ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m0
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	x,2,2
  20              		.comm	xQueueRegistry,80,4
  21              		.section	.text.xQueueGenericReset,"ax",%progbits
  22              		.align	2
  23              		.global	xQueueGenericReset
  24              		.code	16
  25              		.thumb_func
  26              		.type	xQueueGenericReset, %function
  27              	xQueueGenericReset:
  28              	.LFB0:
  29              		.file 1 "..\\FreeRTOS\\Source\\queue.c"
   1:..\FreeRTOS\Source/queue.c **** /*
   2:..\FreeRTOS\Source/queue.c ****  * FreeRTOS Kernel V10.4.3
   3:..\FreeRTOS\Source/queue.c ****  * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:..\FreeRTOS\Source/queue.c ****  *
   5:..\FreeRTOS\Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   6:..\FreeRTOS\Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   7:..\FreeRTOS\Source/queue.c ****  * the Software without restriction, including without limitation the rights to
   8:..\FreeRTOS\Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   9:..\FreeRTOS\Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  10:..\FreeRTOS\Source/queue.c ****  * subject to the following conditions:
  11:..\FreeRTOS\Source/queue.c ****  *
  12:..\FreeRTOS\Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  13:..\FreeRTOS\Source/queue.c ****  * copies or substantial portions of the Software.
  14:..\FreeRTOS\Source/queue.c ****  *
  15:..\FreeRTOS\Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  16:..\FreeRTOS\Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  17:..\FreeRTOS\Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  18:..\FreeRTOS\Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  19:..\FreeRTOS\Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  20:..\FreeRTOS\Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  21:..\FreeRTOS\Source/queue.c ****  *
  22:..\FreeRTOS\Source/queue.c ****  * https://www.FreeRTOS.org
  23:..\FreeRTOS\Source/queue.c ****  * https://github.com/FreeRTOS
  24:..\FreeRTOS\Source/queue.c ****  *
  25:..\FreeRTOS\Source/queue.c ****  */
  26:..\FreeRTOS\Source/queue.c **** 
  27:..\FreeRTOS\Source/queue.c **** #include <stdlib.h>
  28:..\FreeRTOS\Source/queue.c **** #include <string.h>
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 2


  29:..\FreeRTOS\Source/queue.c **** 
  30:..\FreeRTOS\Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  31:..\FreeRTOS\Source/queue.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  32:..\FreeRTOS\Source/queue.c ****  * task.h is included from an application file. */
  33:..\FreeRTOS\Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  34:..\FreeRTOS\Source/queue.c **** 
  35:..\FreeRTOS\Source/queue.c **** #include "FreeRTOS.h"
  36:..\FreeRTOS\Source/queue.c **** #include "task.h"
  37:..\FreeRTOS\Source/queue.c **** #include "queue.h"
  38:..\FreeRTOS\Source/queue.c **** 
  39:..\FreeRTOS\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  40:..\FreeRTOS\Source/queue.c ****     #include "croutine.h"
  41:..\FreeRTOS\Source/queue.c **** #endif
  42:..\FreeRTOS\Source/queue.c **** 
  43:..\FreeRTOS\Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  44:..\FreeRTOS\Source/queue.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  45:..\FreeRTOS\Source/queue.c ****  * for the header files above, but not in this file, in order to generate the
  46:..\FreeRTOS\Source/queue.c ****  * correct privileged Vs unprivileged linkage and placement. */
  47:..\FreeRTOS\Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  48:..\FreeRTOS\Source/queue.c **** 
  49:..\FreeRTOS\Source/queue.c **** 
  50:..\FreeRTOS\Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  51:..\FreeRTOS\Source/queue.c **** #define queueUNLOCKED             ( ( int8_t ) -1 )
  52:..\FreeRTOS\Source/queue.c **** #define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
  53:..\FreeRTOS\Source/queue.c **** #define queueINT8_MAX             ( ( int8_t ) 127 )
  54:..\FreeRTOS\Source/queue.c **** 
  55:..\FreeRTOS\Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  56:..\FreeRTOS\Source/queue.c ****  * pcTail members are used as pointers into the queue storage area.  When the
  57:..\FreeRTOS\Source/queue.c ****  * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  58:..\FreeRTOS\Source/queue.c ****  * not necessary, and the pcHead pointer is set to NULL to indicate that the
  59:..\FreeRTOS\Source/queue.c ****  * structure instead holds a pointer to the mutex holder (if any).  Map alternative
  60:..\FreeRTOS\Source/queue.c ****  * names to the pcHead and structure member to ensure the readability of the code
  61:..\FreeRTOS\Source/queue.c ****  * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  62:..\FreeRTOS\Source/queue.c ****  * a union as their usage is mutually exclusive dependent on what the queue is
  63:..\FreeRTOS\Source/queue.c ****  * being used for. */
  64:..\FreeRTOS\Source/queue.c **** #define uxQueueType               pcHead
  65:..\FreeRTOS\Source/queue.c **** #define queueQUEUE_IS_MUTEX       NULL
  66:..\FreeRTOS\Source/queue.c **** 
  67:..\FreeRTOS\Source/queue.c **** typedef struct QueuePointers
  68:..\FreeRTOS\Source/queue.c **** {
  69:..\FreeRTOS\Source/queue.c ****     int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more by
  70:..\FreeRTOS\Source/queue.c ****     int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the str
  71:..\FreeRTOS\Source/queue.c **** } QueuePointers_t;
  72:..\FreeRTOS\Source/queue.c **** 
  73:..\FreeRTOS\Source/queue.c **** typedef struct SemaphoreData
  74:..\FreeRTOS\Source/queue.c **** {
  75:..\FreeRTOS\Source/queue.c ****     TaskHandle_t xMutexHolder;        /*< The handle of the task that holds the mutex. */
  76:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxRecursiveCallCount; /*< Maintains a count of the number of times a recursive mute
  77:..\FreeRTOS\Source/queue.c **** } SemaphoreData_t;
  78:..\FreeRTOS\Source/queue.c **** 
  79:..\FreeRTOS\Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  80:..\FreeRTOS\Source/queue.c ****  * zero. */
  81:..\FreeRTOS\Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
  82:..\FreeRTOS\Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
  83:..\FreeRTOS\Source/queue.c **** 
  84:..\FreeRTOS\Source/queue.c **** #if ( configUSE_PREEMPTION == 0 )
  85:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 3


  86:..\FreeRTOS\Source/queue.c **** /* If the cooperative scheduler is being used then a yield should not be
  87:..\FreeRTOS\Source/queue.c ****  * performed just because a higher priority task has been woken. */
  88:..\FreeRTOS\Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()
  89:..\FreeRTOS\Source/queue.c **** #else
  90:..\FreeRTOS\Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  91:..\FreeRTOS\Source/queue.c **** #endif
  92:..\FreeRTOS\Source/queue.c **** 
  93:..\FreeRTOS\Source/queue.c **** /*
  94:..\FreeRTOS\Source/queue.c ****  * Definition of the queue used by the scheduler.
  95:..\FreeRTOS\Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  96:..\FreeRTOS\Source/queue.c ****  * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
  97:..\FreeRTOS\Source/queue.c ****  */
  98:..\FreeRTOS\Source/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
  99:..\FreeRTOS\Source/queue.c **** {
 100:..\FreeRTOS\Source/queue.c ****     int8_t * pcHead;           /*< Points to the beginning of the queue storage area. */
 101:..\FreeRTOS\Source/queue.c ****     int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. */
 102:..\FreeRTOS\Source/queue.c **** 
 103:..\FreeRTOS\Source/queue.c ****     union
 104:..\FreeRTOS\Source/queue.c ****     {
 105:..\FreeRTOS\Source/queue.c ****         QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a 
 106:..\FreeRTOS\Source/queue.c ****         SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a 
 107:..\FreeRTOS\Source/queue.c ****     } u;
 108:..\FreeRTOS\Source/queue.c **** 
 109:..\FreeRTOS\Source/queue.c ****     List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto
 110:..\FreeRTOS\Source/queue.c ****     List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from
 111:..\FreeRTOS\Source/queue.c **** 
 112:..\FreeRTOS\Source/queue.c ****     volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. */
 113:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxLength;                   /*< The length of the queue defined as the number of it
 114:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. */
 115:..\FreeRTOS\Source/queue.c **** 
 116:..\FreeRTOS\Source/queue.c ****     volatile int8_t cRxLock;                /*< Stores the number of items received from the queue 
 117:..\FreeRTOS\Source/queue.c ****     volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue
 118:..\FreeRTOS\Source/queue.c **** 
 119:..\FreeRTOS\Source/queue.c ****     #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 120:..\FreeRTOS\Source/queue.c ****         uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was static
 121:..\FreeRTOS\Source/queue.c ****     #endif
 122:..\FreeRTOS\Source/queue.c **** 
 123:..\FreeRTOS\Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 124:..\FreeRTOS\Source/queue.c ****         struct QueueDefinition * pxQueueSetContainer;
 125:..\FreeRTOS\Source/queue.c ****     #endif
 126:..\FreeRTOS\Source/queue.c **** 
 127:..\FreeRTOS\Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 128:..\FreeRTOS\Source/queue.c ****         UBaseType_t uxQueueNumber;
 129:..\FreeRTOS\Source/queue.c ****         uint8_t ucQueueType;
 130:..\FreeRTOS\Source/queue.c ****     #endif
 131:..\FreeRTOS\Source/queue.c **** } xQUEUE;
 132:..\FreeRTOS\Source/queue.c **** 
 133:..\FreeRTOS\Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 134:..\FreeRTOS\Source/queue.c ****  * name below to enable the use of older kernel aware debuggers. */
 135:..\FreeRTOS\Source/queue.c **** typedef xQUEUE Queue_t;
 136:..\FreeRTOS\Source/queue.c **** 
 137:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 138:..\FreeRTOS\Source/queue.c **** 
 139:..\FreeRTOS\Source/queue.c **** /*
 140:..\FreeRTOS\Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 141:..\FreeRTOS\Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 142:..\FreeRTOS\Source/queue.c ****  */
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 4


 143:..\FreeRTOS\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 144:..\FreeRTOS\Source/queue.c **** 
 145:..\FreeRTOS\Source/queue.c **** /* The type stored within the queue registry array.  This allows a name
 146:..\FreeRTOS\Source/queue.c ****  * to be assigned to each queue making kernel aware debugging a little
 147:..\FreeRTOS\Source/queue.c ****  * more user friendly. */
 148:..\FreeRTOS\Source/queue.c ****     typedef struct QUEUE_REGISTRY_ITEM
 149:..\FreeRTOS\Source/queue.c ****     {
 150:..\FreeRTOS\Source/queue.c ****         const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and s
 151:..\FreeRTOS\Source/queue.c ****         QueueHandle_t xHandle;
 152:..\FreeRTOS\Source/queue.c ****     } xQueueRegistryItem;
 153:..\FreeRTOS\Source/queue.c **** 
 154:..\FreeRTOS\Source/queue.c **** /* The old xQueueRegistryItem name is maintained above then typedefed to the
 155:..\FreeRTOS\Source/queue.c ****  * new xQueueRegistryItem name below to enable the use of older kernel aware
 156:..\FreeRTOS\Source/queue.c ****  * debuggers. */
 157:..\FreeRTOS\Source/queue.c ****     typedef xQueueRegistryItem QueueRegistryItem_t;
 158:..\FreeRTOS\Source/queue.c **** 
 159:..\FreeRTOS\Source/queue.c **** /* The queue registry is simply an array of QueueRegistryItem_t structures.
 160:..\FreeRTOS\Source/queue.c ****  * The pcQueueName member of a structure being NULL is indicative of the
 161:..\FreeRTOS\Source/queue.c ****  * array position being vacant. */
 162:..\FreeRTOS\Source/queue.c ****     PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 163:..\FreeRTOS\Source/queue.c **** 
 164:..\FreeRTOS\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 165:..\FreeRTOS\Source/queue.c **** 
 166:..\FreeRTOS\Source/queue.c **** /*
 167:..\FreeRTOS\Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 168:..\FreeRTOS\Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 169:..\FreeRTOS\Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 170:..\FreeRTOS\Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 171:..\FreeRTOS\Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 172:..\FreeRTOS\Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 173:..\FreeRTOS\Source/queue.c ****  */
 174:..\FreeRTOS\Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 175:..\FreeRTOS\Source/queue.c **** 
 176:..\FreeRTOS\Source/queue.c **** /*
 177:..\FreeRTOS\Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 178:..\FreeRTOS\Source/queue.c ****  *
 179:..\FreeRTOS\Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 180:..\FreeRTOS\Source/queue.c ****  */
 181:..\FreeRTOS\Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 182:..\FreeRTOS\Source/queue.c **** 
 183:..\FreeRTOS\Source/queue.c **** /*
 184:..\FreeRTOS\Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 185:..\FreeRTOS\Source/queue.c ****  *
 186:..\FreeRTOS\Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 187:..\FreeRTOS\Source/queue.c ****  */
 188:..\FreeRTOS\Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 189:..\FreeRTOS\Source/queue.c **** 
 190:..\FreeRTOS\Source/queue.c **** /*
 191:..\FreeRTOS\Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 192:..\FreeRTOS\Source/queue.c ****  * back of the queue.
 193:..\FreeRTOS\Source/queue.c ****  */
 194:..\FreeRTOS\Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
 195:..\FreeRTOS\Source/queue.c ****                                       const void * pvItemToQueue,
 196:..\FreeRTOS\Source/queue.c ****                                       const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
 197:..\FreeRTOS\Source/queue.c **** 
 198:..\FreeRTOS\Source/queue.c **** /*
 199:..\FreeRTOS\Source/queue.c ****  * Copies an item out of a queue.
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 5


 200:..\FreeRTOS\Source/queue.c ****  */
 201:..\FreeRTOS\Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
 202:..\FreeRTOS\Source/queue.c ****                                   void * const pvBuffer ) PRIVILEGED_FUNCTION;
 203:..\FreeRTOS\Source/queue.c **** 
 204:..\FreeRTOS\Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 205:..\FreeRTOS\Source/queue.c **** 
 206:..\FreeRTOS\Source/queue.c **** /*
 207:..\FreeRTOS\Source/queue.c ****  * Checks to see if a queue is a member of a queue set, and if so, notifies
 208:..\FreeRTOS\Source/queue.c ****  * the queue set that the queue contains data.
 209:..\FreeRTOS\Source/queue.c ****  */
 210:..\FreeRTOS\Source/queue.c ****     static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTI
 211:..\FreeRTOS\Source/queue.c **** #endif
 212:..\FreeRTOS\Source/queue.c **** 
 213:..\FreeRTOS\Source/queue.c **** /*
 214:..\FreeRTOS\Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 215:..\FreeRTOS\Source/queue.c ****  * dynamically to fill in the structure's members.
 216:..\FreeRTOS\Source/queue.c ****  */
 217:..\FreeRTOS\Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 218:..\FreeRTOS\Source/queue.c ****                                    const UBaseType_t uxItemSize,
 219:..\FreeRTOS\Source/queue.c ****                                    uint8_t * pucQueueStorage,
 220:..\FreeRTOS\Source/queue.c ****                                    const uint8_t ucQueueType,
 221:..\FreeRTOS\Source/queue.c ****                                    Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 222:..\FreeRTOS\Source/queue.c **** 
 223:..\FreeRTOS\Source/queue.c **** /*
 224:..\FreeRTOS\Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 225:..\FreeRTOS\Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 226:..\FreeRTOS\Source/queue.c ****  * as a mutex.
 227:..\FreeRTOS\Source/queue.c ****  */
 228:..\FreeRTOS\Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 229:..\FreeRTOS\Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 230:..\FreeRTOS\Source/queue.c **** #endif
 231:..\FreeRTOS\Source/queue.c **** 
 232:..\FreeRTOS\Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 233:..\FreeRTOS\Source/queue.c **** 
 234:..\FreeRTOS\Source/queue.c **** /*
 235:..\FreeRTOS\Source/queue.c ****  * If a task waiting for a mutex causes the mutex holder to inherit a
 236:..\FreeRTOS\Source/queue.c ****  * priority, but the waiting task times out, then the holder should
 237:..\FreeRTOS\Source/queue.c ****  * disinherit the priority - but only down to the highest priority of any
 238:..\FreeRTOS\Source/queue.c ****  * other tasks that are waiting for the same mutex.  This function returns
 239:..\FreeRTOS\Source/queue.c ****  * that priority.
 240:..\FreeRTOS\Source/queue.c ****  */
 241:..\FreeRTOS\Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVIL
 242:..\FreeRTOS\Source/queue.c **** #endif
 243:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 244:..\FreeRTOS\Source/queue.c **** 
 245:..\FreeRTOS\Source/queue.c **** /*
 246:..\FreeRTOS\Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 247:..\FreeRTOS\Source/queue.c ****  * accessing the queue event lists.
 248:..\FreeRTOS\Source/queue.c ****  */
 249:..\FreeRTOS\Source/queue.c **** #define prvLockQueue( pxQueue )                            \
 250:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();                                  \
 251:..\FreeRTOS\Source/queue.c ****     {                                                      \
 252:..\FreeRTOS\Source/queue.c ****         if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
 253:..\FreeRTOS\Source/queue.c ****         {                                                  \
 254:..\FreeRTOS\Source/queue.c ****             ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
 255:..\FreeRTOS\Source/queue.c ****         }                                                  \
 256:..\FreeRTOS\Source/queue.c ****         if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 6


 257:..\FreeRTOS\Source/queue.c ****         {                                                  \
 258:..\FreeRTOS\Source/queue.c ****             ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
 259:..\FreeRTOS\Source/queue.c ****         }                                                  \
 260:..\FreeRTOS\Source/queue.c ****     }                                                      \
 261:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL()
 262:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 263:..\FreeRTOS\Source/queue.c **** 
 264:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
 265:..\FreeRTOS\Source/queue.c ****                                BaseType_t xNewQueue )
 266:..\FreeRTOS\Source/queue.c **** {
  30              		.loc 1 266 0
  31              		.cfi_startproc
  32              		@ args = 0, pretend = 0, frame = 16
  33              		@ frame_needed = 1, uses_anonymous_args = 0
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 84B0     		sub	sp, sp, #16
  39              		.cfi_def_cfa_offset 24
  40 0004 00AF     		add	r7, sp, #0
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
  43 0008 3960     		str	r1, [r7]
 267:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
  44              		.loc 1 267 0
  45 000a 7B68     		ldr	r3, [r7, #4]
  46 000c FB60     		str	r3, [r7, #12]
 268:..\FreeRTOS\Source/queue.c **** 
 269:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
  47              		.loc 1 269 0
  48 000e 274B     		ldr	r3, .L7
  49 0010 1B88     		ldrh	r3, [r3]
  50 0012 002B     		cmp	r3, #0
  51 0014 01D1     		bne	.L2
  52              		.loc 1 269 0 is_stmt 0 discriminator 1
  53              		.syntax divided
  54              	@ 269 "..\FreeRTOS\Source\queue.c" 1
  55 0016 72B6     		 cpsid i 
  56              	@ 0 "" 2
  57              		.thumb
  58              		.syntax unified
  59              	.L3:
  60 0018 FEE7     		b	.L3
  61              	.L2:
 270:..\FreeRTOS\Source/queue.c **** 
 271:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();
  62              		.loc 1 271 0 is_stmt 1
  63 001a FFF7FEFF 		bl	vPortEnterCritical
 272:..\FreeRTOS\Source/queue.c ****     {
 273:..\FreeRTOS\Source/queue.c ****         pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /
  64              		.loc 1 273 0
  65 001e FB68     		ldr	r3, [r7, #12]
  66 0020 1A68     		ldr	r2, [r3]
  67 0022 FB68     		ldr	r3, [r7, #12]
  68 0024 D96B     		ldr	r1, [r3, #60]
  69 0026 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 7


  70 0028 1B6C     		ldr	r3, [r3, #64]
  71 002a 4B43     		muls	r3, r1
  72 002c D218     		adds	r2, r2, r3
  73 002e FB68     		ldr	r3, [r7, #12]
  74 0030 9A60     		str	r2, [r3, #8]
 274:..\FreeRTOS\Source/queue.c ****         pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  75              		.loc 1 274 0
  76 0032 FB68     		ldr	r3, [r7, #12]
  77 0034 0022     		movs	r2, #0
  78 0036 9A63     		str	r2, [r3, #56]
 275:..\FreeRTOS\Source/queue.c ****         pxQueue->pcWriteTo = pxQueue->pcHead;
  79              		.loc 1 275 0
  80 0038 FB68     		ldr	r3, [r7, #12]
  81 003a 1A68     		ldr	r2, [r3]
  82 003c FB68     		ldr	r3, [r7, #12]
  83 003e 5A60     		str	r2, [r3, #4]
 276:..\FreeRTOS\Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->ux
  84              		.loc 1 276 0
  85 0040 FB68     		ldr	r3, [r7, #12]
  86 0042 1A68     		ldr	r2, [r3]
  87 0044 FB68     		ldr	r3, [r7, #12]
  88 0046 DB6B     		ldr	r3, [r3, #60]
  89 0048 591E     		subs	r1, r3, #1
  90 004a FB68     		ldr	r3, [r7, #12]
  91 004c 1B6C     		ldr	r3, [r3, #64]
  92 004e 4B43     		muls	r3, r1
  93 0050 D218     		adds	r2, r2, r3
  94 0052 FB68     		ldr	r3, [r7, #12]
  95 0054 DA60     		str	r2, [r3, #12]
 277:..\FreeRTOS\Source/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
  96              		.loc 1 277 0
  97 0056 FB68     		ldr	r3, [r7, #12]
  98 0058 4422     		movs	r2, #68
  99 005a FF21     		movs	r1, #255
 100 005c 9954     		strb	r1, [r3, r2]
 278:..\FreeRTOS\Source/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 101              		.loc 1 278 0
 102 005e FB68     		ldr	r3, [r7, #12]
 103 0060 4522     		movs	r2, #69
 104 0062 FF21     		movs	r1, #255
 105 0064 9954     		strb	r1, [r3, r2]
 279:..\FreeRTOS\Source/queue.c **** 
 280:..\FreeRTOS\Source/queue.c ****         if( xNewQueue == pdFALSE )
 106              		.loc 1 280 0
 107 0066 3B68     		ldr	r3, [r7]
 108 0068 002B     		cmp	r3, #0
 109 006a 0DD1     		bne	.L4
 281:..\FreeRTOS\Source/queue.c ****         {
 282:..\FreeRTOS\Source/queue.c ****             /* If there are tasks blocked waiting to read from the queue, then
 283:..\FreeRTOS\Source/queue.c ****              * the tasks will remain blocked as after this function exits the queue
 284:..\FreeRTOS\Source/queue.c ****              * will still be empty.  If there are tasks blocked waiting to write to
 285:..\FreeRTOS\Source/queue.c ****              * the queue, then one should be unblocked as after this function exits
 286:..\FreeRTOS\Source/queue.c ****              * it will be possible to write to it. */
 287:..\FreeRTOS\Source/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 110              		.loc 1 287 0
 111 006c FB68     		ldr	r3, [r7, #12]
 112 006e 1B69     		ldr	r3, [r3, #16]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 8


 113 0070 002B     		cmp	r3, #0
 114 0072 13D0     		beq	.L5
 288:..\FreeRTOS\Source/queue.c ****             {
 289:..\FreeRTOS\Source/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 115              		.loc 1 289 0
 116 0074 FB68     		ldr	r3, [r7, #12]
 117 0076 1033     		adds	r3, r3, #16
 118 0078 1800     		movs	r0, r3
 119 007a FFF7FEFF 		bl	xTaskRemoveFromEventList
 120 007e 031E     		subs	r3, r0, #0
 121 0080 0CD0     		beq	.L5
 290:..\FreeRTOS\Source/queue.c ****                 {
 291:..\FreeRTOS\Source/queue.c ****                     queueYIELD_IF_USING_PREEMPTION();
 122              		.loc 1 291 0
 123 0082 FFF7FEFF 		bl	vPortYield
 124 0086 09E0     		b	.L5
 125              	.L4:
 292:..\FreeRTOS\Source/queue.c ****                 }
 293:..\FreeRTOS\Source/queue.c ****                 else
 294:..\FreeRTOS\Source/queue.c ****                 {
 295:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 296:..\FreeRTOS\Source/queue.c ****                 }
 297:..\FreeRTOS\Source/queue.c ****             }
 298:..\FreeRTOS\Source/queue.c ****             else
 299:..\FreeRTOS\Source/queue.c ****             {
 300:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 301:..\FreeRTOS\Source/queue.c ****             }
 302:..\FreeRTOS\Source/queue.c ****         }
 303:..\FreeRTOS\Source/queue.c ****         else
 304:..\FreeRTOS\Source/queue.c ****         {
 305:..\FreeRTOS\Source/queue.c ****             /* Ensure the event queues start in the correct state. */
 306:..\FreeRTOS\Source/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 126              		.loc 1 306 0
 127 0088 FB68     		ldr	r3, [r7, #12]
 128 008a 1033     		adds	r3, r3, #16
 129 008c 1800     		movs	r0, r3
 130 008e FFF7FEFF 		bl	vListInitialise
 307:..\FreeRTOS\Source/queue.c ****             vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 131              		.loc 1 307 0
 132 0092 FB68     		ldr	r3, [r7, #12]
 133 0094 2433     		adds	r3, r3, #36
 134 0096 1800     		movs	r0, r3
 135 0098 FFF7FEFF 		bl	vListInitialise
 136              	.L5:
 308:..\FreeRTOS\Source/queue.c ****         }
 309:..\FreeRTOS\Source/queue.c ****     }
 310:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL();
 137              		.loc 1 310 0
 138 009c FFF7FEFF 		bl	vPortExitCritical
 311:..\FreeRTOS\Source/queue.c **** 
 312:..\FreeRTOS\Source/queue.c ****     /* A value is returned for calling semantic consistency with previous
 313:..\FreeRTOS\Source/queue.c ****      * versions. */
 314:..\FreeRTOS\Source/queue.c ****     return pdPASS;
 139              		.loc 1 314 0
 140 00a0 0123     		movs	r3, #1
 315:..\FreeRTOS\Source/queue.c **** }
 141              		.loc 1 315 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 9


 142 00a2 1800     		movs	r0, r3
 143 00a4 BD46     		mov	sp, r7
 144 00a6 04B0     		add	sp, sp, #16
 145              		@ sp needed
 146 00a8 80BD     		pop	{r7, pc}
 147              	.L8:
 148 00aa C046     		.align	2
 149              	.L7:
 150 00ac 00000000 		.word	x
 151              		.cfi_endproc
 152              	.LFE0:
 153              		.size	xQueueGenericReset, .-xQueueGenericReset
 154              		.section	.text.xQueueGenericCreateStatic,"ax",%progbits
 155              		.align	2
 156              		.global	xQueueGenericCreateStatic
 157              		.code	16
 158              		.thumb_func
 159              		.type	xQueueGenericCreateStatic, %function
 160              	xQueueGenericCreateStatic:
 161              	.LFB1:
 316:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 317:..\FreeRTOS\Source/queue.c **** 
 318:..\FreeRTOS\Source/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 319:..\FreeRTOS\Source/queue.c **** 
 320:..\FreeRTOS\Source/queue.c ****     QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
 321:..\FreeRTOS\Source/queue.c ****                                              const UBaseType_t uxItemSize,
 322:..\FreeRTOS\Source/queue.c ****                                              uint8_t * pucQueueStorage,
 323:..\FreeRTOS\Source/queue.c ****                                              StaticQueue_t * pxStaticQueue,
 324:..\FreeRTOS\Source/queue.c ****                                              const uint8_t ucQueueType )
 325:..\FreeRTOS\Source/queue.c ****     {
 162              		.loc 1 325 0
 163              		.cfi_startproc
 164              		@ args = 4, pretend = 0, frame = 24
 165              		@ frame_needed = 1, uses_anonymous_args = 0
 166 0000 90B5     		push	{r4, r7, lr}
 167              		.cfi_def_cfa_offset 12
 168              		.cfi_offset 4, -12
 169              		.cfi_offset 7, -8
 170              		.cfi_offset 14, -4
 171 0002 89B0     		sub	sp, sp, #36
 172              		.cfi_def_cfa_offset 48
 173 0004 02AF     		add	r7, sp, #8
 174              		.cfi_def_cfa 7, 40
 175 0006 F860     		str	r0, [r7, #12]
 176 0008 B960     		str	r1, [r7, #8]
 177 000a 7A60     		str	r2, [r7, #4]
 178 000c 3B60     		str	r3, [r7]
 326:..\FreeRTOS\Source/queue.c ****         Queue_t * pxNewQueue;
 327:..\FreeRTOS\Source/queue.c **** 
 328:..\FreeRTOS\Source/queue.c ****         configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 179              		.loc 1 328 0
 180 000e 1E4B     		ldr	r3, .L28
 181 0010 1B88     		ldrh	r3, [r3]
 182 0012 002B     		cmp	r3, #0
 183 0014 01D1     		bne	.L10
 184              		.loc 1 328 0 is_stmt 0 discriminator 1
 185              		.syntax divided
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 10


 186              	@ 328 "..\FreeRTOS\Source\queue.c" 1
 187 0016 72B6     		 cpsid i 
 188              	@ 0 "" 2
 189              		.thumb
 190              		.syntax unified
 191              	.L11:
 192 0018 FEE7     		b	.L11
 193              	.L10:
 329:..\FreeRTOS\Source/queue.c **** 
 330:..\FreeRTOS\Source/queue.c ****         /* The StaticQueue_t structure and the queue storage area must be
 331:..\FreeRTOS\Source/queue.c ****          * supplied. */
 332:..\FreeRTOS\Source/queue.c ****         configASSERT( pxStaticQueue != NULL );
 194              		.loc 1 332 0 is_stmt 1
 195 001a 1B4B     		ldr	r3, .L28
 196 001c 1B88     		ldrh	r3, [r3]
 197 001e 002B     		cmp	r3, #0
 198 0020 01D1     		bne	.L12
 199              		.loc 1 332 0 is_stmt 0 discriminator 1
 200              		.syntax divided
 201              	@ 332 "..\FreeRTOS\Source\queue.c" 1
 202 0022 72B6     		 cpsid i 
 203              	@ 0 "" 2
 204              		.thumb
 205              		.syntax unified
 206              	.L13:
 207              		.loc 1 332 0 discriminator 2
 208 0024 FEE7     		b	.L13
 209              	.L12:
 333:..\FreeRTOS\Source/queue.c **** 
 334:..\FreeRTOS\Source/queue.c ****         /* A queue storage area should be provided if the item size is not 0, and
 335:..\FreeRTOS\Source/queue.c ****          * should not be provided if the item size is 0. */
 336:..\FreeRTOS\Source/queue.c ****         configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 210              		.loc 1 336 0 is_stmt 1
 211 0026 184B     		ldr	r3, .L28
 212 0028 1B88     		ldrh	r3, [r3]
 213 002a 002B     		cmp	r3, #0
 214 002c 01D1     		bne	.L14
 215              		.loc 1 336 0 is_stmt 0 discriminator 1
 216              		.syntax divided
 217              	@ 336 "..\FreeRTOS\Source\queue.c" 1
 218 002e 72B6     		 cpsid i 
 219              	@ 0 "" 2
 220              		.thumb
 221              		.syntax unified
 222              	.L15:
 223              		.loc 1 336 0 discriminator 3
 224 0030 FEE7     		b	.L15
 225              	.L14:
 226              		.loc 1 336 0 discriminator 2
 227 0032 7B68     		ldr	r3, [r7, #4]
 337:..\FreeRTOS\Source/queue.c ****         configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 228              		.loc 1 337 0 is_stmt 1 discriminator 2
 229 0034 144B     		ldr	r3, .L28
 230 0036 1B88     		ldrh	r3, [r3]
 231 0038 002B     		cmp	r3, #0
 232 003a 01D1     		bne	.L19
 233              		.loc 1 337 0 is_stmt 0 discriminator 1
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 11


 234              		.syntax divided
 235              	@ 337 "..\FreeRTOS\Source\queue.c" 1
 236 003c 72B6     		 cpsid i 
 237              	@ 0 "" 2
 238              		.thumb
 239              		.syntax unified
 240              	.L20:
 241              		.loc 1 337 0 discriminator 4
 242 003e FEE7     		b	.L20
 243              	.L19:
 244              		.loc 1 337 0 discriminator 2
 245 0040 7B68     		ldr	r3, [r7, #4]
 246              	.LBB2:
 338:..\FreeRTOS\Source/queue.c **** 
 339:..\FreeRTOS\Source/queue.c ****         #if ( configASSERT_DEFINED == 1 )
 340:..\FreeRTOS\Source/queue.c ****             {
 341:..\FreeRTOS\Source/queue.c ****                 /* Sanity check that the size of the structure used to declare a
 342:..\FreeRTOS\Source/queue.c ****                  * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 343:..\FreeRTOS\Source/queue.c ****                  * the real queue and semaphore structures. */
 344:..\FreeRTOS\Source/queue.c ****                 volatile size_t xSize = sizeof( StaticQueue_t );
 247              		.loc 1 344 0 is_stmt 1 discriminator 2
 248 0042 4823     		movs	r3, #72
 249 0044 3B61     		str	r3, [r7, #16]
 345:..\FreeRTOS\Source/queue.c ****                 configASSERT( xSize == sizeof( Queue_t ) );
 250              		.loc 1 345 0 discriminator 2
 251 0046 104B     		ldr	r3, .L28
 252 0048 1B88     		ldrh	r3, [r3]
 253 004a 002B     		cmp	r3, #0
 254 004c 01D1     		bne	.L24
 255              		.loc 1 345 0 is_stmt 0 discriminator 1
 256              		.syntax divided
 257              	@ 345 "..\FreeRTOS\Source\queue.c" 1
 258 004e 72B6     		 cpsid i 
 259              	@ 0 "" 2
 260              		.thumb
 261              		.syntax unified
 262              	.L25:
 263              		.loc 1 345 0 discriminator 5
 264 0050 FEE7     		b	.L25
 265              	.L24:
 266              		.loc 1 345 0 discriminator 2
 267 0052 3B69     		ldr	r3, [r7, #16]
 346:..\FreeRTOS\Source/queue.c ****                 ( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 268              		.loc 1 346 0 is_stmt 1 discriminator 2
 269 0054 3B69     		ldr	r3, [r7, #16]
 270              	.LBE2:
 347:..\FreeRTOS\Source/queue.c ****             }
 348:..\FreeRTOS\Source/queue.c ****         #endif /* configASSERT_DEFINED */
 349:..\FreeRTOS\Source/queue.c **** 
 350:..\FreeRTOS\Source/queue.c ****         /* The address of a statically allocated queue was passed in, use it.
 351:..\FreeRTOS\Source/queue.c ****          * The address of a statically allocated storage area was also passed in
 352:..\FreeRTOS\Source/queue.c ****          * but is already set. */
 353:..\FreeRTOS\Source/queue.c ****         pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the str
 271              		.loc 1 353 0 discriminator 2
 272 0056 3B68     		ldr	r3, [r7]
 273 0058 7B61     		str	r3, [r7, #20]
 354:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 12


 355:..\FreeRTOS\Source/queue.c ****         if( pxNewQueue != NULL )
 274              		.loc 1 355 0 discriminator 2
 275 005a 7B69     		ldr	r3, [r7, #20]
 276 005c 002B     		cmp	r3, #0
 277 005e 0ED0     		beq	.L26
 356:..\FreeRTOS\Source/queue.c ****         {
 357:..\FreeRTOS\Source/queue.c ****             #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 358:..\FreeRTOS\Source/queue.c ****                 {
 359:..\FreeRTOS\Source/queue.c ****                     /* Queues can be allocated wither statically or dynamically, so
 360:..\FreeRTOS\Source/queue.c ****                      * note this queue was allocated statically in case the queue is
 361:..\FreeRTOS\Source/queue.c ****                      * later deleted. */
 362:..\FreeRTOS\Source/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdTRUE;
 278              		.loc 1 362 0
 279 0060 7B69     		ldr	r3, [r7, #20]
 280 0062 4622     		movs	r2, #70
 281 0064 0121     		movs	r1, #1
 282 0066 9954     		strb	r1, [r3, r2]
 363:..\FreeRTOS\Source/queue.c ****                 }
 364:..\FreeRTOS\Source/queue.c ****             #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 365:..\FreeRTOS\Source/queue.c **** 
 366:..\FreeRTOS\Source/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 283              		.loc 1 366 0
 284 0068 2823     		movs	r3, #40
 285 006a FB18     		adds	r3, r7, r3
 286 006c 1C78     		ldrb	r4, [r3]
 287 006e 7A68     		ldr	r2, [r7, #4]
 288 0070 B968     		ldr	r1, [r7, #8]
 289 0072 F868     		ldr	r0, [r7, #12]
 290 0074 7B69     		ldr	r3, [r7, #20]
 291 0076 0093     		str	r3, [sp]
 292 0078 2300     		movs	r3, r4
 293 007a FFF7FEFF 		bl	prvInitialiseNewQueue
 294              	.L26:
 367:..\FreeRTOS\Source/queue.c ****         }
 368:..\FreeRTOS\Source/queue.c ****         else
 369:..\FreeRTOS\Source/queue.c ****         {
 370:..\FreeRTOS\Source/queue.c ****             traceQUEUE_CREATE_FAILED( ucQueueType );
 371:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 372:..\FreeRTOS\Source/queue.c ****         }
 373:..\FreeRTOS\Source/queue.c **** 
 374:..\FreeRTOS\Source/queue.c ****         return pxNewQueue;
 295              		.loc 1 374 0
 296 007e 7B69     		ldr	r3, [r7, #20]
 375:..\FreeRTOS\Source/queue.c ****     }
 297              		.loc 1 375 0
 298 0080 1800     		movs	r0, r3
 299 0082 BD46     		mov	sp, r7
 300 0084 07B0     		add	sp, sp, #28
 301              		@ sp needed
 302 0086 90BD     		pop	{r4, r7, pc}
 303              	.L29:
 304              		.align	2
 305              	.L28:
 306 0088 00000000 		.word	x
 307              		.cfi_endproc
 308              	.LFE1:
 309              		.size	xQueueGenericCreateStatic, .-xQueueGenericCreateStatic
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 13


 310              		.global	__aeabi_uidiv
 311              		.section	.text.xQueueGenericCreate,"ax",%progbits
 312              		.align	2
 313              		.global	xQueueGenericCreate
 314              		.code	16
 315              		.thumb_func
 316              		.type	xQueueGenericCreate, %function
 317              	xQueueGenericCreate:
 318              	.LFB2:
 376:..\FreeRTOS\Source/queue.c **** 
 377:..\FreeRTOS\Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 378:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 379:..\FreeRTOS\Source/queue.c **** 
 380:..\FreeRTOS\Source/queue.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 381:..\FreeRTOS\Source/queue.c **** 
 382:..\FreeRTOS\Source/queue.c ****     QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
 383:..\FreeRTOS\Source/queue.c ****                                        const UBaseType_t uxItemSize,
 384:..\FreeRTOS\Source/queue.c ****                                        const uint8_t ucQueueType )
 385:..\FreeRTOS\Source/queue.c ****     {
 319              		.loc 1 385 0
 320              		.cfi_startproc
 321              		@ args = 0, pretend = 0, frame = 32
 322              		@ frame_needed = 1, uses_anonymous_args = 0
 323 0000 90B5     		push	{r4, r7, lr}
 324              		.cfi_def_cfa_offset 12
 325              		.cfi_offset 4, -12
 326              		.cfi_offset 7, -8
 327              		.cfi_offset 14, -4
 328 0002 8BB0     		sub	sp, sp, #44
 329              		.cfi_def_cfa_offset 56
 330 0004 02AF     		add	r7, sp, #8
 331              		.cfi_def_cfa 7, 48
 332 0006 F860     		str	r0, [r7, #12]
 333 0008 B960     		str	r1, [r7, #8]
 334 000a FB1D     		adds	r3, r7, #7
 335 000c 1A70     		strb	r2, [r3]
 386:..\FreeRTOS\Source/queue.c ****         Queue_t * pxNewQueue;
 387:..\FreeRTOS\Source/queue.c ****         size_t xQueueSizeInBytes;
 388:..\FreeRTOS\Source/queue.c ****         uint8_t * pucQueueStorage;
 389:..\FreeRTOS\Source/queue.c **** 
 390:..\FreeRTOS\Source/queue.c ****         configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 336              		.loc 1 390 0
 337 000e 1F4B     		ldr	r3, .L42
 338 0010 1B88     		ldrh	r3, [r3]
 339 0012 002B     		cmp	r3, #0
 340 0014 01D1     		bne	.L31
 341              		.loc 1 390 0 is_stmt 0 discriminator 1
 342              		.syntax divided
 343              	@ 390 "..\FreeRTOS\Source\queue.c" 1
 344 0016 72B6     		 cpsid i 
 345              	@ 0 "" 2
 346              		.thumb
 347              		.syntax unified
 348              	.L32:
 349 0018 FEE7     		b	.L32
 350              	.L31:
 391:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 14


 392:..\FreeRTOS\Source/queue.c ****         /* Allocate enough space to hold the maximum number of items that
 393:..\FreeRTOS\Source/queue.c ****          * can be in the queue at any time.  It is valid for uxItemSize to be
 394:..\FreeRTOS\Source/queue.c ****          * zero in the case the queue is used as a semaphore. */
 395:..\FreeRTOS\Source/queue.c ****         xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception
 351              		.loc 1 395 0 is_stmt 1
 352 001a FB68     		ldr	r3, [r7, #12]
 353 001c BA68     		ldr	r2, [r7, #8]
 354 001e 5343     		muls	r3, r2
 355 0020 FB61     		str	r3, [r7, #28]
 396:..\FreeRTOS\Source/queue.c **** 
 397:..\FreeRTOS\Source/queue.c ****         /* Check for multiplication overflow. */
 398:..\FreeRTOS\Source/queue.c ****         configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) 
 356              		.loc 1 398 0
 357 0022 1A4B     		ldr	r3, .L42
 358 0024 1B88     		ldrh	r3, [r3]
 359 0026 002B     		cmp	r3, #0
 360 0028 01D1     		bne	.L33
 361              		.loc 1 398 0 is_stmt 0 discriminator 1
 362              		.syntax divided
 363              	@ 398 "..\FreeRTOS\Source\queue.c" 1
 364 002a 72B6     		 cpsid i 
 365              	@ 0 "" 2
 366              		.thumb
 367              		.syntax unified
 368              	.L34:
 369              		.loc 1 398 0 discriminator 2
 370 002c FEE7     		b	.L34
 371              	.L33:
 372 002e BB68     		ldr	r3, [r7, #8]
 373 0030 002B     		cmp	r3, #0
 374 0032 03D0     		beq	.L37
 375              		.loc 1 398 0 discriminator 4
 376 0034 B968     		ldr	r1, [r7, #8]
 377 0036 F869     		ldr	r0, [r7, #28]
 378 0038 FFF7FEFF 		bl	__aeabi_uidiv
 379              	.L37:
 399:..\FreeRTOS\Source/queue.c **** 
 400:..\FreeRTOS\Source/queue.c ****         /* Check for addition overflow. */
 401:..\FreeRTOS\Source/queue.c ****         configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );
 380              		.loc 1 401 0 is_stmt 1
 381 003c 134B     		ldr	r3, .L42
 382 003e 1B88     		ldrh	r3, [r3]
 383 0040 002B     		cmp	r3, #0
 384 0042 01D1     		bne	.L38
 385              		.loc 1 401 0 is_stmt 0 discriminator 1
 386              		.syntax divided
 387              	@ 401 "..\FreeRTOS\Source\queue.c" 1
 388 0044 72B6     		 cpsid i 
 389              	@ 0 "" 2
 390              		.thumb
 391              		.syntax unified
 392              	.L39:
 393              		.loc 1 401 0 discriminator 3
 394 0046 FEE7     		b	.L39
 395              	.L38:
 402:..\FreeRTOS\Source/queue.c **** 
 403:..\FreeRTOS\Source/queue.c ****         /* Allocate the queue and storage area.  Justification for MISRA
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 15


 404:..\FreeRTOS\Source/queue.c ****          * deviation as follows:  pvPortMalloc() always ensures returned memory
 405:..\FreeRTOS\Source/queue.c ****          * blocks are aligned per the requirements of the MCU stack.  In this case
 406:..\FreeRTOS\Source/queue.c ****          * pvPortMalloc() must return a pointer that is guaranteed to meet the
 407:..\FreeRTOS\Source/queue.c ****          * alignment requirements of the Queue_t structure - which in this case
 408:..\FreeRTOS\Source/queue.c ****          * is an int8_t *.  Therefore, whenever the stack alignment requirements
 409:..\FreeRTOS\Source/queue.c ****          * are greater than or equal to the pointer to char requirements the cast
 410:..\FreeRTOS\Source/queue.c ****          * is safe.  In other cases alignment requirements are not strict (one or
 411:..\FreeRTOS\Source/queue.c ****          * two bytes). */
 412:..\FreeRTOS\Source/queue.c ****         pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e
 396              		.loc 1 412 0 is_stmt 1 discriminator 2
 397 0048 FB69     		ldr	r3, [r7, #28]
 398 004a 4833     		adds	r3, r3, #72
 399 004c 1800     		movs	r0, r3
 400 004e FFF7FEFF 		bl	pvPortMalloc
 401 0052 0300     		movs	r3, r0
 402 0054 BB61     		str	r3, [r7, #24]
 413:..\FreeRTOS\Source/queue.c **** 
 414:..\FreeRTOS\Source/queue.c ****         if( pxNewQueue != NULL )
 403              		.loc 1 414 0 discriminator 2
 404 0056 BB69     		ldr	r3, [r7, #24]
 405 0058 002B     		cmp	r3, #0
 406 005a 12D0     		beq	.L40
 415:..\FreeRTOS\Source/queue.c ****         {
 416:..\FreeRTOS\Source/queue.c ****             /* Jump past the queue structure to find the location of the queue
 417:..\FreeRTOS\Source/queue.c ****              * storage area. */
 418:..\FreeRTOS\Source/queue.c ****             pucQueueStorage = ( uint8_t * ) pxNewQueue;
 407              		.loc 1 418 0
 408 005c BB69     		ldr	r3, [r7, #24]
 409 005e 7B61     		str	r3, [r7, #20]
 419:..\FreeRTOS\Source/queue.c ****             pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char 
 410              		.loc 1 419 0
 411 0060 7B69     		ldr	r3, [r7, #20]
 412 0062 4833     		adds	r3, r3, #72
 413 0064 7B61     		str	r3, [r7, #20]
 420:..\FreeRTOS\Source/queue.c **** 
 421:..\FreeRTOS\Source/queue.c ****             #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 422:..\FreeRTOS\Source/queue.c ****                 {
 423:..\FreeRTOS\Source/queue.c ****                     /* Queues can be created either statically or dynamically, so
 424:..\FreeRTOS\Source/queue.c ****                      * note this task was created dynamically in case it is later
 425:..\FreeRTOS\Source/queue.c ****                      * deleted. */
 426:..\FreeRTOS\Source/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
 414              		.loc 1 426 0
 415 0066 BB69     		ldr	r3, [r7, #24]
 416 0068 4622     		movs	r2, #70
 417 006a 0021     		movs	r1, #0
 418 006c 9954     		strb	r1, [r3, r2]
 427:..\FreeRTOS\Source/queue.c ****                 }
 428:..\FreeRTOS\Source/queue.c ****             #endif /* configSUPPORT_STATIC_ALLOCATION */
 429:..\FreeRTOS\Source/queue.c **** 
 430:..\FreeRTOS\Source/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 419              		.loc 1 430 0
 420 006e FB1D     		adds	r3, r7, #7
 421 0070 1C78     		ldrb	r4, [r3]
 422 0072 7A69     		ldr	r2, [r7, #20]
 423 0074 B968     		ldr	r1, [r7, #8]
 424 0076 F868     		ldr	r0, [r7, #12]
 425 0078 BB69     		ldr	r3, [r7, #24]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 16


 426 007a 0093     		str	r3, [sp]
 427 007c 2300     		movs	r3, r4
 428 007e FFF7FEFF 		bl	prvInitialiseNewQueue
 429              	.L40:
 431:..\FreeRTOS\Source/queue.c ****         }
 432:..\FreeRTOS\Source/queue.c ****         else
 433:..\FreeRTOS\Source/queue.c ****         {
 434:..\FreeRTOS\Source/queue.c ****             traceQUEUE_CREATE_FAILED( ucQueueType );
 435:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 436:..\FreeRTOS\Source/queue.c ****         }
 437:..\FreeRTOS\Source/queue.c **** 
 438:..\FreeRTOS\Source/queue.c ****         return pxNewQueue;
 430              		.loc 1 438 0
 431 0082 BB69     		ldr	r3, [r7, #24]
 439:..\FreeRTOS\Source/queue.c ****     }
 432              		.loc 1 439 0
 433 0084 1800     		movs	r0, r3
 434 0086 BD46     		mov	sp, r7
 435 0088 09B0     		add	sp, sp, #36
 436              		@ sp needed
 437 008a 90BD     		pop	{r4, r7, pc}
 438              	.L43:
 439              		.align	2
 440              	.L42:
 441 008c 00000000 		.word	x
 442              		.cfi_endproc
 443              	.LFE2:
 444              		.size	xQueueGenericCreate, .-xQueueGenericCreate
 445              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 446              		.align	2
 447              		.code	16
 448              		.thumb_func
 449              		.type	prvInitialiseNewQueue, %function
 450              	prvInitialiseNewQueue:
 451              	.LFB3:
 440:..\FreeRTOS\Source/queue.c **** 
 441:..\FreeRTOS\Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 442:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 443:..\FreeRTOS\Source/queue.c **** 
 444:..\FreeRTOS\Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 445:..\FreeRTOS\Source/queue.c ****                                    const UBaseType_t uxItemSize,
 446:..\FreeRTOS\Source/queue.c ****                                    uint8_t * pucQueueStorage,
 447:..\FreeRTOS\Source/queue.c ****                                    const uint8_t ucQueueType,
 448:..\FreeRTOS\Source/queue.c ****                                    Queue_t * pxNewQueue )
 449:..\FreeRTOS\Source/queue.c **** {
 452              		.loc 1 449 0
 453              		.cfi_startproc
 454              		@ args = 4, pretend = 0, frame = 16
 455              		@ frame_needed = 1, uses_anonymous_args = 0
 456 0000 80B5     		push	{r7, lr}
 457              		.cfi_def_cfa_offset 8
 458              		.cfi_offset 7, -8
 459              		.cfi_offset 14, -4
 460 0002 84B0     		sub	sp, sp, #16
 461              		.cfi_def_cfa_offset 24
 462 0004 00AF     		add	r7, sp, #0
 463              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 17


 464 0006 F860     		str	r0, [r7, #12]
 465 0008 B960     		str	r1, [r7, #8]
 466 000a 7A60     		str	r2, [r7, #4]
 467 000c 1A00     		movs	r2, r3
 468 000e FB1C     		adds	r3, r7, #3
 469 0010 1A70     		strb	r2, [r3]
 450:..\FreeRTOS\Source/queue.c ****     /* Remove compiler warnings about unused parameters should
 451:..\FreeRTOS\Source/queue.c ****      * configUSE_TRACE_FACILITY not be set to 1. */
 452:..\FreeRTOS\Source/queue.c ****     ( void ) ucQueueType;
 453:..\FreeRTOS\Source/queue.c **** 
 454:..\FreeRTOS\Source/queue.c ****     if( uxItemSize == ( UBaseType_t ) 0 )
 470              		.loc 1 454 0
 471 0012 BB68     		ldr	r3, [r7, #8]
 472 0014 002B     		cmp	r3, #0
 473 0016 03D1     		bne	.L45
 455:..\FreeRTOS\Source/queue.c ****     {
 456:..\FreeRTOS\Source/queue.c ****         /* No RAM was allocated for the queue storage area, but PC head cannot
 457:..\FreeRTOS\Source/queue.c ****          * be set to NULL because NULL is used as a key to say the queue is used as
 458:..\FreeRTOS\Source/queue.c ****          * a mutex.  Therefore just set pcHead to point to the queue as a benign
 459:..\FreeRTOS\Source/queue.c ****          * value that is known to be within the memory map. */
 460:..\FreeRTOS\Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 474              		.loc 1 460 0
 475 0018 BB69     		ldr	r3, [r7, #24]
 476 001a BA69     		ldr	r2, [r7, #24]
 477 001c 1A60     		str	r2, [r3]
 478 001e 02E0     		b	.L46
 479              	.L45:
 461:..\FreeRTOS\Source/queue.c ****     }
 462:..\FreeRTOS\Source/queue.c ****     else
 463:..\FreeRTOS\Source/queue.c ****     {
 464:..\FreeRTOS\Source/queue.c ****         /* Set the head to the start of the queue storage area. */
 465:..\FreeRTOS\Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 480              		.loc 1 465 0
 481 0020 BB69     		ldr	r3, [r7, #24]
 482 0022 7A68     		ldr	r2, [r7, #4]
 483 0024 1A60     		str	r2, [r3]
 484              	.L46:
 466:..\FreeRTOS\Source/queue.c ****     }
 467:..\FreeRTOS\Source/queue.c **** 
 468:..\FreeRTOS\Source/queue.c ****     /* Initialise the queue members as described where the queue type is
 469:..\FreeRTOS\Source/queue.c ****      * defined. */
 470:..\FreeRTOS\Source/queue.c ****     pxNewQueue->uxLength = uxQueueLength;
 485              		.loc 1 470 0
 486 0026 BB69     		ldr	r3, [r7, #24]
 487 0028 FA68     		ldr	r2, [r7, #12]
 488 002a DA63     		str	r2, [r3, #60]
 471:..\FreeRTOS\Source/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 489              		.loc 1 471 0
 490 002c BB69     		ldr	r3, [r7, #24]
 491 002e BA68     		ldr	r2, [r7, #8]
 492 0030 1A64     		str	r2, [r3, #64]
 472:..\FreeRTOS\Source/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 493              		.loc 1 472 0
 494 0032 BB69     		ldr	r3, [r7, #24]
 495 0034 0121     		movs	r1, #1
 496 0036 1800     		movs	r0, r3
 497 0038 FFF7FEFF 		bl	xQueueGenericReset
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 18


 473:..\FreeRTOS\Source/queue.c **** 
 474:..\FreeRTOS\Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 475:..\FreeRTOS\Source/queue.c ****         {
 476:..\FreeRTOS\Source/queue.c ****             pxNewQueue->ucQueueType = ucQueueType;
 477:..\FreeRTOS\Source/queue.c ****         }
 478:..\FreeRTOS\Source/queue.c ****     #endif /* configUSE_TRACE_FACILITY */
 479:..\FreeRTOS\Source/queue.c **** 
 480:..\FreeRTOS\Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 481:..\FreeRTOS\Source/queue.c ****         {
 482:..\FreeRTOS\Source/queue.c ****             pxNewQueue->pxQueueSetContainer = NULL;
 483:..\FreeRTOS\Source/queue.c ****         }
 484:..\FreeRTOS\Source/queue.c ****     #endif /* configUSE_QUEUE_SETS */
 485:..\FreeRTOS\Source/queue.c **** 
 486:..\FreeRTOS\Source/queue.c ****     traceQUEUE_CREATE( pxNewQueue );
 487:..\FreeRTOS\Source/queue.c **** }
 498              		.loc 1 487 0
 499 003c C046     		nop
 500 003e BD46     		mov	sp, r7
 501 0040 04B0     		add	sp, sp, #16
 502              		@ sp needed
 503 0042 80BD     		pop	{r7, pc}
 504              		.cfi_endproc
 505              	.LFE3:
 506              		.size	prvInitialiseNewQueue, .-prvInitialiseNewQueue
 507              		.section	.text.xQueueGenericSend,"ax",%progbits
 508              		.align	2
 509              		.global	xQueueGenericSend
 510              		.code	16
 511              		.thumb_func
 512              		.type	xQueueGenericSend, %function
 513              	xQueueGenericSend:
 514              	.LFB4:
 488:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 489:..\FreeRTOS\Source/queue.c **** 
 490:..\FreeRTOS\Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 491:..\FreeRTOS\Source/queue.c **** 
 492:..\FreeRTOS\Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue )
 493:..\FreeRTOS\Source/queue.c ****     {
 494:..\FreeRTOS\Source/queue.c ****         if( pxNewQueue != NULL )
 495:..\FreeRTOS\Source/queue.c ****         {
 496:..\FreeRTOS\Source/queue.c ****             /* The queue create function will set all the queue structure members
 497:..\FreeRTOS\Source/queue.c ****             * correctly for a generic queue, but this function is creating a
 498:..\FreeRTOS\Source/queue.c ****             * mutex.  Overwrite those members that need to be set differently -
 499:..\FreeRTOS\Source/queue.c ****             * in particular the information required for priority inheritance. */
 500:..\FreeRTOS\Source/queue.c ****             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 501:..\FreeRTOS\Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 502:..\FreeRTOS\Source/queue.c **** 
 503:..\FreeRTOS\Source/queue.c ****             /* In case this is a recursive mutex. */
 504:..\FreeRTOS\Source/queue.c ****             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 505:..\FreeRTOS\Source/queue.c **** 
 506:..\FreeRTOS\Source/queue.c ****             traceCREATE_MUTEX( pxNewQueue );
 507:..\FreeRTOS\Source/queue.c **** 
 508:..\FreeRTOS\Source/queue.c ****             /* Start with the semaphore in the expected state. */
 509:..\FreeRTOS\Source/queue.c ****             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 510:..\FreeRTOS\Source/queue.c ****         }
 511:..\FreeRTOS\Source/queue.c ****         else
 512:..\FreeRTOS\Source/queue.c ****         {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 19


 513:..\FreeRTOS\Source/queue.c ****             traceCREATE_MUTEX_FAILED();
 514:..\FreeRTOS\Source/queue.c ****         }
 515:..\FreeRTOS\Source/queue.c ****     }
 516:..\FreeRTOS\Source/queue.c **** 
 517:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_MUTEXES */
 518:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 519:..\FreeRTOS\Source/queue.c **** 
 520:..\FreeRTOS\Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 521:..\FreeRTOS\Source/queue.c **** 
 522:..\FreeRTOS\Source/queue.c ****     QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 523:..\FreeRTOS\Source/queue.c ****     {
 524:..\FreeRTOS\Source/queue.c ****         QueueHandle_t xNewQueue;
 525:..\FreeRTOS\Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 526:..\FreeRTOS\Source/queue.c **** 
 527:..\FreeRTOS\Source/queue.c ****         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 528:..\FreeRTOS\Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 529:..\FreeRTOS\Source/queue.c **** 
 530:..\FreeRTOS\Source/queue.c ****         return xNewQueue;
 531:..\FreeRTOS\Source/queue.c ****     }
 532:..\FreeRTOS\Source/queue.c **** 
 533:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_MUTEXES */
 534:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 535:..\FreeRTOS\Source/queue.c **** 
 536:..\FreeRTOS\Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 537:..\FreeRTOS\Source/queue.c **** 
 538:..\FreeRTOS\Source/queue.c ****     QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
 539:..\FreeRTOS\Source/queue.c ****                                            StaticQueue_t * pxStaticQueue )
 540:..\FreeRTOS\Source/queue.c ****     {
 541:..\FreeRTOS\Source/queue.c ****         QueueHandle_t xNewQueue;
 542:..\FreeRTOS\Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 543:..\FreeRTOS\Source/queue.c **** 
 544:..\FreeRTOS\Source/queue.c ****         /* Prevent compiler warnings about unused parameters if
 545:..\FreeRTOS\Source/queue.c ****          * configUSE_TRACE_FACILITY does not equal 1. */
 546:..\FreeRTOS\Source/queue.c ****         ( void ) ucQueueType;
 547:..\FreeRTOS\Source/queue.c **** 
 548:..\FreeRTOS\Source/queue.c ****         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQ
 549:..\FreeRTOS\Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 550:..\FreeRTOS\Source/queue.c **** 
 551:..\FreeRTOS\Source/queue.c ****         return xNewQueue;
 552:..\FreeRTOS\Source/queue.c ****     }
 553:..\FreeRTOS\Source/queue.c **** 
 554:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_MUTEXES */
 555:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 556:..\FreeRTOS\Source/queue.c **** 
 557:..\FreeRTOS\Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 558:..\FreeRTOS\Source/queue.c **** 
 559:..\FreeRTOS\Source/queue.c ****     TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 560:..\FreeRTOS\Source/queue.c ****     {
 561:..\FreeRTOS\Source/queue.c ****         TaskHandle_t pxReturn;
 562:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 563:..\FreeRTOS\Source/queue.c **** 
 564:..\FreeRTOS\Source/queue.c ****         /* This function is called by xSemaphoreGetMutexHolder(), and should not
 565:..\FreeRTOS\Source/queue.c ****          * be called directly.  Note:  This is a good way of determining if the
 566:..\FreeRTOS\Source/queue.c ****          * calling task is the mutex holder, but not a good way of determining the
 567:..\FreeRTOS\Source/queue.c ****          * identity of the mutex holder, as the holder may change between the
 568:..\FreeRTOS\Source/queue.c ****          * following critical section exiting and the function returning. */
 569:..\FreeRTOS\Source/queue.c ****         taskENTER_CRITICAL();
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 20


 570:..\FreeRTOS\Source/queue.c ****         {
 571:..\FreeRTOS\Source/queue.c ****             if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 572:..\FreeRTOS\Source/queue.c ****             {
 573:..\FreeRTOS\Source/queue.c ****                 pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 574:..\FreeRTOS\Source/queue.c ****             }
 575:..\FreeRTOS\Source/queue.c ****             else
 576:..\FreeRTOS\Source/queue.c ****             {
 577:..\FreeRTOS\Source/queue.c ****                 pxReturn = NULL;
 578:..\FreeRTOS\Source/queue.c ****             }
 579:..\FreeRTOS\Source/queue.c ****         }
 580:..\FreeRTOS\Source/queue.c ****         taskEXIT_CRITICAL();
 581:..\FreeRTOS\Source/queue.c **** 
 582:..\FreeRTOS\Source/queue.c ****         return pxReturn;
 583:..\FreeRTOS\Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 584:..\FreeRTOS\Source/queue.c **** 
 585:..\FreeRTOS\Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 586:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 587:..\FreeRTOS\Source/queue.c **** 
 588:..\FreeRTOS\Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 589:..\FreeRTOS\Source/queue.c **** 
 590:..\FreeRTOS\Source/queue.c ****     TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 591:..\FreeRTOS\Source/queue.c ****     {
 592:..\FreeRTOS\Source/queue.c ****         TaskHandle_t pxReturn;
 593:..\FreeRTOS\Source/queue.c **** 
 594:..\FreeRTOS\Source/queue.c ****         configASSERT( xSemaphore );
 595:..\FreeRTOS\Source/queue.c **** 
 596:..\FreeRTOS\Source/queue.c ****         /* Mutexes cannot be used in interrupt service routines, so the mutex
 597:..\FreeRTOS\Source/queue.c ****          * holder should not change in an ISR, and therefore a critical section is
 598:..\FreeRTOS\Source/queue.c ****          * not required here. */
 599:..\FreeRTOS\Source/queue.c ****         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 600:..\FreeRTOS\Source/queue.c ****         {
 601:..\FreeRTOS\Source/queue.c ****             pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 602:..\FreeRTOS\Source/queue.c ****         }
 603:..\FreeRTOS\Source/queue.c ****         else
 604:..\FreeRTOS\Source/queue.c ****         {
 605:..\FreeRTOS\Source/queue.c ****             pxReturn = NULL;
 606:..\FreeRTOS\Source/queue.c ****         }
 607:..\FreeRTOS\Source/queue.c **** 
 608:..\FreeRTOS\Source/queue.c ****         return pxReturn;
 609:..\FreeRTOS\Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 610:..\FreeRTOS\Source/queue.c **** 
 611:..\FreeRTOS\Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 612:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 613:..\FreeRTOS\Source/queue.c **** 
 614:..\FreeRTOS\Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 615:..\FreeRTOS\Source/queue.c **** 
 616:..\FreeRTOS\Source/queue.c ****     BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 617:..\FreeRTOS\Source/queue.c ****     {
 618:..\FreeRTOS\Source/queue.c ****         BaseType_t xReturn;
 619:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 620:..\FreeRTOS\Source/queue.c **** 
 621:..\FreeRTOS\Source/queue.c ****         configASSERT( pxMutex );
 622:..\FreeRTOS\Source/queue.c **** 
 623:..\FreeRTOS\Source/queue.c ****         /* If this is the task that holds the mutex then xMutexHolder will not
 624:..\FreeRTOS\Source/queue.c ****          * change outside of this task.  If this task does not hold the mutex then
 625:..\FreeRTOS\Source/queue.c ****          * pxMutexHolder can never coincidentally equal the tasks handle, and as
 626:..\FreeRTOS\Source/queue.c ****          * this is the only condition we are interested in it does not matter if
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 21


 627:..\FreeRTOS\Source/queue.c ****          * pxMutexHolder is accessed simultaneously by another task.  Therefore no
 628:..\FreeRTOS\Source/queue.c ****          * mutual exclusion is required to test the pxMutexHolder variable. */
 629:..\FreeRTOS\Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 630:..\FreeRTOS\Source/queue.c ****         {
 631:..\FreeRTOS\Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE( pxMutex );
 632:..\FreeRTOS\Source/queue.c **** 
 633:..\FreeRTOS\Source/queue.c ****             /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 634:..\FreeRTOS\Source/queue.c ****              * the task handle, therefore no underflow check is required.  Also,
 635:..\FreeRTOS\Source/queue.c ****              * uxRecursiveCallCount is only modified by the mutex holder, and as
 636:..\FreeRTOS\Source/queue.c ****              * there can only be one, no mutual exclusion is required to modify the
 637:..\FreeRTOS\Source/queue.c ****              * uxRecursiveCallCount member. */
 638:..\FreeRTOS\Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 639:..\FreeRTOS\Source/queue.c **** 
 640:..\FreeRTOS\Source/queue.c ****             /* Has the recursive call count unwound to 0? */
 641:..\FreeRTOS\Source/queue.c ****             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 642:..\FreeRTOS\Source/queue.c ****             {
 643:..\FreeRTOS\Source/queue.c ****                 /* Return the mutex.  This will automatically unblock any other
 644:..\FreeRTOS\Source/queue.c ****                  * task that might be waiting to access the mutex. */
 645:..\FreeRTOS\Source/queue.c ****                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO
 646:..\FreeRTOS\Source/queue.c ****             }
 647:..\FreeRTOS\Source/queue.c ****             else
 648:..\FreeRTOS\Source/queue.c ****             {
 649:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 650:..\FreeRTOS\Source/queue.c ****             }
 651:..\FreeRTOS\Source/queue.c **** 
 652:..\FreeRTOS\Source/queue.c ****             xReturn = pdPASS;
 653:..\FreeRTOS\Source/queue.c ****         }
 654:..\FreeRTOS\Source/queue.c ****         else
 655:..\FreeRTOS\Source/queue.c ****         {
 656:..\FreeRTOS\Source/queue.c ****             /* The mutex cannot be given because the calling task is not the
 657:..\FreeRTOS\Source/queue.c ****              * holder. */
 658:..\FreeRTOS\Source/queue.c ****             xReturn = pdFAIL;
 659:..\FreeRTOS\Source/queue.c **** 
 660:..\FreeRTOS\Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 661:..\FreeRTOS\Source/queue.c ****         }
 662:..\FreeRTOS\Source/queue.c **** 
 663:..\FreeRTOS\Source/queue.c ****         return xReturn;
 664:..\FreeRTOS\Source/queue.c ****     }
 665:..\FreeRTOS\Source/queue.c **** 
 666:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 667:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 668:..\FreeRTOS\Source/queue.c **** 
 669:..\FreeRTOS\Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 670:..\FreeRTOS\Source/queue.c **** 
 671:..\FreeRTOS\Source/queue.c ****     BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
 672:..\FreeRTOS\Source/queue.c ****                                          TickType_t xTicksToWait )
 673:..\FreeRTOS\Source/queue.c ****     {
 674:..\FreeRTOS\Source/queue.c ****         BaseType_t xReturn;
 675:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 676:..\FreeRTOS\Source/queue.c **** 
 677:..\FreeRTOS\Source/queue.c ****         configASSERT( pxMutex );
 678:..\FreeRTOS\Source/queue.c **** 
 679:..\FreeRTOS\Source/queue.c ****         /* Comments regarding mutual exclusion as per those within
 680:..\FreeRTOS\Source/queue.c ****          * xQueueGiveMutexRecursive(). */
 681:..\FreeRTOS\Source/queue.c **** 
 682:..\FreeRTOS\Source/queue.c ****         traceTAKE_MUTEX_RECURSIVE( pxMutex );
 683:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 22


 684:..\FreeRTOS\Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 685:..\FreeRTOS\Source/queue.c ****         {
 686:..\FreeRTOS\Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 687:..\FreeRTOS\Source/queue.c ****             xReturn = pdPASS;
 688:..\FreeRTOS\Source/queue.c ****         }
 689:..\FreeRTOS\Source/queue.c ****         else
 690:..\FreeRTOS\Source/queue.c ****         {
 691:..\FreeRTOS\Source/queue.c ****             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 692:..\FreeRTOS\Source/queue.c **** 
 693:..\FreeRTOS\Source/queue.c ****             /* pdPASS will only be returned if the mutex was successfully
 694:..\FreeRTOS\Source/queue.c ****              * obtained.  The calling task may have entered the Blocked state
 695:..\FreeRTOS\Source/queue.c ****              * before reaching here. */
 696:..\FreeRTOS\Source/queue.c ****             if( xReturn != pdFAIL )
 697:..\FreeRTOS\Source/queue.c ****             {
 698:..\FreeRTOS\Source/queue.c ****                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 699:..\FreeRTOS\Source/queue.c ****             }
 700:..\FreeRTOS\Source/queue.c ****             else
 701:..\FreeRTOS\Source/queue.c ****             {
 702:..\FreeRTOS\Source/queue.c ****                 traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 703:..\FreeRTOS\Source/queue.c ****             }
 704:..\FreeRTOS\Source/queue.c ****         }
 705:..\FreeRTOS\Source/queue.c **** 
 706:..\FreeRTOS\Source/queue.c ****         return xReturn;
 707:..\FreeRTOS\Source/queue.c ****     }
 708:..\FreeRTOS\Source/queue.c **** 
 709:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 710:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 711:..\FreeRTOS\Source/queue.c **** 
 712:..\FreeRTOS\Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 713:..\FreeRTOS\Source/queue.c **** 
 714:..\FreeRTOS\Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
 715:..\FreeRTOS\Source/queue.c ****                                                        const UBaseType_t uxInitialCount,
 716:..\FreeRTOS\Source/queue.c ****                                                        StaticQueue_t * pxStaticQueue )
 717:..\FreeRTOS\Source/queue.c ****     {
 718:..\FreeRTOS\Source/queue.c ****         QueueHandle_t xHandle;
 719:..\FreeRTOS\Source/queue.c **** 
 720:..\FreeRTOS\Source/queue.c ****         configASSERT( uxMaxCount != 0 );
 721:..\FreeRTOS\Source/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 722:..\FreeRTOS\Source/queue.c **** 
 723:..\FreeRTOS\Source/queue.c ****         xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, px
 724:..\FreeRTOS\Source/queue.c **** 
 725:..\FreeRTOS\Source/queue.c ****         if( xHandle != NULL )
 726:..\FreeRTOS\Source/queue.c ****         {
 727:..\FreeRTOS\Source/queue.c ****             ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 728:..\FreeRTOS\Source/queue.c **** 
 729:..\FreeRTOS\Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE();
 730:..\FreeRTOS\Source/queue.c ****         }
 731:..\FreeRTOS\Source/queue.c ****         else
 732:..\FreeRTOS\Source/queue.c ****         {
 733:..\FreeRTOS\Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE_FAILED();
 734:..\FreeRTOS\Source/queue.c ****         }
 735:..\FreeRTOS\Source/queue.c **** 
 736:..\FreeRTOS\Source/queue.c ****         return xHandle;
 737:..\FreeRTOS\Source/queue.c ****     }
 738:..\FreeRTOS\Source/queue.c **** 
 739:..\FreeRTOS\Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 740:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 23


 741:..\FreeRTOS\Source/queue.c **** 
 742:..\FreeRTOS\Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 743:..\FreeRTOS\Source/queue.c **** 
 744:..\FreeRTOS\Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
 745:..\FreeRTOS\Source/queue.c ****                                                  const UBaseType_t uxInitialCount )
 746:..\FreeRTOS\Source/queue.c ****     {
 747:..\FreeRTOS\Source/queue.c ****         QueueHandle_t xHandle;
 748:..\FreeRTOS\Source/queue.c **** 
 749:..\FreeRTOS\Source/queue.c ****         configASSERT( uxMaxCount != 0 );
 750:..\FreeRTOS\Source/queue.c ****         configASSERT( uxInitialCount <= uxMaxCount );
 751:..\FreeRTOS\Source/queue.c **** 
 752:..\FreeRTOS\Source/queue.c ****         xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYP
 753:..\FreeRTOS\Source/queue.c **** 
 754:..\FreeRTOS\Source/queue.c ****         if( xHandle != NULL )
 755:..\FreeRTOS\Source/queue.c ****         {
 756:..\FreeRTOS\Source/queue.c ****             ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 757:..\FreeRTOS\Source/queue.c **** 
 758:..\FreeRTOS\Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE();
 759:..\FreeRTOS\Source/queue.c ****         }
 760:..\FreeRTOS\Source/queue.c ****         else
 761:..\FreeRTOS\Source/queue.c ****         {
 762:..\FreeRTOS\Source/queue.c ****             traceCREATE_COUNTING_SEMAPHORE_FAILED();
 763:..\FreeRTOS\Source/queue.c ****         }
 764:..\FreeRTOS\Source/queue.c **** 
 765:..\FreeRTOS\Source/queue.c ****         return xHandle;
 766:..\FreeRTOS\Source/queue.c ****     }
 767:..\FreeRTOS\Source/queue.c **** 
 768:..\FreeRTOS\Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 769:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 770:..\FreeRTOS\Source/queue.c **** 
 771:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
 772:..\FreeRTOS\Source/queue.c ****                               const void * const pvItemToQueue,
 773:..\FreeRTOS\Source/queue.c ****                               TickType_t xTicksToWait,
 774:..\FreeRTOS\Source/queue.c ****                               const BaseType_t xCopyPosition )
 775:..\FreeRTOS\Source/queue.c **** {
 515              		.loc 1 775 0
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 40
 518              		@ frame_needed = 1, uses_anonymous_args = 0
 519 0000 80B5     		push	{r7, lr}
 520              		.cfi_def_cfa_offset 8
 521              		.cfi_offset 7, -8
 522              		.cfi_offset 14, -4
 523 0002 8AB0     		sub	sp, sp, #40
 524              		.cfi_def_cfa_offset 48
 525 0004 00AF     		add	r7, sp, #0
 526              		.cfi_def_cfa_register 7
 527 0006 F860     		str	r0, [r7, #12]
 528 0008 B960     		str	r1, [r7, #8]
 529 000a 7A60     		str	r2, [r7, #4]
 530 000c 3B60     		str	r3, [r7]
 776:..\FreeRTOS\Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 531              		.loc 1 776 0
 532 000e 0023     		movs	r3, #0
 533 0010 7B62     		str	r3, [r7, #36]
 777:..\FreeRTOS\Source/queue.c ****     TimeOut_t xTimeOut;
 778:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 24


 534              		.loc 1 778 0
 535 0012 FB68     		ldr	r3, [r7, #12]
 536 0014 3B62     		str	r3, [r7, #32]
 779:..\FreeRTOS\Source/queue.c **** 
 780:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 537              		.loc 1 780 0
 538 0016 554B     		ldr	r3, .L82
 539 0018 1B88     		ldrh	r3, [r3]
 540 001a 002B     		cmp	r3, #0
 541 001c 01D1     		bne	.L48
 542              		.loc 1 780 0 is_stmt 0 discriminator 1
 543              		.syntax divided
 544              	@ 780 "..\FreeRTOS\Source\queue.c" 1
 545 001e 72B6     		 cpsid i 
 546              	@ 0 "" 2
 547              		.thumb
 548              		.syntax unified
 549              	.L49:
 550 0020 FEE7     		b	.L49
 551              	.L48:
 781:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 552              		.loc 1 781 0 is_stmt 1
 553 0022 524B     		ldr	r3, .L82
 554 0024 1B88     		ldrh	r3, [r3]
 555 0026 002B     		cmp	r3, #0
 556 0028 01D1     		bne	.L50
 557              		.loc 1 781 0 is_stmt 0 discriminator 1
 558              		.syntax divided
 559              	@ 781 "..\FreeRTOS\Source\queue.c" 1
 560 002a 72B6     		 cpsid i 
 561              	@ 0 "" 2
 562              		.thumb
 563              		.syntax unified
 564              	.L51:
 565              		.loc 1 781 0 discriminator 2
 566 002c FEE7     		b	.L51
 567              	.L50:
 568 002e BB68     		ldr	r3, [r7, #8]
 569 0030 C046     		nop
 782:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 570              		.loc 1 782 0 is_stmt 1 discriminator 2
 571 0032 4E4B     		ldr	r3, .L82
 572 0034 1B88     		ldrh	r3, [r3]
 573 0036 002B     		cmp	r3, #0
 574 0038 01D1     		bne	.L55
 575              		.loc 1 782 0 is_stmt 0 discriminator 1
 576              		.syntax divided
 577              	@ 782 "..\FreeRTOS\Source\queue.c" 1
 578 003a 72B6     		 cpsid i 
 579              	@ 0 "" 2
 580              		.thumb
 581              		.syntax unified
 582              	.L56:
 583              		.loc 1 782 0 discriminator 3
 584 003c FEE7     		b	.L56
 585              	.L55:
 586              		.loc 1 782 0 discriminator 2
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 25


 587 003e 3B68     		ldr	r3, [r7]
 588 0040 C046     		nop
 783:..\FreeRTOS\Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 784:..\FreeRTOS\Source/queue.c ****         {
 785:..\FreeRTOS\Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
 589              		.loc 1 785 0 is_stmt 1 discriminator 2
 590 0042 4A4B     		ldr	r3, .L82
 591 0044 1B88     		ldrh	r3, [r3]
 592 0046 002B     		cmp	r3, #0
 593 0048 01D1     		bne	.L60
 594              		.loc 1 785 0 is_stmt 0 discriminator 1
 595              		.syntax divided
 596              	@ 785 "..\FreeRTOS\Source\queue.c" 1
 597 004a 72B6     		 cpsid i 
 598              	@ 0 "" 2
 599              		.thumb
 600              		.syntax unified
 601              	.L61:
 602              		.loc 1 785 0 discriminator 4
 603 004c FEE7     		b	.L61
 604              	.L60:
 605              		.loc 1 785 0 discriminator 2
 606 004e FFF7FEFF 		bl	xTaskGetSchedulerState
 607 0052 031E     		subs	r3, r0, #0
 608 0054 00D1     		bne	.L64
 609              		.loc 1 785 0 discriminator 4
 610 0056 7B68     		ldr	r3, [r7, #4]
 611              	.L64:
 786:..\FreeRTOS\Source/queue.c ****         }
 787:..\FreeRTOS\Source/queue.c ****     #endif
 788:..\FreeRTOS\Source/queue.c **** 
 789:..\FreeRTOS\Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to
 790:..\FreeRTOS\Source/queue.c ****      * allow return statements within the function itself.  This is done in the
 791:..\FreeRTOS\Source/queue.c ****      * interest of execution time efficiency. */
 792:..\FreeRTOS\Source/queue.c ****     for( ; ; )
 793:..\FreeRTOS\Source/queue.c ****     {
 794:..\FreeRTOS\Source/queue.c ****         taskENTER_CRITICAL();
 612              		.loc 1 794 0 is_stmt 1
 613 0058 FFF7FEFF 		bl	vPortEnterCritical
 795:..\FreeRTOS\Source/queue.c ****         {
 796:..\FreeRTOS\Source/queue.c ****             /* Is there room on the queue now?  The running task must be the
 797:..\FreeRTOS\Source/queue.c ****              * highest priority task wanting to access the queue.  If the head item
 798:..\FreeRTOS\Source/queue.c ****              * in the queue is to be overwritten then it does not matter if the
 799:..\FreeRTOS\Source/queue.c ****              * queue is full. */
 800:..\FreeRTOS\Source/queue.c ****             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERW
 614              		.loc 1 800 0
 615 005c 3B6A     		ldr	r3, [r7, #32]
 616 005e 9A6B     		ldr	r2, [r3, #56]
 617 0060 3B6A     		ldr	r3, [r7, #32]
 618 0062 DB6B     		ldr	r3, [r3, #60]
 619 0064 9A42     		cmp	r2, r3
 620 0066 02D3     		bcc	.L65
 621              		.loc 1 800 0 is_stmt 0 discriminator 1
 622 0068 3B68     		ldr	r3, [r7]
 623 006a 022B     		cmp	r3, #2
 624 006c 1ED1     		bne	.L66
 625              	.L65:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 26


 801:..\FreeRTOS\Source/queue.c ****             {
 802:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_SEND( pxQueue );
 803:..\FreeRTOS\Source/queue.c **** 
 804:..\FreeRTOS\Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
 805:..\FreeRTOS\Source/queue.c ****                     {
 806:..\FreeRTOS\Source/queue.c ****                         const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 807:..\FreeRTOS\Source/queue.c **** 
 808:..\FreeRTOS\Source/queue.c ****                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition 
 809:..\FreeRTOS\Source/queue.c **** 
 810:..\FreeRTOS\Source/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
 811:..\FreeRTOS\Source/queue.c ****                         {
 812:..\FreeRTOS\Source/queue.c ****                             if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting 
 813:..\FreeRTOS\Source/queue.c ****                             {
 814:..\FreeRTOS\Source/queue.c ****                                 /* Do not notify the queue set as an existing item
 815:..\FreeRTOS\Source/queue.c ****                                  * was overwritten in the queue so the number of items
 816:..\FreeRTOS\Source/queue.c ****                                  * in the queue has not changed. */
 817:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 818:..\FreeRTOS\Source/queue.c ****                             }
 819:..\FreeRTOS\Source/queue.c ****                             else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 820:..\FreeRTOS\Source/queue.c ****                             {
 821:..\FreeRTOS\Source/queue.c ****                                 /* The queue is a member of a queue set, and posting
 822:..\FreeRTOS\Source/queue.c ****                                  * to the queue set caused a higher priority task to
 823:..\FreeRTOS\Source/queue.c ****                                  * unblock. A context switch is required. */
 824:..\FreeRTOS\Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 825:..\FreeRTOS\Source/queue.c ****                             }
 826:..\FreeRTOS\Source/queue.c ****                             else
 827:..\FreeRTOS\Source/queue.c ****                             {
 828:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 829:..\FreeRTOS\Source/queue.c ****                             }
 830:..\FreeRTOS\Source/queue.c ****                         }
 831:..\FreeRTOS\Source/queue.c ****                         else
 832:..\FreeRTOS\Source/queue.c ****                         {
 833:..\FreeRTOS\Source/queue.c ****                             /* If there was a task waiting for data to arrive on the
 834:..\FreeRTOS\Source/queue.c ****                              * queue then unblock it now. */
 835:..\FreeRTOS\Source/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
 836:..\FreeRTOS\Source/queue.c ****                             {
 837:..\FreeRTOS\Source/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
 838:..\FreeRTOS\Source/queue.c ****                                 {
 839:..\FreeRTOS\Source/queue.c ****                                     /* The unblocked task has a priority higher than
 840:..\FreeRTOS\Source/queue.c ****                                      * our own so yield immediately.  Yes it is ok to
 841:..\FreeRTOS\Source/queue.c ****                                      * do this from within the critical section - the
 842:..\FreeRTOS\Source/queue.c ****                                      * kernel takes care of that. */
 843:..\FreeRTOS\Source/queue.c ****                                     queueYIELD_IF_USING_PREEMPTION();
 844:..\FreeRTOS\Source/queue.c ****                                 }
 845:..\FreeRTOS\Source/queue.c ****                                 else
 846:..\FreeRTOS\Source/queue.c ****                                 {
 847:..\FreeRTOS\Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
 848:..\FreeRTOS\Source/queue.c ****                                 }
 849:..\FreeRTOS\Source/queue.c ****                             }
 850:..\FreeRTOS\Source/queue.c ****                             else if( xYieldRequired != pdFALSE )
 851:..\FreeRTOS\Source/queue.c ****                             {
 852:..\FreeRTOS\Source/queue.c ****                                 /* This path is a special case that will only get
 853:..\FreeRTOS\Source/queue.c ****                                  * executed if the task was holding multiple mutexes
 854:..\FreeRTOS\Source/queue.c ****                                  * and the mutexes were given back in an order that is
 855:..\FreeRTOS\Source/queue.c ****                                  * different to that in which they were taken. */
 856:..\FreeRTOS\Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 857:..\FreeRTOS\Source/queue.c ****                             }
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 27


 858:..\FreeRTOS\Source/queue.c ****                             else
 859:..\FreeRTOS\Source/queue.c ****                             {
 860:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 861:..\FreeRTOS\Source/queue.c ****                             }
 862:..\FreeRTOS\Source/queue.c ****                         }
 863:..\FreeRTOS\Source/queue.c ****                     }
 864:..\FreeRTOS\Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
 865:..\FreeRTOS\Source/queue.c ****                     {
 866:..\FreeRTOS\Source/queue.c ****                         xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition 
 626              		.loc 1 866 0 is_stmt 1
 627 006e 3A68     		ldr	r2, [r7]
 628 0070 B968     		ldr	r1, [r7, #8]
 629 0072 3B6A     		ldr	r3, [r7, #32]
 630 0074 1800     		movs	r0, r3
 631 0076 FFF7FEFF 		bl	prvCopyDataToQueue
 632 007a 0300     		movs	r3, r0
 633 007c FB61     		str	r3, [r7, #28]
 867:..\FreeRTOS\Source/queue.c **** 
 868:..\FreeRTOS\Source/queue.c ****                         /* If there was a task waiting for data to arrive on the
 869:..\FreeRTOS\Source/queue.c ****                          * queue then unblock it now. */
 870:..\FreeRTOS\Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 634              		.loc 1 870 0
 635 007e 3B6A     		ldr	r3, [r7, #32]
 636 0080 5B6A     		ldr	r3, [r3, #36]
 637 0082 002B     		cmp	r3, #0
 638 0084 09D0     		beq	.L67
 871:..\FreeRTOS\Source/queue.c ****                         {
 872:..\FreeRTOS\Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 639              		.loc 1 872 0
 640 0086 3B6A     		ldr	r3, [r7, #32]
 641 0088 2433     		adds	r3, r3, #36
 642 008a 1800     		movs	r0, r3
 643 008c FFF7FEFF 		bl	xTaskRemoveFromEventList
 644 0090 031E     		subs	r3, r0, #0
 645 0092 07D0     		beq	.L68
 873:..\FreeRTOS\Source/queue.c ****                             {
 874:..\FreeRTOS\Source/queue.c ****                                 /* The unblocked task has a priority higher than
 875:..\FreeRTOS\Source/queue.c ****                                  * our own so yield immediately.  Yes it is ok to do
 876:..\FreeRTOS\Source/queue.c ****                                  * this from within the critical section - the kernel
 877:..\FreeRTOS\Source/queue.c ****                                  * takes care of that. */
 878:..\FreeRTOS\Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 646              		.loc 1 878 0
 647 0094 FFF7FEFF 		bl	vPortYield
 648 0098 04E0     		b	.L68
 649              	.L67:
 879:..\FreeRTOS\Source/queue.c ****                             }
 880:..\FreeRTOS\Source/queue.c ****                             else
 881:..\FreeRTOS\Source/queue.c ****                             {
 882:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 883:..\FreeRTOS\Source/queue.c ****                             }
 884:..\FreeRTOS\Source/queue.c ****                         }
 885:..\FreeRTOS\Source/queue.c ****                         else if( xYieldRequired != pdFALSE )
 650              		.loc 1 885 0
 651 009a FB69     		ldr	r3, [r7, #28]
 652 009c 002B     		cmp	r3, #0
 653 009e 01D0     		beq	.L68
 886:..\FreeRTOS\Source/queue.c ****                         {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 28


 887:..\FreeRTOS\Source/queue.c ****                             /* This path is a special case that will only get
 888:..\FreeRTOS\Source/queue.c ****                              * executed if the task was holding multiple mutexes and
 889:..\FreeRTOS\Source/queue.c ****                              * the mutexes were given back in an order that is
 890:..\FreeRTOS\Source/queue.c ****                              * different to that in which they were taken. */
 891:..\FreeRTOS\Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 654              		.loc 1 891 0
 655 00a0 FFF7FEFF 		bl	vPortYield
 656              	.L68:
 892:..\FreeRTOS\Source/queue.c ****                         }
 893:..\FreeRTOS\Source/queue.c ****                         else
 894:..\FreeRTOS\Source/queue.c ****                         {
 895:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 896:..\FreeRTOS\Source/queue.c ****                         }
 897:..\FreeRTOS\Source/queue.c ****                     }
 898:..\FreeRTOS\Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
 899:..\FreeRTOS\Source/queue.c **** 
 900:..\FreeRTOS\Source/queue.c ****                 taskEXIT_CRITICAL();
 657              		.loc 1 900 0
 658 00a4 FFF7FEFF 		bl	vPortExitCritical
 901:..\FreeRTOS\Source/queue.c ****                 return pdPASS;
 659              		.loc 1 901 0
 660 00a8 0123     		movs	r3, #1
 661 00aa 5BE0     		b	.L79
 662              	.L66:
 902:..\FreeRTOS\Source/queue.c ****             }
 903:..\FreeRTOS\Source/queue.c ****             else
 904:..\FreeRTOS\Source/queue.c ****             {
 905:..\FreeRTOS\Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 663              		.loc 1 905 0
 664 00ac 7B68     		ldr	r3, [r7, #4]
 665 00ae 002B     		cmp	r3, #0
 666 00b0 03D1     		bne	.L70
 906:..\FreeRTOS\Source/queue.c ****                 {
 907:..\FreeRTOS\Source/queue.c ****                     /* The queue was full and no block time is specified (or
 908:..\FreeRTOS\Source/queue.c ****                      * the block time has expired) so leave now. */
 909:..\FreeRTOS\Source/queue.c ****                     taskEXIT_CRITICAL();
 667              		.loc 1 909 0
 668 00b2 FFF7FEFF 		bl	vPortExitCritical
 910:..\FreeRTOS\Source/queue.c **** 
 911:..\FreeRTOS\Source/queue.c ****                     /* Return to the original privilege level before exiting
 912:..\FreeRTOS\Source/queue.c ****                      * the function. */
 913:..\FreeRTOS\Source/queue.c ****                     traceQUEUE_SEND_FAILED( pxQueue );
 914:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_FULL;
 669              		.loc 1 914 0
 670 00b6 0023     		movs	r3, #0
 671 00b8 54E0     		b	.L79
 672              	.L70:
 915:..\FreeRTOS\Source/queue.c ****                 }
 916:..\FreeRTOS\Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 673              		.loc 1 916 0
 674 00ba 7B6A     		ldr	r3, [r7, #36]
 675 00bc 002B     		cmp	r3, #0
 676 00be 06D1     		bne	.L71
 917:..\FreeRTOS\Source/queue.c ****                 {
 918:..\FreeRTOS\Source/queue.c ****                     /* The queue was full and a block time was specified so
 919:..\FreeRTOS\Source/queue.c ****                      * configure the timeout structure. */
 920:..\FreeRTOS\Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 29


 677              		.loc 1 920 0
 678 00c0 1423     		movs	r3, #20
 679 00c2 FB18     		adds	r3, r7, r3
 680 00c4 1800     		movs	r0, r3
 681 00c6 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 921:..\FreeRTOS\Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 682              		.loc 1 921 0
 683 00ca 0123     		movs	r3, #1
 684 00cc 7B62     		str	r3, [r7, #36]
 685              	.L71:
 922:..\FreeRTOS\Source/queue.c ****                 }
 923:..\FreeRTOS\Source/queue.c ****                 else
 924:..\FreeRTOS\Source/queue.c ****                 {
 925:..\FreeRTOS\Source/queue.c ****                     /* Entry time was already set. */
 926:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 927:..\FreeRTOS\Source/queue.c ****                 }
 928:..\FreeRTOS\Source/queue.c ****             }
 929:..\FreeRTOS\Source/queue.c ****         }
 930:..\FreeRTOS\Source/queue.c ****         taskEXIT_CRITICAL();
 686              		.loc 1 930 0
 687 00ce FFF7FEFF 		bl	vPortExitCritical
 931:..\FreeRTOS\Source/queue.c **** 
 932:..\FreeRTOS\Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
 933:..\FreeRTOS\Source/queue.c ****          * now the critical section has been exited. */
 934:..\FreeRTOS\Source/queue.c **** 
 935:..\FreeRTOS\Source/queue.c ****         vTaskSuspendAll();
 688              		.loc 1 935 0
 689 00d2 FFF7FEFF 		bl	vTaskSuspendAll
 936:..\FreeRTOS\Source/queue.c ****         prvLockQueue( pxQueue );
 690              		.loc 1 936 0
 691 00d6 FFF7FEFF 		bl	vPortEnterCritical
 692 00da 3B6A     		ldr	r3, [r7, #32]
 693 00dc 4422     		movs	r2, #68
 694 00de 9B5C     		ldrb	r3, [r3, r2]
 695 00e0 5BB2     		sxtb	r3, r3
 696 00e2 0133     		adds	r3, r3, #1
 697 00e4 03D1     		bne	.L72
 698              		.loc 1 936 0 is_stmt 0 discriminator 1
 699 00e6 3B6A     		ldr	r3, [r7, #32]
 700 00e8 4422     		movs	r2, #68
 701 00ea 0021     		movs	r1, #0
 702 00ec 9954     		strb	r1, [r3, r2]
 703              	.L72:
 704              		.loc 1 936 0 discriminator 3
 705 00ee 3B6A     		ldr	r3, [r7, #32]
 706 00f0 4522     		movs	r2, #69
 707 00f2 9B5C     		ldrb	r3, [r3, r2]
 708 00f4 5BB2     		sxtb	r3, r3
 709 00f6 0133     		adds	r3, r3, #1
 710 00f8 03D1     		bne	.L73
 711              		.loc 1 936 0 discriminator 4
 712 00fa 3B6A     		ldr	r3, [r7, #32]
 713 00fc 4522     		movs	r2, #69
 714 00fe 0021     		movs	r1, #0
 715 0100 9954     		strb	r1, [r3, r2]
 716              	.L73:
 717              		.loc 1 936 0 discriminator 6
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 30


 718 0102 FFF7FEFF 		bl	vPortExitCritical
 937:..\FreeRTOS\Source/queue.c **** 
 938:..\FreeRTOS\Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
 939:..\FreeRTOS\Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 719              		.loc 1 939 0 is_stmt 1 discriminator 6
 720 0106 3A1D     		adds	r2, r7, #4
 721 0108 1423     		movs	r3, #20
 722 010a FB18     		adds	r3, r7, r3
 723 010c 1100     		movs	r1, r2
 724 010e 1800     		movs	r0, r3
 725 0110 FFF7FEFF 		bl	xTaskCheckForTimeOut
 726 0114 031E     		subs	r3, r0, #0
 727 0116 1ED1     		bne	.L74
 940:..\FreeRTOS\Source/queue.c ****         {
 941:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
 728              		.loc 1 941 0
 729 0118 3B6A     		ldr	r3, [r7, #32]
 730 011a 1800     		movs	r0, r3
 731 011c FFF7FEFF 		bl	prvIsQueueFull
 732 0120 031E     		subs	r3, r0, #0
 733 0122 11D0     		beq	.L75
 942:..\FreeRTOS\Source/queue.c ****             {
 943:..\FreeRTOS\Source/queue.c ****                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 944:..\FreeRTOS\Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 734              		.loc 1 944 0
 735 0124 3B6A     		ldr	r3, [r7, #32]
 736 0126 1033     		adds	r3, r3, #16
 737 0128 7A68     		ldr	r2, [r7, #4]
 738 012a 1100     		movs	r1, r2
 739 012c 1800     		movs	r0, r3
 740 012e FFF7FEFF 		bl	vTaskPlaceOnEventList
 945:..\FreeRTOS\Source/queue.c **** 
 946:..\FreeRTOS\Source/queue.c ****                 /* Unlocking the queue means queue events can effect the
 947:..\FreeRTOS\Source/queue.c ****                  * event list.  It is possible that interrupts occurring now
 948:..\FreeRTOS\Source/queue.c ****                  * remove this task from the event list again - but as the
 949:..\FreeRTOS\Source/queue.c ****                  * scheduler is suspended the task will go onto the pending
 950:..\FreeRTOS\Source/queue.c ****                  * ready last instead of the actual ready list. */
 951:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
 741              		.loc 1 951 0
 742 0132 3B6A     		ldr	r3, [r7, #32]
 743 0134 1800     		movs	r0, r3
 744 0136 FFF7FEFF 		bl	prvUnlockQueue
 952:..\FreeRTOS\Source/queue.c **** 
 953:..\FreeRTOS\Source/queue.c ****                 /* Resuming the scheduler will move tasks from the pending
 954:..\FreeRTOS\Source/queue.c ****                  * ready list into the ready list - so it is feasible that this
 955:..\FreeRTOS\Source/queue.c ****                  * task is already in a ready list before it yields - in which
 956:..\FreeRTOS\Source/queue.c ****                  * case the yield will not cause a context switch unless there
 957:..\FreeRTOS\Source/queue.c ****                  * is also a higher priority task in the pending ready list. */
 958:..\FreeRTOS\Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 745              		.loc 1 958 0
 746 013a FFF7FEFF 		bl	xTaskResumeAll
 747 013e 031E     		subs	r3, r0, #0
 748 0140 8AD1     		bne	.L64
 959:..\FreeRTOS\Source/queue.c ****                 {
 960:..\FreeRTOS\Source/queue.c ****                     portYIELD_WITHIN_API();
 749              		.loc 1 960 0
 750 0142 FFF7FEFF 		bl	vPortYield
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 31


 751 0146 87E7     		b	.L64
 752              	.L75:
 961:..\FreeRTOS\Source/queue.c ****                 }
 962:..\FreeRTOS\Source/queue.c ****             }
 963:..\FreeRTOS\Source/queue.c ****             else
 964:..\FreeRTOS\Source/queue.c ****             {
 965:..\FreeRTOS\Source/queue.c ****                 /* Try again. */
 966:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
 753              		.loc 1 966 0
 754 0148 3B6A     		ldr	r3, [r7, #32]
 755 014a 1800     		movs	r0, r3
 756 014c FFF7FEFF 		bl	prvUnlockQueue
 967:..\FreeRTOS\Source/queue.c ****                 ( void ) xTaskResumeAll();
 757              		.loc 1 967 0
 758 0150 FFF7FEFF 		bl	xTaskResumeAll
 759 0154 80E7     		b	.L64
 760              	.L74:
 968:..\FreeRTOS\Source/queue.c ****             }
 969:..\FreeRTOS\Source/queue.c ****         }
 970:..\FreeRTOS\Source/queue.c ****         else
 971:..\FreeRTOS\Source/queue.c ****         {
 972:..\FreeRTOS\Source/queue.c ****             /* The timeout has expired. */
 973:..\FreeRTOS\Source/queue.c ****             prvUnlockQueue( pxQueue );
 761              		.loc 1 973 0
 762 0156 3B6A     		ldr	r3, [r7, #32]
 763 0158 1800     		movs	r0, r3
 764 015a FFF7FEFF 		bl	prvUnlockQueue
 974:..\FreeRTOS\Source/queue.c ****             ( void ) xTaskResumeAll();
 765              		.loc 1 974 0
 766 015e FFF7FEFF 		bl	xTaskResumeAll
 975:..\FreeRTOS\Source/queue.c **** 
 976:..\FreeRTOS\Source/queue.c ****             traceQUEUE_SEND_FAILED( pxQueue );
 977:..\FreeRTOS\Source/queue.c ****             return errQUEUE_FULL;
 767              		.loc 1 977 0
 768 0162 0023     		movs	r3, #0
 769              	.L79:
 978:..\FreeRTOS\Source/queue.c ****         }
 979:..\FreeRTOS\Source/queue.c ****     } /*lint -restore */
 980:..\FreeRTOS\Source/queue.c **** }
 770              		.loc 1 980 0 discriminator 7
 771 0164 1800     		movs	r0, r3
 772 0166 BD46     		mov	sp, r7
 773 0168 0AB0     		add	sp, sp, #40
 774              		@ sp needed
 775 016a 80BD     		pop	{r7, pc}
 776              	.L83:
 777              		.align	2
 778              	.L82:
 779 016c 00000000 		.word	x
 780              		.cfi_endproc
 781              	.LFE4:
 782              		.size	xQueueGenericSend, .-xQueueGenericSend
 783              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 784              		.align	2
 785              		.global	xQueueGenericSendFromISR
 786              		.code	16
 787              		.thumb_func
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 32


 788              		.type	xQueueGenericSendFromISR, %function
 789              	xQueueGenericSendFromISR:
 790              	.LFB5:
 981:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
 982:..\FreeRTOS\Source/queue.c **** 
 983:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
 984:..\FreeRTOS\Source/queue.c ****                                      const void * const pvItemToQueue,
 985:..\FreeRTOS\Source/queue.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
 986:..\FreeRTOS\Source/queue.c ****                                      const BaseType_t xCopyPosition )
 987:..\FreeRTOS\Source/queue.c **** {
 791              		.loc 1 987 0
 792              		.cfi_startproc
 793              		@ args = 0, pretend = 0, frame = 40
 794              		@ frame_needed = 1, uses_anonymous_args = 0
 795 0000 80B5     		push	{r7, lr}
 796              		.cfi_def_cfa_offset 8
 797              		.cfi_offset 7, -8
 798              		.cfi_offset 14, -4
 799 0002 8AB0     		sub	sp, sp, #40
 800              		.cfi_def_cfa_offset 48
 801 0004 00AF     		add	r7, sp, #0
 802              		.cfi_def_cfa_register 7
 803 0006 F860     		str	r0, [r7, #12]
 804 0008 B960     		str	r1, [r7, #8]
 805 000a 7A60     		str	r2, [r7, #4]
 806 000c 3B60     		str	r3, [r7]
 988:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
 989:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 990:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 807              		.loc 1 990 0
 808 000e FB68     		ldr	r3, [r7, #12]
 809 0010 3B62     		str	r3, [r7, #32]
 991:..\FreeRTOS\Source/queue.c **** 
 992:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 810              		.loc 1 992 0
 811 0012 334B     		ldr	r3, .L107
 812 0014 1B88     		ldrh	r3, [r3]
 813 0016 002B     		cmp	r3, #0
 814 0018 01D1     		bne	.L85
 815              		.loc 1 992 0 is_stmt 0 discriminator 1
 816              		.syntax divided
 817              	@ 992 "..\FreeRTOS\Source\queue.c" 1
 818 001a 72B6     		 cpsid i 
 819              	@ 0 "" 2
 820              		.thumb
 821              		.syntax unified
 822              	.L86:
 823 001c FEE7     		b	.L86
 824              	.L85:
 993:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 825              		.loc 1 993 0 is_stmt 1
 826 001e 304B     		ldr	r3, .L107
 827 0020 1B88     		ldrh	r3, [r3]
 828 0022 002B     		cmp	r3, #0
 829 0024 01D1     		bne	.L87
 830              		.loc 1 993 0 is_stmt 0 discriminator 1
 831              		.syntax divided
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 33


 832              	@ 993 "..\FreeRTOS\Source\queue.c" 1
 833 0026 72B6     		 cpsid i 
 834              	@ 0 "" 2
 835              		.thumb
 836              		.syntax unified
 837              	.L88:
 838              		.loc 1 993 0 discriminator 2
 839 0028 FEE7     		b	.L88
 840              	.L87:
 841 002a BB68     		ldr	r3, [r7, #8]
 842 002c C046     		nop
 994:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 843              		.loc 1 994 0 is_stmt 1 discriminator 2
 844 002e 2C4B     		ldr	r3, .L107
 845 0030 1B88     		ldrh	r3, [r3]
 846 0032 002B     		cmp	r3, #0
 847 0034 01D1     		bne	.L92
 848              		.loc 1 994 0 is_stmt 0 discriminator 1
 849              		.syntax divided
 850              	@ 994 "..\FreeRTOS\Source\queue.c" 1
 851 0036 72B6     		 cpsid i 
 852              	@ 0 "" 2
 853              		.thumb
 854              		.syntax unified
 855              	.L93:
 856              		.loc 1 994 0 discriminator 3
 857 0038 FEE7     		b	.L93
 858              	.L92:
 859              		.loc 1 994 0 discriminator 2
 860 003a 3B68     		ldr	r3, [r7]
 861 003c C046     		nop
 995:..\FreeRTOS\Source/queue.c **** 
 996:..\FreeRTOS\Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
 997:..\FreeRTOS\Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
 998:..\FreeRTOS\Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
 999:..\FreeRTOS\Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1000:..\FreeRTOS\Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1001:..\FreeRTOS\Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1002:..\FreeRTOS\Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1003:..\FreeRTOS\Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1004:..\FreeRTOS\Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1005:..\FreeRTOS\Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1006:..\FreeRTOS\Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1007:..\FreeRTOS\Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1008:..\FreeRTOS\Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1009:..\FreeRTOS\Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1010:..\FreeRTOS\Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1011:..\FreeRTOS\Source/queue.c **** 
1012:..\FreeRTOS\Source/queue.c ****     /* Similar to xQueueGenericSend, except without blocking if there is no room
1013:..\FreeRTOS\Source/queue.c ****      * in the queue.  Also don't directly wake a task that was blocked on a queue
1014:..\FreeRTOS\Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1015:..\FreeRTOS\Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1016:..\FreeRTOS\Source/queue.c ****      * post). */
1017:..\FreeRTOS\Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 862              		.loc 1 1017 0 is_stmt 1 discriminator 2
 863 003e FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 864 0042 0300     		movs	r3, r0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 34


 865 0044 FB61     		str	r3, [r7, #28]
1018:..\FreeRTOS\Source/queue.c ****     {
1019:..\FreeRTOS\Source/queue.c ****         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE
 866              		.loc 1 1019 0 discriminator 2
 867 0046 3B6A     		ldr	r3, [r7, #32]
 868 0048 9A6B     		ldr	r2, [r3, #56]
 869 004a 3B6A     		ldr	r3, [r7, #32]
 870 004c DB6B     		ldr	r3, [r3, #60]
 871 004e 9A42     		cmp	r2, r3
 872 0050 02D3     		bcc	.L97
 873              		.loc 1 1019 0 is_stmt 0 discriminator 1
 874 0052 3B68     		ldr	r3, [r7]
 875 0054 022B     		cmp	r3, #2
 876 0056 38D1     		bne	.L98
 877              	.L97:
 878              	.LBB3:
1020:..\FreeRTOS\Source/queue.c ****         {
1021:..\FreeRTOS\Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
 879              		.loc 1 1021 0 is_stmt 1
 880 0058 1B23     		movs	r3, #27
 881 005a FB18     		adds	r3, r7, r3
 882 005c 3A6A     		ldr	r2, [r7, #32]
 883 005e 4521     		movs	r1, #69
 884 0060 525C     		ldrb	r2, [r2, r1]
 885 0062 1A70     		strb	r2, [r3]
1022:..\FreeRTOS\Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 886              		.loc 1 1022 0
 887 0064 3B6A     		ldr	r3, [r7, #32]
 888 0066 9B6B     		ldr	r3, [r3, #56]
 889 0068 7B61     		str	r3, [r7, #20]
1023:..\FreeRTOS\Source/queue.c **** 
1024:..\FreeRTOS\Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1025:..\FreeRTOS\Source/queue.c **** 
1026:..\FreeRTOS\Source/queue.c ****             /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1027:..\FreeRTOS\Source/queue.c ****              *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1028:..\FreeRTOS\Source/queue.c ****              *  in a task disinheriting a priority and prvCopyDataToQueue() can be
1029:..\FreeRTOS\Source/queue.c ****              *  called here even though the disinherit function does not check if
1030:..\FreeRTOS\Source/queue.c ****              *  the scheduler is suspended before accessing the ready lists. */
1031:..\FreeRTOS\Source/queue.c ****             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 890              		.loc 1 1031 0
 891 006a 3A68     		ldr	r2, [r7]
 892 006c B968     		ldr	r1, [r7, #8]
 893 006e 3B6A     		ldr	r3, [r7, #32]
 894 0070 1800     		movs	r0, r3
 895 0072 FFF7FEFF 		bl	prvCopyDataToQueue
1032:..\FreeRTOS\Source/queue.c **** 
1033:..\FreeRTOS\Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1034:..\FreeRTOS\Source/queue.c ****              * be done when the queue is unlocked later. */
1035:..\FreeRTOS\Source/queue.c ****             if( cTxLock == queueUNLOCKED )
 896              		.loc 1 1035 0
 897 0076 1B23     		movs	r3, #27
 898 0078 FB18     		adds	r3, r7, r3
 899 007a 1B78     		ldrb	r3, [r3]
 900 007c 5BB2     		sxtb	r3, r3
 901 007e 0133     		adds	r3, r3, #1
 902 0080 11D1     		bne	.L99
1036:..\FreeRTOS\Source/queue.c ****             {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 35


1037:..\FreeRTOS\Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1038:..\FreeRTOS\Source/queue.c ****                     {
1039:..\FreeRTOS\Source/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
1040:..\FreeRTOS\Source/queue.c ****                         {
1041:..\FreeRTOS\Source/queue.c ****                             if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting 
1042:..\FreeRTOS\Source/queue.c ****                             {
1043:..\FreeRTOS\Source/queue.c ****                                 /* Do not notify the queue set as an existing item
1044:..\FreeRTOS\Source/queue.c ****                                  * was overwritten in the queue so the number of items
1045:..\FreeRTOS\Source/queue.c ****                                  * in the queue has not changed. */
1046:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1047:..\FreeRTOS\Source/queue.c ****                             }
1048:..\FreeRTOS\Source/queue.c ****                             else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1049:..\FreeRTOS\Source/queue.c ****                             {
1050:..\FreeRTOS\Source/queue.c ****                                 /* The queue is a member of a queue set, and posting
1051:..\FreeRTOS\Source/queue.c ****                                  * to the queue set caused a higher priority task to
1052:..\FreeRTOS\Source/queue.c ****                                  * unblock.  A context switch is required. */
1053:..\FreeRTOS\Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1054:..\FreeRTOS\Source/queue.c ****                                 {
1055:..\FreeRTOS\Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1056:..\FreeRTOS\Source/queue.c ****                                 }
1057:..\FreeRTOS\Source/queue.c ****                                 else
1058:..\FreeRTOS\Source/queue.c ****                                 {
1059:..\FreeRTOS\Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1060:..\FreeRTOS\Source/queue.c ****                                 }
1061:..\FreeRTOS\Source/queue.c ****                             }
1062:..\FreeRTOS\Source/queue.c ****                             else
1063:..\FreeRTOS\Source/queue.c ****                             {
1064:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1065:..\FreeRTOS\Source/queue.c ****                             }
1066:..\FreeRTOS\Source/queue.c ****                         }
1067:..\FreeRTOS\Source/queue.c ****                         else
1068:..\FreeRTOS\Source/queue.c ****                         {
1069:..\FreeRTOS\Source/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
1070:..\FreeRTOS\Source/queue.c ****                             {
1071:..\FreeRTOS\Source/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
1072:..\FreeRTOS\Source/queue.c ****                                 {
1073:..\FreeRTOS\Source/queue.c ****                                     /* The task waiting has a higher priority so
1074:..\FreeRTOS\Source/queue.c ****                                      *  record that a context switch is required. */
1075:..\FreeRTOS\Source/queue.c ****                                     if( pxHigherPriorityTaskWoken != NULL )
1076:..\FreeRTOS\Source/queue.c ****                                     {
1077:..\FreeRTOS\Source/queue.c ****                                         *pxHigherPriorityTaskWoken = pdTRUE;
1078:..\FreeRTOS\Source/queue.c ****                                     }
1079:..\FreeRTOS\Source/queue.c ****                                     else
1080:..\FreeRTOS\Source/queue.c ****                                     {
1081:..\FreeRTOS\Source/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1082:..\FreeRTOS\Source/queue.c ****                                     }
1083:..\FreeRTOS\Source/queue.c ****                                 }
1084:..\FreeRTOS\Source/queue.c ****                                 else
1085:..\FreeRTOS\Source/queue.c ****                                 {
1086:..\FreeRTOS\Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1087:..\FreeRTOS\Source/queue.c ****                                 }
1088:..\FreeRTOS\Source/queue.c ****                             }
1089:..\FreeRTOS\Source/queue.c ****                             else
1090:..\FreeRTOS\Source/queue.c ****                             {
1091:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1092:..\FreeRTOS\Source/queue.c ****                             }
1093:..\FreeRTOS\Source/queue.c ****                         }
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 36


1094:..\FreeRTOS\Source/queue.c ****                     }
1095:..\FreeRTOS\Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1096:..\FreeRTOS\Source/queue.c ****                     {
1097:..\FreeRTOS\Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 903              		.loc 1 1097 0
 904 0082 3B6A     		ldr	r3, [r7, #32]
 905 0084 5B6A     		ldr	r3, [r3, #36]
 906 0086 002B     		cmp	r3, #0
 907 0088 1CD0     		beq	.L100
1098:..\FreeRTOS\Source/queue.c ****                         {
1099:..\FreeRTOS\Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 908              		.loc 1 1099 0
 909 008a 3B6A     		ldr	r3, [r7, #32]
 910 008c 2433     		adds	r3, r3, #36
 911 008e 1800     		movs	r0, r3
 912 0090 FFF7FEFF 		bl	xTaskRemoveFromEventList
 913 0094 031E     		subs	r3, r0, #0
 914 0096 15D0     		beq	.L100
1100:..\FreeRTOS\Source/queue.c ****                             {
1101:..\FreeRTOS\Source/queue.c ****                                 /* The task waiting has a higher priority so record that a
1102:..\FreeRTOS\Source/queue.c ****                                  * context switch is required. */
1103:..\FreeRTOS\Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
 915              		.loc 1 1103 0
 916 0098 7B68     		ldr	r3, [r7, #4]
 917 009a 002B     		cmp	r3, #0
 918 009c 12D0     		beq	.L100
1104:..\FreeRTOS\Source/queue.c ****                                 {
1105:..\FreeRTOS\Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
 919              		.loc 1 1105 0
 920 009e 7B68     		ldr	r3, [r7, #4]
 921 00a0 0122     		movs	r2, #1
 922 00a2 1A60     		str	r2, [r3]
 923 00a4 0EE0     		b	.L100
 924              	.L99:
1106:..\FreeRTOS\Source/queue.c ****                                 }
1107:..\FreeRTOS\Source/queue.c ****                                 else
1108:..\FreeRTOS\Source/queue.c ****                                 {
1109:..\FreeRTOS\Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1110:..\FreeRTOS\Source/queue.c ****                                 }
1111:..\FreeRTOS\Source/queue.c ****                             }
1112:..\FreeRTOS\Source/queue.c ****                             else
1113:..\FreeRTOS\Source/queue.c ****                             {
1114:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1115:..\FreeRTOS\Source/queue.c ****                             }
1116:..\FreeRTOS\Source/queue.c ****                         }
1117:..\FreeRTOS\Source/queue.c ****                         else
1118:..\FreeRTOS\Source/queue.c ****                         {
1119:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1120:..\FreeRTOS\Source/queue.c ****                         }
1121:..\FreeRTOS\Source/queue.c **** 
1122:..\FreeRTOS\Source/queue.c ****                         /* Not used in this path. */
1123:..\FreeRTOS\Source/queue.c ****                         ( void ) uxPreviousMessagesWaiting;
1124:..\FreeRTOS\Source/queue.c ****                     }
1125:..\FreeRTOS\Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1126:..\FreeRTOS\Source/queue.c ****             }
1127:..\FreeRTOS\Source/queue.c ****             else
1128:..\FreeRTOS\Source/queue.c ****             {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 37


1129:..\FreeRTOS\Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1130:..\FreeRTOS\Source/queue.c ****                  * knows that data was posted while it was locked. */
1131:..\FreeRTOS\Source/queue.c ****                 configASSERT( cTxLock != queueINT8_MAX );
 925              		.loc 1 1131 0
 926 00a6 0E4B     		ldr	r3, .L107
 927 00a8 1B88     		ldrh	r3, [r3]
 928 00aa 002B     		cmp	r3, #0
 929 00ac 01D1     		bne	.L101
 930              		.loc 1 1131 0 is_stmt 0 discriminator 1
 931              		.syntax divided
 932              	@ 1131 "..\FreeRTOS\Source\queue.c" 1
 933 00ae 72B6     		 cpsid i 
 934              	@ 0 "" 2
 935              		.thumb
 936              		.syntax unified
 937              	.L102:
 938              		.loc 1 1131 0 discriminator 6
 939 00b0 FEE7     		b	.L102
 940              	.L101:
1132:..\FreeRTOS\Source/queue.c **** 
1133:..\FreeRTOS\Source/queue.c ****                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 941              		.loc 1 1133 0 is_stmt 1
 942 00b2 1B23     		movs	r3, #27
 943 00b4 FB18     		adds	r3, r7, r3
 944 00b6 1B78     		ldrb	r3, [r3]
 945 00b8 0133     		adds	r3, r3, #1
 946 00ba DBB2     		uxtb	r3, r3
 947 00bc 59B2     		sxtb	r1, r3
 948 00be 3B6A     		ldr	r3, [r7, #32]
 949 00c0 4522     		movs	r2, #69
 950 00c2 9954     		strb	r1, [r3, r2]
 951              	.L100:
1134:..\FreeRTOS\Source/queue.c ****             }
1135:..\FreeRTOS\Source/queue.c **** 
1136:..\FreeRTOS\Source/queue.c ****             xReturn = pdPASS;
 952              		.loc 1 1136 0
 953 00c4 0123     		movs	r3, #1
 954 00c6 7B62     		str	r3, [r7, #36]
 955              	.LBE3:
1020:..\FreeRTOS\Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
 956              		.loc 1 1020 0
 957 00c8 01E0     		b	.L103
 958              	.L98:
1137:..\FreeRTOS\Source/queue.c ****         }
1138:..\FreeRTOS\Source/queue.c ****         else
1139:..\FreeRTOS\Source/queue.c ****         {
1140:..\FreeRTOS\Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1141:..\FreeRTOS\Source/queue.c ****             xReturn = errQUEUE_FULL;
 959              		.loc 1 1141 0
 960 00ca 0023     		movs	r3, #0
 961 00cc 7B62     		str	r3, [r7, #36]
 962              	.L103:
1142:..\FreeRTOS\Source/queue.c ****         }
1143:..\FreeRTOS\Source/queue.c ****     }
1144:..\FreeRTOS\Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 963              		.loc 1 1144 0
 964 00ce FB69     		ldr	r3, [r7, #28]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 38


 965 00d0 1800     		movs	r0, r3
 966 00d2 FFF7FEFF 		bl	vClearInterruptMaskFromISR
1145:..\FreeRTOS\Source/queue.c **** 
1146:..\FreeRTOS\Source/queue.c ****     return xReturn;
 967              		.loc 1 1146 0
 968 00d6 7B6A     		ldr	r3, [r7, #36]
1147:..\FreeRTOS\Source/queue.c **** }
 969              		.loc 1 1147 0
 970 00d8 1800     		movs	r0, r3
 971 00da BD46     		mov	sp, r7
 972 00dc 0AB0     		add	sp, sp, #40
 973              		@ sp needed
 974 00de 80BD     		pop	{r7, pc}
 975              	.L108:
 976              		.align	2
 977              	.L107:
 978 00e0 00000000 		.word	x
 979              		.cfi_endproc
 980              	.LFE5:
 981              		.size	xQueueGenericSendFromISR, .-xQueueGenericSendFromISR
 982              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 983              		.align	2
 984              		.global	xQueueGiveFromISR
 985              		.code	16
 986              		.thumb_func
 987              		.type	xQueueGiveFromISR, %function
 988              	xQueueGiveFromISR:
 989              	.LFB6:
1148:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
1149:..\FreeRTOS\Source/queue.c **** 
1150:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
1151:..\FreeRTOS\Source/queue.c ****                               BaseType_t * const pxHigherPriorityTaskWoken )
1152:..\FreeRTOS\Source/queue.c **** {
 990              		.loc 1 1152 0
 991              		.cfi_startproc
 992              		@ args = 0, pretend = 0, frame = 32
 993              		@ frame_needed = 1, uses_anonymous_args = 0
 994 0000 80B5     		push	{r7, lr}
 995              		.cfi_def_cfa_offset 8
 996              		.cfi_offset 7, -8
 997              		.cfi_offset 14, -4
 998 0002 88B0     		sub	sp, sp, #32
 999              		.cfi_def_cfa_offset 40
 1000 0004 00AF     		add	r7, sp, #0
 1001              		.cfi_def_cfa_register 7
 1002 0006 7860     		str	r0, [r7, #4]
 1003 0008 3960     		str	r1, [r7]
1153:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
1154:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1155:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1004              		.loc 1 1155 0
 1005 000a 7B68     		ldr	r3, [r7, #4]
 1006 000c BB61     		str	r3, [r7, #24]
1156:..\FreeRTOS\Source/queue.c **** 
1157:..\FreeRTOS\Source/queue.c ****     /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1158:..\FreeRTOS\Source/queue.c ****      * item size is 0.  Don't directly wake a task that was blocked on a queue
1159:..\FreeRTOS\Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 39


1160:..\FreeRTOS\Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1161:..\FreeRTOS\Source/queue.c ****      * post). */
1162:..\FreeRTOS\Source/queue.c **** 
1163:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 1007              		.loc 1 1163 0
 1008 000e 304B     		ldr	r3, .L127
 1009 0010 1B88     		ldrh	r3, [r3]
 1010 0012 002B     		cmp	r3, #0
 1011 0014 01D1     		bne	.L110
 1012              		.loc 1 1163 0 is_stmt 0 discriminator 1
 1013              		.syntax divided
 1014              	@ 1163 "..\FreeRTOS\Source\queue.c" 1
 1015 0016 72B6     		 cpsid i 
 1016              	@ 0 "" 2
 1017              		.thumb
 1018              		.syntax unified
 1019              	.L111:
 1020 0018 FEE7     		b	.L111
 1021              	.L110:
1164:..\FreeRTOS\Source/queue.c **** 
1165:..\FreeRTOS\Source/queue.c ****     /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1166:..\FreeRTOS\Source/queue.c ****      * if the item size is not 0. */
1167:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
 1022              		.loc 1 1167 0 is_stmt 1
 1023 001a 2D4B     		ldr	r3, .L127
 1024 001c 1B88     		ldrh	r3, [r3]
 1025 001e 002B     		cmp	r3, #0
 1026 0020 01D1     		bne	.L112
 1027              		.loc 1 1167 0 is_stmt 0 discriminator 1
 1028              		.syntax divided
 1029              	@ 1167 "..\FreeRTOS\Source\queue.c" 1
 1030 0022 72B6     		 cpsid i 
 1031              	@ 0 "" 2
 1032              		.thumb
 1033              		.syntax unified
 1034              	.L113:
 1035              		.loc 1 1167 0 discriminator 2
 1036 0024 FEE7     		b	.L113
 1037              	.L112:
1168:..\FreeRTOS\Source/queue.c **** 
1169:..\FreeRTOS\Source/queue.c ****     /* Normally a mutex would not be given from an interrupt, especially if
1170:..\FreeRTOS\Source/queue.c ****      * there is a mutex holder, as priority inheritance makes no sense for an
1171:..\FreeRTOS\Source/queue.c ****      * interrupts, only tasks. */
1172:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMu
 1038              		.loc 1 1172 0 is_stmt 1 discriminator 2
 1039 0026 2A4B     		ldr	r3, .L127
 1040 0028 1B88     		ldrh	r3, [r3]
 1041 002a 002B     		cmp	r3, #0
 1042 002c 01D1     		bne	.L114
 1043              		.loc 1 1172 0 is_stmt 0 discriminator 1
 1044              		.syntax divided
 1045              	@ 1172 "..\FreeRTOS\Source\queue.c" 1
 1046 002e 72B6     		 cpsid i 
 1047              	@ 0 "" 2
 1048              		.thumb
 1049              		.syntax unified
 1050              	.L115:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 40


 1051              		.loc 1 1172 0 discriminator 3
 1052 0030 FEE7     		b	.L115
 1053              	.L114:
 1054              		.loc 1 1172 0 discriminator 2
 1055 0032 BB69     		ldr	r3, [r7, #24]
 1056 0034 1B68     		ldr	r3, [r3]
 1057 0036 C046     		nop
1173:..\FreeRTOS\Source/queue.c **** 
1174:..\FreeRTOS\Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1175:..\FreeRTOS\Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1176:..\FreeRTOS\Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1177:..\FreeRTOS\Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1178:..\FreeRTOS\Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1179:..\FreeRTOS\Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1180:..\FreeRTOS\Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1181:..\FreeRTOS\Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1182:..\FreeRTOS\Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1183:..\FreeRTOS\Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1184:..\FreeRTOS\Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1185:..\FreeRTOS\Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1186:..\FreeRTOS\Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1187:..\FreeRTOS\Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1188:..\FreeRTOS\Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1189:..\FreeRTOS\Source/queue.c **** 
1190:..\FreeRTOS\Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1058              		.loc 1 1190 0 is_stmt 1 discriminator 2
 1059 0038 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1060 003c 0300     		movs	r3, r0
 1061 003e 7B61     		str	r3, [r7, #20]
 1062              	.LBB4:
1191:..\FreeRTOS\Source/queue.c ****     {
1192:..\FreeRTOS\Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1063              		.loc 1 1192 0 discriminator 2
 1064 0040 BB69     		ldr	r3, [r7, #24]
 1065 0042 9B6B     		ldr	r3, [r3, #56]
 1066 0044 3B61     		str	r3, [r7, #16]
1193:..\FreeRTOS\Source/queue.c **** 
1194:..\FreeRTOS\Source/queue.c ****         /* When the queue is used to implement a semaphore no data is ever
1195:..\FreeRTOS\Source/queue.c ****          * moved through the queue but it is still valid to see if the queue 'has
1196:..\FreeRTOS\Source/queue.c ****          * space'. */
1197:..\FreeRTOS\Source/queue.c ****         if( uxMessagesWaiting < pxQueue->uxLength )
 1067              		.loc 1 1197 0 discriminator 2
 1068 0046 BB69     		ldr	r3, [r7, #24]
 1069 0048 DA6B     		ldr	r2, [r3, #60]
 1070 004a 3B69     		ldr	r3, [r7, #16]
 1071 004c 9A42     		cmp	r2, r3
 1072 004e 33D9     		bls	.L119
 1073              	.LBB5:
1198:..\FreeRTOS\Source/queue.c ****         {
1199:..\FreeRTOS\Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
 1074              		.loc 1 1199 0
 1075 0050 0F23     		movs	r3, #15
 1076 0052 FB18     		adds	r3, r7, r3
 1077 0054 BA69     		ldr	r2, [r7, #24]
 1078 0056 4521     		movs	r1, #69
 1079 0058 525C     		ldrb	r2, [r2, r1]
 1080 005a 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 41


1200:..\FreeRTOS\Source/queue.c **** 
1201:..\FreeRTOS\Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1202:..\FreeRTOS\Source/queue.c **** 
1203:..\FreeRTOS\Source/queue.c ****             /* A task can only have an inherited priority if it is a mutex
1204:..\FreeRTOS\Source/queue.c ****              * holder - and if there is a mutex holder then the mutex cannot be
1205:..\FreeRTOS\Source/queue.c ****              * given from an ISR.  As this is the ISR version of the function it
1206:..\FreeRTOS\Source/queue.c ****              * can be assumed there is no mutex holder and no need to determine if
1207:..\FreeRTOS\Source/queue.c ****              * priority disinheritance is needed.  Simply increase the count of
1208:..\FreeRTOS\Source/queue.c ****              * messages (semaphores) available. */
1209:..\FreeRTOS\Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1081              		.loc 1 1209 0
 1082 005c 3B69     		ldr	r3, [r7, #16]
 1083 005e 5A1C     		adds	r2, r3, #1
 1084 0060 BB69     		ldr	r3, [r7, #24]
 1085 0062 9A63     		str	r2, [r3, #56]
1210:..\FreeRTOS\Source/queue.c **** 
1211:..\FreeRTOS\Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1212:..\FreeRTOS\Source/queue.c ****              * be done when the queue is unlocked later. */
1213:..\FreeRTOS\Source/queue.c ****             if( cTxLock == queueUNLOCKED )
 1086              		.loc 1 1213 0
 1087 0064 0F23     		movs	r3, #15
 1088 0066 FB18     		adds	r3, r7, r3
 1089 0068 1B78     		ldrb	r3, [r3]
 1090 006a 5BB2     		sxtb	r3, r3
 1091 006c 0133     		adds	r3, r3, #1
 1092 006e 11D1     		bne	.L120
1214:..\FreeRTOS\Source/queue.c ****             {
1215:..\FreeRTOS\Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1216:..\FreeRTOS\Source/queue.c ****                     {
1217:..\FreeRTOS\Source/queue.c ****                         if( pxQueue->pxQueueSetContainer != NULL )
1218:..\FreeRTOS\Source/queue.c ****                         {
1219:..\FreeRTOS\Source/queue.c ****                             if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1220:..\FreeRTOS\Source/queue.c ****                             {
1221:..\FreeRTOS\Source/queue.c ****                                 /* The semaphore is a member of a queue set, and
1222:..\FreeRTOS\Source/queue.c ****                                  * posting to the queue set caused a higher priority
1223:..\FreeRTOS\Source/queue.c ****                                  * task to unblock.  A context switch is required. */
1224:..\FreeRTOS\Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1225:..\FreeRTOS\Source/queue.c ****                                 {
1226:..\FreeRTOS\Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1227:..\FreeRTOS\Source/queue.c ****                                 }
1228:..\FreeRTOS\Source/queue.c ****                                 else
1229:..\FreeRTOS\Source/queue.c ****                                 {
1230:..\FreeRTOS\Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1231:..\FreeRTOS\Source/queue.c ****                                 }
1232:..\FreeRTOS\Source/queue.c ****                             }
1233:..\FreeRTOS\Source/queue.c ****                             else
1234:..\FreeRTOS\Source/queue.c ****                             {
1235:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1236:..\FreeRTOS\Source/queue.c ****                             }
1237:..\FreeRTOS\Source/queue.c ****                         }
1238:..\FreeRTOS\Source/queue.c ****                         else
1239:..\FreeRTOS\Source/queue.c ****                         {
1240:..\FreeRTOS\Source/queue.c ****                             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALS
1241:..\FreeRTOS\Source/queue.c ****                             {
1242:..\FreeRTOS\Source/queue.c ****                                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) 
1243:..\FreeRTOS\Source/queue.c ****                                 {
1244:..\FreeRTOS\Source/queue.c ****                                     /* The task waiting has a higher priority so
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 42


1245:..\FreeRTOS\Source/queue.c ****                                      *  record that a context switch is required. */
1246:..\FreeRTOS\Source/queue.c ****                                     if( pxHigherPriorityTaskWoken != NULL )
1247:..\FreeRTOS\Source/queue.c ****                                     {
1248:..\FreeRTOS\Source/queue.c ****                                         *pxHigherPriorityTaskWoken = pdTRUE;
1249:..\FreeRTOS\Source/queue.c ****                                     }
1250:..\FreeRTOS\Source/queue.c ****                                     else
1251:..\FreeRTOS\Source/queue.c ****                                     {
1252:..\FreeRTOS\Source/queue.c ****                                         mtCOVERAGE_TEST_MARKER();
1253:..\FreeRTOS\Source/queue.c ****                                     }
1254:..\FreeRTOS\Source/queue.c ****                                 }
1255:..\FreeRTOS\Source/queue.c ****                                 else
1256:..\FreeRTOS\Source/queue.c ****                                 {
1257:..\FreeRTOS\Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1258:..\FreeRTOS\Source/queue.c ****                                 }
1259:..\FreeRTOS\Source/queue.c ****                             }
1260:..\FreeRTOS\Source/queue.c ****                             else
1261:..\FreeRTOS\Source/queue.c ****                             {
1262:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1263:..\FreeRTOS\Source/queue.c ****                             }
1264:..\FreeRTOS\Source/queue.c ****                         }
1265:..\FreeRTOS\Source/queue.c ****                     }
1266:..\FreeRTOS\Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1267:..\FreeRTOS\Source/queue.c ****                     {
1268:..\FreeRTOS\Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1093              		.loc 1 1268 0
 1094 0070 BB69     		ldr	r3, [r7, #24]
 1095 0072 5B6A     		ldr	r3, [r3, #36]
 1096 0074 002B     		cmp	r3, #0
 1097 0076 1CD0     		beq	.L121
1269:..\FreeRTOS\Source/queue.c ****                         {
1270:..\FreeRTOS\Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 1098              		.loc 1 1270 0
 1099 0078 BB69     		ldr	r3, [r7, #24]
 1100 007a 2433     		adds	r3, r3, #36
 1101 007c 1800     		movs	r0, r3
 1102 007e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1103 0082 031E     		subs	r3, r0, #0
 1104 0084 15D0     		beq	.L121
1271:..\FreeRTOS\Source/queue.c ****                             {
1272:..\FreeRTOS\Source/queue.c ****                                 /* The task waiting has a higher priority so record that a
1273:..\FreeRTOS\Source/queue.c ****                                  * context switch is required. */
1274:..\FreeRTOS\Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
 1105              		.loc 1 1274 0
 1106 0086 3B68     		ldr	r3, [r7]
 1107 0088 002B     		cmp	r3, #0
 1108 008a 12D0     		beq	.L121
1275:..\FreeRTOS\Source/queue.c ****                                 {
1276:..\FreeRTOS\Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
 1109              		.loc 1 1276 0
 1110 008c 3B68     		ldr	r3, [r7]
 1111 008e 0122     		movs	r2, #1
 1112 0090 1A60     		str	r2, [r3]
 1113 0092 0EE0     		b	.L121
 1114              	.L120:
1277:..\FreeRTOS\Source/queue.c ****                                 }
1278:..\FreeRTOS\Source/queue.c ****                                 else
1279:..\FreeRTOS\Source/queue.c ****                                 {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 43


1280:..\FreeRTOS\Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1281:..\FreeRTOS\Source/queue.c ****                                 }
1282:..\FreeRTOS\Source/queue.c ****                             }
1283:..\FreeRTOS\Source/queue.c ****                             else
1284:..\FreeRTOS\Source/queue.c ****                             {
1285:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1286:..\FreeRTOS\Source/queue.c ****                             }
1287:..\FreeRTOS\Source/queue.c ****                         }
1288:..\FreeRTOS\Source/queue.c ****                         else
1289:..\FreeRTOS\Source/queue.c ****                         {
1290:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1291:..\FreeRTOS\Source/queue.c ****                         }
1292:..\FreeRTOS\Source/queue.c ****                     }
1293:..\FreeRTOS\Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1294:..\FreeRTOS\Source/queue.c ****             }
1295:..\FreeRTOS\Source/queue.c ****             else
1296:..\FreeRTOS\Source/queue.c ****             {
1297:..\FreeRTOS\Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1298:..\FreeRTOS\Source/queue.c ****                  * knows that data was posted while it was locked. */
1299:..\FreeRTOS\Source/queue.c ****                 configASSERT( cTxLock != queueINT8_MAX );
 1115              		.loc 1 1299 0
 1116 0094 0E4B     		ldr	r3, .L127
 1117 0096 1B88     		ldrh	r3, [r3]
 1118 0098 002B     		cmp	r3, #0
 1119 009a 01D1     		bne	.L122
 1120              		.loc 1 1299 0 is_stmt 0 discriminator 1
 1121              		.syntax divided
 1122              	@ 1299 "..\FreeRTOS\Source\queue.c" 1
 1123 009c 72B6     		 cpsid i 
 1124              	@ 0 "" 2
 1125              		.thumb
 1126              		.syntax unified
 1127              	.L123:
 1128              		.loc 1 1299 0 discriminator 6
 1129 009e FEE7     		b	.L123
 1130              	.L122:
1300:..\FreeRTOS\Source/queue.c **** 
1301:..\FreeRTOS\Source/queue.c ****                 pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1131              		.loc 1 1301 0 is_stmt 1
 1132 00a0 0F23     		movs	r3, #15
 1133 00a2 FB18     		adds	r3, r7, r3
 1134 00a4 1B78     		ldrb	r3, [r3]
 1135 00a6 0133     		adds	r3, r3, #1
 1136 00a8 DBB2     		uxtb	r3, r3
 1137 00aa 59B2     		sxtb	r1, r3
 1138 00ac BB69     		ldr	r3, [r7, #24]
 1139 00ae 4522     		movs	r2, #69
 1140 00b0 9954     		strb	r1, [r3, r2]
 1141              	.L121:
1302:..\FreeRTOS\Source/queue.c ****             }
1303:..\FreeRTOS\Source/queue.c **** 
1304:..\FreeRTOS\Source/queue.c ****             xReturn = pdPASS;
 1142              		.loc 1 1304 0
 1143 00b2 0123     		movs	r3, #1
 1144 00b4 FB61     		str	r3, [r7, #28]
 1145              	.LBE5:
 1146 00b6 01E0     		b	.L124
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 44


 1147              	.L119:
1305:..\FreeRTOS\Source/queue.c ****         }
1306:..\FreeRTOS\Source/queue.c ****         else
1307:..\FreeRTOS\Source/queue.c ****         {
1308:..\FreeRTOS\Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1309:..\FreeRTOS\Source/queue.c ****             xReturn = errQUEUE_FULL;
 1148              		.loc 1 1309 0
 1149 00b8 0023     		movs	r3, #0
 1150 00ba FB61     		str	r3, [r7, #28]
 1151              	.L124:
 1152              	.LBE4:
1310:..\FreeRTOS\Source/queue.c ****         }
1311:..\FreeRTOS\Source/queue.c ****     }
1312:..\FreeRTOS\Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1153              		.loc 1 1312 0
 1154 00bc 7B69     		ldr	r3, [r7, #20]
 1155 00be 1800     		movs	r0, r3
 1156 00c0 FFF7FEFF 		bl	vClearInterruptMaskFromISR
1313:..\FreeRTOS\Source/queue.c **** 
1314:..\FreeRTOS\Source/queue.c ****     return xReturn;
 1157              		.loc 1 1314 0
 1158 00c4 FB69     		ldr	r3, [r7, #28]
1315:..\FreeRTOS\Source/queue.c **** }
 1159              		.loc 1 1315 0
 1160 00c6 1800     		movs	r0, r3
 1161 00c8 BD46     		mov	sp, r7
 1162 00ca 08B0     		add	sp, sp, #32
 1163              		@ sp needed
 1164 00cc 80BD     		pop	{r7, pc}
 1165              	.L128:
 1166 00ce C046     		.align	2
 1167              	.L127:
 1168 00d0 00000000 		.word	x
 1169              		.cfi_endproc
 1170              	.LFE6:
 1171              		.size	xQueueGiveFromISR, .-xQueueGiveFromISR
 1172              		.section	.text.xQueueReceive,"ax",%progbits
 1173              		.align	2
 1174              		.global	xQueueReceive
 1175              		.code	16
 1176              		.thumb_func
 1177              		.type	xQueueReceive, %function
 1178              	xQueueReceive:
 1179              	.LFB7:
1316:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
1317:..\FreeRTOS\Source/queue.c **** 
1318:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue,
1319:..\FreeRTOS\Source/queue.c ****                           void * const pvBuffer,
1320:..\FreeRTOS\Source/queue.c ****                           TickType_t xTicksToWait )
1321:..\FreeRTOS\Source/queue.c **** {
 1180              		.loc 1 1321 0
 1181              		.cfi_startproc
 1182              		@ args = 0, pretend = 0, frame = 40
 1183              		@ frame_needed = 1, uses_anonymous_args = 0
 1184 0000 80B5     		push	{r7, lr}
 1185              		.cfi_def_cfa_offset 8
 1186              		.cfi_offset 7, -8
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 45


 1187              		.cfi_offset 14, -4
 1188 0002 8AB0     		sub	sp, sp, #40
 1189              		.cfi_def_cfa_offset 48
 1190 0004 00AF     		add	r7, sp, #0
 1191              		.cfi_def_cfa_register 7
 1192 0006 F860     		str	r0, [r7, #12]
 1193 0008 B960     		str	r1, [r7, #8]
 1194 000a 7A60     		str	r2, [r7, #4]
1322:..\FreeRTOS\Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1195              		.loc 1 1322 0
 1196 000c 0023     		movs	r3, #0
 1197 000e 7B62     		str	r3, [r7, #36]
1323:..\FreeRTOS\Source/queue.c ****     TimeOut_t xTimeOut;
1324:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1198              		.loc 1 1324 0
 1199 0010 FB68     		ldr	r3, [r7, #12]
 1200 0012 3B62     		str	r3, [r7, #32]
1325:..\FreeRTOS\Source/queue.c **** 
1326:..\FreeRTOS\Source/queue.c ****     /* Check the pointer is not NULL. */
1327:..\FreeRTOS\Source/queue.c ****     configASSERT( ( pxQueue ) );
 1201              		.loc 1 1327 0
 1202 0014 514B     		ldr	r3, .L155
 1203 0016 1B88     		ldrh	r3, [r3]
 1204 0018 002B     		cmp	r3, #0
 1205 001a 01D1     		bne	.L130
 1206              		.loc 1 1327 0 is_stmt 0 discriminator 1
 1207              		.syntax divided
 1208              	@ 1327 "..\FreeRTOS\Source\queue.c" 1
 1209 001c 72B6     		 cpsid i 
 1210              	@ 0 "" 2
 1211              		.thumb
 1212              		.syntax unified
 1213              	.L131:
 1214 001e FEE7     		b	.L131
 1215              	.L130:
1328:..\FreeRTOS\Source/queue.c **** 
1329:..\FreeRTOS\Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1330:..\FreeRTOS\Source/queue.c ****      * is zero (so no data is copied into the buffer). */
1331:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
 1216              		.loc 1 1331 0 is_stmt 1
 1217 0020 4E4B     		ldr	r3, .L155
 1218 0022 1B88     		ldrh	r3, [r3]
 1219 0024 002B     		cmp	r3, #0
 1220 0026 01D1     		bne	.L132
 1221              		.loc 1 1331 0 is_stmt 0 discriminator 1
 1222              		.syntax divided
 1223              	@ 1331 "..\FreeRTOS\Source\queue.c" 1
 1224 0028 72B6     		 cpsid i 
 1225              	@ 0 "" 2
 1226              		.thumb
 1227              		.syntax unified
 1228              	.L133:
 1229              		.loc 1 1331 0 discriminator 2
 1230 002a FEE7     		b	.L133
 1231              	.L132:
 1232 002c BB68     		ldr	r3, [r7, #8]
 1233 002e C046     		nop
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 46


1332:..\FreeRTOS\Source/queue.c **** 
1333:..\FreeRTOS\Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1334:..\FreeRTOS\Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1335:..\FreeRTOS\Source/queue.c ****         {
1336:..\FreeRTOS\Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
 1234              		.loc 1 1336 0 is_stmt 1 discriminator 2
 1235 0030 4A4B     		ldr	r3, .L155
 1236 0032 1B88     		ldrh	r3, [r3]
 1237 0034 002B     		cmp	r3, #0
 1238 0036 01D1     		bne	.L137
 1239              		.loc 1 1336 0 is_stmt 0 discriminator 1
 1240              		.syntax divided
 1241              	@ 1336 "..\FreeRTOS\Source\queue.c" 1
 1242 0038 72B6     		 cpsid i 
 1243              	@ 0 "" 2
 1244              		.thumb
 1245              		.syntax unified
 1246              	.L138:
 1247              		.loc 1 1336 0 discriminator 3
 1248 003a FEE7     		b	.L138
 1249              	.L137:
 1250              		.loc 1 1336 0 discriminator 2
 1251 003c FFF7FEFF 		bl	xTaskGetSchedulerState
 1252 0040 031E     		subs	r3, r0, #0
 1253 0042 00D1     		bne	.L141
 1254              		.loc 1 1336 0 discriminator 4
 1255 0044 7B68     		ldr	r3, [r7, #4]
 1256              	.L141:
1337:..\FreeRTOS\Source/queue.c ****         }
1338:..\FreeRTOS\Source/queue.c ****     #endif
1339:..\FreeRTOS\Source/queue.c **** 
1340:..\FreeRTOS\Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1341:..\FreeRTOS\Source/queue.c ****      * allow return statements within the function itself.  This is done in the
1342:..\FreeRTOS\Source/queue.c ****      * interest of execution time efficiency. */
1343:..\FreeRTOS\Source/queue.c ****     for( ; ; )
1344:..\FreeRTOS\Source/queue.c ****     {
1345:..\FreeRTOS\Source/queue.c ****         taskENTER_CRITICAL();
 1257              		.loc 1 1345 0 is_stmt 1
 1258 0046 FFF7FEFF 		bl	vPortEnterCritical
 1259              	.LBB6:
1346:..\FreeRTOS\Source/queue.c ****         {
1347:..\FreeRTOS\Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1260              		.loc 1 1347 0
 1261 004a 3B6A     		ldr	r3, [r7, #32]
 1262 004c 9B6B     		ldr	r3, [r3, #56]
 1263 004e FB61     		str	r3, [r7, #28]
1348:..\FreeRTOS\Source/queue.c **** 
1349:..\FreeRTOS\Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1350:..\FreeRTOS\Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1351:..\FreeRTOS\Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1264              		.loc 1 1351 0
 1265 0050 FB69     		ldr	r3, [r7, #28]
 1266 0052 002B     		cmp	r3, #0
 1267 0054 1AD0     		beq	.L142
1352:..\FreeRTOS\Source/queue.c ****             {
1353:..\FreeRTOS\Source/queue.c ****                 /* Data available, remove one item. */
1354:..\FreeRTOS\Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 47


 1268              		.loc 1 1354 0
 1269 0056 BA68     		ldr	r2, [r7, #8]
 1270 0058 3B6A     		ldr	r3, [r7, #32]
 1271 005a 1100     		movs	r1, r2
 1272 005c 1800     		movs	r0, r3
 1273 005e FFF7FEFF 		bl	prvCopyDataFromQueue
1355:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1356:..\FreeRTOS\Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1274              		.loc 1 1356 0
 1275 0062 FB69     		ldr	r3, [r7, #28]
 1276 0064 5A1E     		subs	r2, r3, #1
 1277 0066 3B6A     		ldr	r3, [r7, #32]
 1278 0068 9A63     		str	r2, [r3, #56]
1357:..\FreeRTOS\Source/queue.c **** 
1358:..\FreeRTOS\Source/queue.c ****                 /* There is now space in the queue, were any tasks waiting to
1359:..\FreeRTOS\Source/queue.c ****                  * post to the queue?  If so, unblock the highest priority waiting
1360:..\FreeRTOS\Source/queue.c ****                  * task. */
1361:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1279              		.loc 1 1361 0
 1280 006a 3B6A     		ldr	r3, [r7, #32]
 1281 006c 1B69     		ldr	r3, [r3, #16]
 1282 006e 002B     		cmp	r3, #0
 1283 0070 08D0     		beq	.L143
1362:..\FreeRTOS\Source/queue.c ****                 {
1363:..\FreeRTOS\Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1284              		.loc 1 1363 0
 1285 0072 3B6A     		ldr	r3, [r7, #32]
 1286 0074 1033     		adds	r3, r3, #16
 1287 0076 1800     		movs	r0, r3
 1288 0078 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1289 007c 031E     		subs	r3, r0, #0
 1290 007e 01D0     		beq	.L143
1364:..\FreeRTOS\Source/queue.c ****                     {
1365:..\FreeRTOS\Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 1291              		.loc 1 1365 0
 1292 0080 FFF7FEFF 		bl	vPortYield
 1293              	.L143:
1366:..\FreeRTOS\Source/queue.c ****                     }
1367:..\FreeRTOS\Source/queue.c ****                     else
1368:..\FreeRTOS\Source/queue.c ****                     {
1369:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1370:..\FreeRTOS\Source/queue.c ****                     }
1371:..\FreeRTOS\Source/queue.c ****                 }
1372:..\FreeRTOS\Source/queue.c ****                 else
1373:..\FreeRTOS\Source/queue.c ****                 {
1374:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1375:..\FreeRTOS\Source/queue.c ****                 }
1376:..\FreeRTOS\Source/queue.c **** 
1377:..\FreeRTOS\Source/queue.c ****                 taskEXIT_CRITICAL();
 1294              		.loc 1 1377 0
 1295 0084 FFF7FEFF 		bl	vPortExitCritical
1378:..\FreeRTOS\Source/queue.c ****                 return pdPASS;
 1296              		.loc 1 1378 0
 1297 0088 0123     		movs	r3, #1
 1298 008a 62E0     		b	.L153
 1299              	.L142:
1379:..\FreeRTOS\Source/queue.c ****             }
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 48


1380:..\FreeRTOS\Source/queue.c ****             else
1381:..\FreeRTOS\Source/queue.c ****             {
1382:..\FreeRTOS\Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 1300              		.loc 1 1382 0
 1301 008c 7B68     		ldr	r3, [r7, #4]
 1302 008e 002B     		cmp	r3, #0
 1303 0090 03D1     		bne	.L145
1383:..\FreeRTOS\Source/queue.c ****                 {
1384:..\FreeRTOS\Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1385:..\FreeRTOS\Source/queue.c ****                      * the block time has expired) so leave now. */
1386:..\FreeRTOS\Source/queue.c ****                     taskEXIT_CRITICAL();
 1304              		.loc 1 1386 0
 1305 0092 FFF7FEFF 		bl	vPortExitCritical
1387:..\FreeRTOS\Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1388:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_EMPTY;
 1306              		.loc 1 1388 0
 1307 0096 0023     		movs	r3, #0
 1308 0098 5BE0     		b	.L153
 1309              	.L145:
1389:..\FreeRTOS\Source/queue.c ****                 }
1390:..\FreeRTOS\Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 1310              		.loc 1 1390 0
 1311 009a 7B6A     		ldr	r3, [r7, #36]
 1312 009c 002B     		cmp	r3, #0
 1313 009e 06D1     		bne	.L146
1391:..\FreeRTOS\Source/queue.c ****                 {
1392:..\FreeRTOS\Source/queue.c ****                     /* The queue was empty and a block time was specified so
1393:..\FreeRTOS\Source/queue.c ****                      * configure the timeout structure. */
1394:..\FreeRTOS\Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 1314              		.loc 1 1394 0
 1315 00a0 1423     		movs	r3, #20
 1316 00a2 FB18     		adds	r3, r7, r3
 1317 00a4 1800     		movs	r0, r3
 1318 00a6 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1395:..\FreeRTOS\Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 1319              		.loc 1 1395 0
 1320 00aa 0123     		movs	r3, #1
 1321 00ac 7B62     		str	r3, [r7, #36]
 1322              	.L146:
 1323              	.LBE6:
1396:..\FreeRTOS\Source/queue.c ****                 }
1397:..\FreeRTOS\Source/queue.c ****                 else
1398:..\FreeRTOS\Source/queue.c ****                 {
1399:..\FreeRTOS\Source/queue.c ****                     /* Entry time was already set. */
1400:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1401:..\FreeRTOS\Source/queue.c ****                 }
1402:..\FreeRTOS\Source/queue.c ****             }
1403:..\FreeRTOS\Source/queue.c ****         }
1404:..\FreeRTOS\Source/queue.c ****         taskEXIT_CRITICAL();
 1324              		.loc 1 1404 0
 1325 00ae FFF7FEFF 		bl	vPortExitCritical
1405:..\FreeRTOS\Source/queue.c **** 
1406:..\FreeRTOS\Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1407:..\FreeRTOS\Source/queue.c ****          * now the critical section has been exited. */
1408:..\FreeRTOS\Source/queue.c **** 
1409:..\FreeRTOS\Source/queue.c ****         vTaskSuspendAll();
 1326              		.loc 1 1409 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 49


 1327 00b2 FFF7FEFF 		bl	vTaskSuspendAll
1410:..\FreeRTOS\Source/queue.c ****         prvLockQueue( pxQueue );
 1328              		.loc 1 1410 0
 1329 00b6 FFF7FEFF 		bl	vPortEnterCritical
 1330 00ba 3B6A     		ldr	r3, [r7, #32]
 1331 00bc 4422     		movs	r2, #68
 1332 00be 9B5C     		ldrb	r3, [r3, r2]
 1333 00c0 5BB2     		sxtb	r3, r3
 1334 00c2 0133     		adds	r3, r3, #1
 1335 00c4 03D1     		bne	.L147
 1336              		.loc 1 1410 0 is_stmt 0 discriminator 1
 1337 00c6 3B6A     		ldr	r3, [r7, #32]
 1338 00c8 4422     		movs	r2, #68
 1339 00ca 0021     		movs	r1, #0
 1340 00cc 9954     		strb	r1, [r3, r2]
 1341              	.L147:
 1342              		.loc 1 1410 0 discriminator 3
 1343 00ce 3B6A     		ldr	r3, [r7, #32]
 1344 00d0 4522     		movs	r2, #69
 1345 00d2 9B5C     		ldrb	r3, [r3, r2]
 1346 00d4 5BB2     		sxtb	r3, r3
 1347 00d6 0133     		adds	r3, r3, #1
 1348 00d8 03D1     		bne	.L148
 1349              		.loc 1 1410 0 discriminator 4
 1350 00da 3B6A     		ldr	r3, [r7, #32]
 1351 00dc 4522     		movs	r2, #69
 1352 00de 0021     		movs	r1, #0
 1353 00e0 9954     		strb	r1, [r3, r2]
 1354              	.L148:
 1355              		.loc 1 1410 0 discriminator 6
 1356 00e2 FFF7FEFF 		bl	vPortExitCritical
1411:..\FreeRTOS\Source/queue.c **** 
1412:..\FreeRTOS\Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1413:..\FreeRTOS\Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1357              		.loc 1 1413 0 is_stmt 1 discriminator 6
 1358 00e6 3A1D     		adds	r2, r7, #4
 1359 00e8 1423     		movs	r3, #20
 1360 00ea FB18     		adds	r3, r7, r3
 1361 00ec 1100     		movs	r1, r2
 1362 00ee 1800     		movs	r0, r3
 1363 00f0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1364 00f4 031E     		subs	r3, r0, #0
 1365 00f6 1ED1     		bne	.L149
1414:..\FreeRTOS\Source/queue.c ****         {
1415:..\FreeRTOS\Source/queue.c ****             /* The timeout has not expired.  If the queue is still empty place
1416:..\FreeRTOS\Source/queue.c ****              * the task on the list of tasks waiting to receive from the queue. */
1417:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1366              		.loc 1 1417 0
 1367 00f8 3B6A     		ldr	r3, [r7, #32]
 1368 00fa 1800     		movs	r0, r3
 1369 00fc FFF7FEFF 		bl	prvIsQueueEmpty
 1370 0100 031E     		subs	r3, r0, #0
 1371 0102 11D0     		beq	.L150
1418:..\FreeRTOS\Source/queue.c ****             {
1419:..\FreeRTOS\Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1420:..\FreeRTOS\Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1372              		.loc 1 1420 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 50


 1373 0104 3B6A     		ldr	r3, [r7, #32]
 1374 0106 2433     		adds	r3, r3, #36
 1375 0108 7A68     		ldr	r2, [r7, #4]
 1376 010a 1100     		movs	r1, r2
 1377 010c 1800     		movs	r0, r3
 1378 010e FFF7FEFF 		bl	vTaskPlaceOnEventList
1421:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1379              		.loc 1 1421 0
 1380 0112 3B6A     		ldr	r3, [r7, #32]
 1381 0114 1800     		movs	r0, r3
 1382 0116 FFF7FEFF 		bl	prvUnlockQueue
1422:..\FreeRTOS\Source/queue.c **** 
1423:..\FreeRTOS\Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 1383              		.loc 1 1423 0
 1384 011a FFF7FEFF 		bl	xTaskResumeAll
 1385 011e 031E     		subs	r3, r0, #0
 1386 0120 91D1     		bne	.L141
1424:..\FreeRTOS\Source/queue.c ****                 {
1425:..\FreeRTOS\Source/queue.c ****                     portYIELD_WITHIN_API();
 1387              		.loc 1 1425 0
 1388 0122 FFF7FEFF 		bl	vPortYield
 1389 0126 8EE7     		b	.L141
 1390              	.L150:
1426:..\FreeRTOS\Source/queue.c ****                 }
1427:..\FreeRTOS\Source/queue.c ****                 else
1428:..\FreeRTOS\Source/queue.c ****                 {
1429:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1430:..\FreeRTOS\Source/queue.c ****                 }
1431:..\FreeRTOS\Source/queue.c ****             }
1432:..\FreeRTOS\Source/queue.c ****             else
1433:..\FreeRTOS\Source/queue.c ****             {
1434:..\FreeRTOS\Source/queue.c ****                 /* The queue contains data again.  Loop back to try and read the
1435:..\FreeRTOS\Source/queue.c ****                  * data. */
1436:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1391              		.loc 1 1436 0
 1392 0128 3B6A     		ldr	r3, [r7, #32]
 1393 012a 1800     		movs	r0, r3
 1394 012c FFF7FEFF 		bl	prvUnlockQueue
1437:..\FreeRTOS\Source/queue.c ****                 ( void ) xTaskResumeAll();
 1395              		.loc 1 1437 0
 1396 0130 FFF7FEFF 		bl	xTaskResumeAll
 1397 0134 87E7     		b	.L141
 1398              	.L149:
1438:..\FreeRTOS\Source/queue.c ****             }
1439:..\FreeRTOS\Source/queue.c ****         }
1440:..\FreeRTOS\Source/queue.c ****         else
1441:..\FreeRTOS\Source/queue.c ****         {
1442:..\FreeRTOS\Source/queue.c ****             /* Timed out.  If there is no data in the queue exit, otherwise loop
1443:..\FreeRTOS\Source/queue.c ****              * back and attempt to read the data. */
1444:..\FreeRTOS\Source/queue.c ****             prvUnlockQueue( pxQueue );
 1399              		.loc 1 1444 0
 1400 0136 3B6A     		ldr	r3, [r7, #32]
 1401 0138 1800     		movs	r0, r3
 1402 013a FFF7FEFF 		bl	prvUnlockQueue
1445:..\FreeRTOS\Source/queue.c ****             ( void ) xTaskResumeAll();
 1403              		.loc 1 1445 0
 1404 013e FFF7FEFF 		bl	xTaskResumeAll
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 51


1446:..\FreeRTOS\Source/queue.c **** 
1447:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1405              		.loc 1 1447 0
 1406 0142 3B6A     		ldr	r3, [r7, #32]
 1407 0144 1800     		movs	r0, r3
 1408 0146 FFF7FEFF 		bl	prvIsQueueEmpty
 1409 014a 031E     		subs	r3, r0, #0
 1410 014c 00D1     		bne	.LCB1147
 1411 014e 7AE7     		b	.L141	@long jump
 1412              	.LCB1147:
1448:..\FreeRTOS\Source/queue.c ****             {
1449:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1450:..\FreeRTOS\Source/queue.c ****                 return errQUEUE_EMPTY;
 1413              		.loc 1 1450 0
 1414 0150 0023     		movs	r3, #0
 1415              	.L153:
1451:..\FreeRTOS\Source/queue.c ****             }
1452:..\FreeRTOS\Source/queue.c ****             else
1453:..\FreeRTOS\Source/queue.c ****             {
1454:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1455:..\FreeRTOS\Source/queue.c ****             }
1456:..\FreeRTOS\Source/queue.c ****         }
1457:..\FreeRTOS\Source/queue.c ****     } /*lint -restore */
1458:..\FreeRTOS\Source/queue.c **** }
 1416              		.loc 1 1458 0 discriminator 6
 1417 0152 1800     		movs	r0, r3
 1418 0154 BD46     		mov	sp, r7
 1419 0156 0AB0     		add	sp, sp, #40
 1420              		@ sp needed
 1421 0158 80BD     		pop	{r7, pc}
 1422              	.L156:
 1423 015a C046     		.align	2
 1424              	.L155:
 1425 015c 00000000 		.word	x
 1426              		.cfi_endproc
 1427              	.LFE7:
 1428              		.size	xQueueReceive, .-xQueueReceive
 1429              		.section	.text.xQueueSemaphoreTake,"ax",%progbits
 1430              		.align	2
 1431              		.global	xQueueSemaphoreTake
 1432              		.code	16
 1433              		.thumb_func
 1434              		.type	xQueueSemaphoreTake, %function
 1435              	xQueueSemaphoreTake:
 1436              	.LFB8:
1459:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
1460:..\FreeRTOS\Source/queue.c **** 
1461:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
1462:..\FreeRTOS\Source/queue.c ****                                 TickType_t xTicksToWait )
1463:..\FreeRTOS\Source/queue.c **** {
 1437              		.loc 1 1463 0
 1438              		.cfi_startproc
 1439              		@ args = 0, pretend = 0, frame = 32
 1440              		@ frame_needed = 1, uses_anonymous_args = 0
 1441 0000 80B5     		push	{r7, lr}
 1442              		.cfi_def_cfa_offset 8
 1443              		.cfi_offset 7, -8
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 52


 1444              		.cfi_offset 14, -4
 1445 0002 88B0     		sub	sp, sp, #32
 1446              		.cfi_def_cfa_offset 40
 1447 0004 00AF     		add	r7, sp, #0
 1448              		.cfi_def_cfa_register 7
 1449 0006 7860     		str	r0, [r7, #4]
 1450 0008 3960     		str	r1, [r7]
1464:..\FreeRTOS\Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1451              		.loc 1 1464 0
 1452 000a 0023     		movs	r3, #0
 1453 000c FB61     		str	r3, [r7, #28]
1465:..\FreeRTOS\Source/queue.c ****     TimeOut_t xTimeOut;
1466:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1454              		.loc 1 1466 0
 1455 000e 7B68     		ldr	r3, [r7, #4]
 1456 0010 BB61     		str	r3, [r7, #24]
1467:..\FreeRTOS\Source/queue.c **** 
1468:..\FreeRTOS\Source/queue.c ****     #if ( configUSE_MUTEXES == 1 )
1469:..\FreeRTOS\Source/queue.c ****         BaseType_t xInheritanceOccurred = pdFALSE;
1470:..\FreeRTOS\Source/queue.c ****     #endif
1471:..\FreeRTOS\Source/queue.c **** 
1472:..\FreeRTOS\Source/queue.c ****     /* Check the queue pointer is not NULL. */
1473:..\FreeRTOS\Source/queue.c ****     configASSERT( ( pxQueue ) );
 1457              		.loc 1 1473 0
 1458 0012 4D4B     		ldr	r3, .L179
 1459 0014 1B88     		ldrh	r3, [r3]
 1460 0016 002B     		cmp	r3, #0
 1461 0018 01D1     		bne	.L158
 1462              		.loc 1 1473 0 is_stmt 0 discriminator 1
 1463              		.syntax divided
 1464              	@ 1473 "..\FreeRTOS\Source\queue.c" 1
 1465 001a 72B6     		 cpsid i 
 1466              	@ 0 "" 2
 1467              		.thumb
 1468              		.syntax unified
 1469              	.L159:
 1470 001c FEE7     		b	.L159
 1471              	.L158:
1474:..\FreeRTOS\Source/queue.c **** 
1475:..\FreeRTOS\Source/queue.c ****     /* Check this really is a semaphore, in which case the item size will be
1476:..\FreeRTOS\Source/queue.c ****      * 0. */
1477:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
 1472              		.loc 1 1477 0 is_stmt 1
 1473 001e 4A4B     		ldr	r3, .L179
 1474 0020 1B88     		ldrh	r3, [r3]
 1475 0022 002B     		cmp	r3, #0
 1476 0024 01D1     		bne	.L160
 1477              		.loc 1 1477 0 is_stmt 0 discriminator 1
 1478              		.syntax divided
 1479              	@ 1477 "..\FreeRTOS\Source\queue.c" 1
 1480 0026 72B6     		 cpsid i 
 1481              	@ 0 "" 2
 1482              		.thumb
 1483              		.syntax unified
 1484              	.L161:
 1485              		.loc 1 1477 0 discriminator 2
 1486 0028 FEE7     		b	.L161
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 53


 1487              	.L160:
1478:..\FreeRTOS\Source/queue.c **** 
1479:..\FreeRTOS\Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1480:..\FreeRTOS\Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1481:..\FreeRTOS\Source/queue.c ****         {
1482:..\FreeRTOS\Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
 1488              		.loc 1 1482 0 is_stmt 1 discriminator 2
 1489 002a 474B     		ldr	r3, .L179
 1490 002c 1B88     		ldrh	r3, [r3]
 1491 002e 002B     		cmp	r3, #0
 1492 0030 01D1     		bne	.L162
 1493              		.loc 1 1482 0 is_stmt 0 discriminator 1
 1494              		.syntax divided
 1495              	@ 1482 "..\FreeRTOS\Source\queue.c" 1
 1496 0032 72B6     		 cpsid i 
 1497              	@ 0 "" 2
 1498              		.thumb
 1499              		.syntax unified
 1500              	.L163:
 1501              		.loc 1 1482 0 discriminator 3
 1502 0034 FEE7     		b	.L163
 1503              	.L162:
 1504              		.loc 1 1482 0 discriminator 2
 1505 0036 FFF7FEFF 		bl	xTaskGetSchedulerState
 1506 003a 031E     		subs	r3, r0, #0
 1507 003c 00D1     		bne	.L166
 1508              		.loc 1 1482 0 discriminator 4
 1509 003e 3B68     		ldr	r3, [r7]
 1510              	.L166:
1483:..\FreeRTOS\Source/queue.c ****         }
1484:..\FreeRTOS\Source/queue.c ****     #endif
1485:..\FreeRTOS\Source/queue.c **** 
1486:..\FreeRTOS\Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1487:..\FreeRTOS\Source/queue.c ****      * statements within the function itself.  This is done in the interest
1488:..\FreeRTOS\Source/queue.c ****      * of execution time efficiency. */
1489:..\FreeRTOS\Source/queue.c ****     for( ; ; )
1490:..\FreeRTOS\Source/queue.c ****     {
1491:..\FreeRTOS\Source/queue.c ****         taskENTER_CRITICAL();
 1511              		.loc 1 1491 0 is_stmt 1
 1512 0040 FFF7FEFF 		bl	vPortEnterCritical
 1513              	.LBB7:
1492:..\FreeRTOS\Source/queue.c ****         {
1493:..\FreeRTOS\Source/queue.c ****             /* Semaphores are queues with an item size of 0, and where the
1494:..\FreeRTOS\Source/queue.c ****              * number of messages in the queue is the semaphore's count value. */
1495:..\FreeRTOS\Source/queue.c ****             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 1514              		.loc 1 1495 0
 1515 0044 BB69     		ldr	r3, [r7, #24]
 1516 0046 9B6B     		ldr	r3, [r3, #56]
 1517 0048 7B61     		str	r3, [r7, #20]
1496:..\FreeRTOS\Source/queue.c **** 
1497:..\FreeRTOS\Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1498:..\FreeRTOS\Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1499:..\FreeRTOS\Source/queue.c ****             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 1518              		.loc 1 1499 0
 1519 004a 7B69     		ldr	r3, [r7, #20]
 1520 004c 002B     		cmp	r3, #0
 1521 004e 14D0     		beq	.L167
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 54


1500:..\FreeRTOS\Source/queue.c ****             {
1501:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1502:..\FreeRTOS\Source/queue.c **** 
1503:..\FreeRTOS\Source/queue.c ****                 /* Semaphores are queues with a data size of zero and where the
1504:..\FreeRTOS\Source/queue.c ****                  * messages waiting is the semaphore's count.  Reduce the count. */
1505:..\FreeRTOS\Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 1522              		.loc 1 1505 0
 1523 0050 7B69     		ldr	r3, [r7, #20]
 1524 0052 5A1E     		subs	r2, r3, #1
 1525 0054 BB69     		ldr	r3, [r7, #24]
 1526 0056 9A63     		str	r2, [r3, #56]
1506:..\FreeRTOS\Source/queue.c **** 
1507:..\FreeRTOS\Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1508:..\FreeRTOS\Source/queue.c ****                     {
1509:..\FreeRTOS\Source/queue.c ****                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1510:..\FreeRTOS\Source/queue.c ****                         {
1511:..\FreeRTOS\Source/queue.c ****                             /* Record the information required to implement
1512:..\FreeRTOS\Source/queue.c ****                              * priority inheritance should it become necessary. */
1513:..\FreeRTOS\Source/queue.c ****                             pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1514:..\FreeRTOS\Source/queue.c ****                         }
1515:..\FreeRTOS\Source/queue.c ****                         else
1516:..\FreeRTOS\Source/queue.c ****                         {
1517:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1518:..\FreeRTOS\Source/queue.c ****                         }
1519:..\FreeRTOS\Source/queue.c ****                     }
1520:..\FreeRTOS\Source/queue.c ****                 #endif /* configUSE_MUTEXES */
1521:..\FreeRTOS\Source/queue.c **** 
1522:..\FreeRTOS\Source/queue.c ****                 /* Check to see if other tasks are blocked waiting to give the
1523:..\FreeRTOS\Source/queue.c ****                  * semaphore, and if so, unblock the highest priority such task. */
1524:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1527              		.loc 1 1524 0
 1528 0058 BB69     		ldr	r3, [r7, #24]
 1529 005a 1B69     		ldr	r3, [r3, #16]
 1530 005c 002B     		cmp	r3, #0
 1531 005e 08D0     		beq	.L168
1525:..\FreeRTOS\Source/queue.c ****                 {
1526:..\FreeRTOS\Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1532              		.loc 1 1526 0
 1533 0060 BB69     		ldr	r3, [r7, #24]
 1534 0062 1033     		adds	r3, r3, #16
 1535 0064 1800     		movs	r0, r3
 1536 0066 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1537 006a 031E     		subs	r3, r0, #0
 1538 006c 01D0     		beq	.L168
1527:..\FreeRTOS\Source/queue.c ****                     {
1528:..\FreeRTOS\Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 1539              		.loc 1 1528 0
 1540 006e FFF7FEFF 		bl	vPortYield
 1541              	.L168:
1529:..\FreeRTOS\Source/queue.c ****                     }
1530:..\FreeRTOS\Source/queue.c ****                     else
1531:..\FreeRTOS\Source/queue.c ****                     {
1532:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1533:..\FreeRTOS\Source/queue.c ****                     }
1534:..\FreeRTOS\Source/queue.c ****                 }
1535:..\FreeRTOS\Source/queue.c ****                 else
1536:..\FreeRTOS\Source/queue.c ****                 {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 55


1537:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1538:..\FreeRTOS\Source/queue.c ****                 }
1539:..\FreeRTOS\Source/queue.c **** 
1540:..\FreeRTOS\Source/queue.c ****                 taskEXIT_CRITICAL();
 1542              		.loc 1 1540 0
 1543 0072 FFF7FEFF 		bl	vPortExitCritical
1541:..\FreeRTOS\Source/queue.c ****                 return pdPASS;
 1544              		.loc 1 1541 0
 1545 0076 0123     		movs	r3, #1
 1546 0078 62E0     		b	.L178
 1547              	.L167:
1542:..\FreeRTOS\Source/queue.c ****             }
1543:..\FreeRTOS\Source/queue.c ****             else
1544:..\FreeRTOS\Source/queue.c ****             {
1545:..\FreeRTOS\Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 1548              		.loc 1 1545 0
 1549 007a 3B68     		ldr	r3, [r7]
 1550 007c 002B     		cmp	r3, #0
 1551 007e 03D1     		bne	.L170
1546:..\FreeRTOS\Source/queue.c ****                 {
1547:..\FreeRTOS\Source/queue.c ****                     /* For inheritance to have occurred there must have been an
1548:..\FreeRTOS\Source/queue.c ****                      * initial timeout, and an adjusted timeout cannot become 0, as
1549:..\FreeRTOS\Source/queue.c ****                      * if it were 0 the function would have exited. */
1550:..\FreeRTOS\Source/queue.c ****                     #if ( configUSE_MUTEXES == 1 )
1551:..\FreeRTOS\Source/queue.c ****                         {
1552:..\FreeRTOS\Source/queue.c ****                             configASSERT( xInheritanceOccurred == pdFALSE );
1553:..\FreeRTOS\Source/queue.c ****                         }
1554:..\FreeRTOS\Source/queue.c ****                     #endif /* configUSE_MUTEXES */
1555:..\FreeRTOS\Source/queue.c **** 
1556:..\FreeRTOS\Source/queue.c ****                     /* The semaphore count was 0 and no block time is specified
1557:..\FreeRTOS\Source/queue.c ****                      * (or the block time has expired) so exit now. */
1558:..\FreeRTOS\Source/queue.c ****                     taskEXIT_CRITICAL();
 1552              		.loc 1 1558 0
 1553 0080 FFF7FEFF 		bl	vPortExitCritical
1559:..\FreeRTOS\Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1560:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_EMPTY;
 1554              		.loc 1 1560 0
 1555 0084 0023     		movs	r3, #0
 1556 0086 5BE0     		b	.L178
 1557              	.L170:
1561:..\FreeRTOS\Source/queue.c ****                 }
1562:..\FreeRTOS\Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 1558              		.loc 1 1562 0
 1559 0088 FB69     		ldr	r3, [r7, #28]
 1560 008a 002B     		cmp	r3, #0
 1561 008c 06D1     		bne	.L171
1563:..\FreeRTOS\Source/queue.c ****                 {
1564:..\FreeRTOS\Source/queue.c ****                     /* The semaphore count was 0 and a block time was specified
1565:..\FreeRTOS\Source/queue.c ****                      * so configure the timeout structure ready to block. */
1566:..\FreeRTOS\Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 1562              		.loc 1 1566 0
 1563 008e 0C23     		movs	r3, #12
 1564 0090 FB18     		adds	r3, r7, r3
 1565 0092 1800     		movs	r0, r3
 1566 0094 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1567:..\FreeRTOS\Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 1567              		.loc 1 1567 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 56


 1568 0098 0123     		movs	r3, #1
 1569 009a FB61     		str	r3, [r7, #28]
 1570              	.L171:
 1571              	.LBE7:
1568:..\FreeRTOS\Source/queue.c ****                 }
1569:..\FreeRTOS\Source/queue.c ****                 else
1570:..\FreeRTOS\Source/queue.c ****                 {
1571:..\FreeRTOS\Source/queue.c ****                     /* Entry time was already set. */
1572:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1573:..\FreeRTOS\Source/queue.c ****                 }
1574:..\FreeRTOS\Source/queue.c ****             }
1575:..\FreeRTOS\Source/queue.c ****         }
1576:..\FreeRTOS\Source/queue.c ****         taskEXIT_CRITICAL();
 1572              		.loc 1 1576 0
 1573 009c FFF7FEFF 		bl	vPortExitCritical
1577:..\FreeRTOS\Source/queue.c **** 
1578:..\FreeRTOS\Source/queue.c ****         /* Interrupts and other tasks can give to and take from the semaphore
1579:..\FreeRTOS\Source/queue.c ****          * now the critical section has been exited. */
1580:..\FreeRTOS\Source/queue.c **** 
1581:..\FreeRTOS\Source/queue.c ****         vTaskSuspendAll();
 1574              		.loc 1 1581 0
 1575 00a0 FFF7FEFF 		bl	vTaskSuspendAll
1582:..\FreeRTOS\Source/queue.c ****         prvLockQueue( pxQueue );
 1576              		.loc 1 1582 0
 1577 00a4 FFF7FEFF 		bl	vPortEnterCritical
 1578 00a8 BB69     		ldr	r3, [r7, #24]
 1579 00aa 4422     		movs	r2, #68
 1580 00ac 9B5C     		ldrb	r3, [r3, r2]
 1581 00ae 5BB2     		sxtb	r3, r3
 1582 00b0 0133     		adds	r3, r3, #1
 1583 00b2 03D1     		bne	.L172
 1584              		.loc 1 1582 0 is_stmt 0 discriminator 1
 1585 00b4 BB69     		ldr	r3, [r7, #24]
 1586 00b6 4422     		movs	r2, #68
 1587 00b8 0021     		movs	r1, #0
 1588 00ba 9954     		strb	r1, [r3, r2]
 1589              	.L172:
 1590              		.loc 1 1582 0 discriminator 3
 1591 00bc BB69     		ldr	r3, [r7, #24]
 1592 00be 4522     		movs	r2, #69
 1593 00c0 9B5C     		ldrb	r3, [r3, r2]
 1594 00c2 5BB2     		sxtb	r3, r3
 1595 00c4 0133     		adds	r3, r3, #1
 1596 00c6 03D1     		bne	.L173
 1597              		.loc 1 1582 0 discriminator 4
 1598 00c8 BB69     		ldr	r3, [r7, #24]
 1599 00ca 4522     		movs	r2, #69
 1600 00cc 0021     		movs	r1, #0
 1601 00ce 9954     		strb	r1, [r3, r2]
 1602              	.L173:
 1603              		.loc 1 1582 0 discriminator 6
 1604 00d0 FFF7FEFF 		bl	vPortExitCritical
1583:..\FreeRTOS\Source/queue.c **** 
1584:..\FreeRTOS\Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1585:..\FreeRTOS\Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1605              		.loc 1 1585 0 is_stmt 1 discriminator 6
 1606 00d4 3A00     		movs	r2, r7
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 57


 1607 00d6 0C23     		movs	r3, #12
 1608 00d8 FB18     		adds	r3, r7, r3
 1609 00da 1100     		movs	r1, r2
 1610 00dc 1800     		movs	r0, r3
 1611 00de FFF7FEFF 		bl	xTaskCheckForTimeOut
 1612 00e2 031E     		subs	r3, r0, #0
 1613 00e4 1ED1     		bne	.L174
1586:..\FreeRTOS\Source/queue.c ****         {
1587:..\FreeRTOS\Source/queue.c ****             /* A block time is specified and not expired.  If the semaphore
1588:..\FreeRTOS\Source/queue.c ****              * count is 0 then enter the Blocked state to wait for a semaphore to
1589:..\FreeRTOS\Source/queue.c ****              * become available.  As semaphores are implemented with queues the
1590:..\FreeRTOS\Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1591:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1614              		.loc 1 1591 0
 1615 00e6 BB69     		ldr	r3, [r7, #24]
 1616 00e8 1800     		movs	r0, r3
 1617 00ea FFF7FEFF 		bl	prvIsQueueEmpty
 1618 00ee 031E     		subs	r3, r0, #0
 1619 00f0 11D0     		beq	.L175
1592:..\FreeRTOS\Source/queue.c ****             {
1593:..\FreeRTOS\Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1594:..\FreeRTOS\Source/queue.c **** 
1595:..\FreeRTOS\Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1596:..\FreeRTOS\Source/queue.c ****                     {
1597:..\FreeRTOS\Source/queue.c ****                         if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1598:..\FreeRTOS\Source/queue.c ****                         {
1599:..\FreeRTOS\Source/queue.c ****                             taskENTER_CRITICAL();
1600:..\FreeRTOS\Source/queue.c ****                             {
1601:..\FreeRTOS\Source/queue.c ****                                 xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.
1602:..\FreeRTOS\Source/queue.c ****                             }
1603:..\FreeRTOS\Source/queue.c ****                             taskEXIT_CRITICAL();
1604:..\FreeRTOS\Source/queue.c ****                         }
1605:..\FreeRTOS\Source/queue.c ****                         else
1606:..\FreeRTOS\Source/queue.c ****                         {
1607:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1608:..\FreeRTOS\Source/queue.c ****                         }
1609:..\FreeRTOS\Source/queue.c ****                     }
1610:..\FreeRTOS\Source/queue.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1611:..\FreeRTOS\Source/queue.c **** 
1612:..\FreeRTOS\Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1620              		.loc 1 1612 0
 1621 00f2 BB69     		ldr	r3, [r7, #24]
 1622 00f4 2433     		adds	r3, r3, #36
 1623 00f6 3A68     		ldr	r2, [r7]
 1624 00f8 1100     		movs	r1, r2
 1625 00fa 1800     		movs	r0, r3
 1626 00fc FFF7FEFF 		bl	vTaskPlaceOnEventList
1613:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1627              		.loc 1 1613 0
 1628 0100 BB69     		ldr	r3, [r7, #24]
 1629 0102 1800     		movs	r0, r3
 1630 0104 FFF7FEFF 		bl	prvUnlockQueue
1614:..\FreeRTOS\Source/queue.c **** 
1615:..\FreeRTOS\Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 1631              		.loc 1 1615 0
 1632 0108 FFF7FEFF 		bl	xTaskResumeAll
 1633 010c 031E     		subs	r3, r0, #0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 58


 1634 010e 97D1     		bne	.L166
1616:..\FreeRTOS\Source/queue.c ****                 {
1617:..\FreeRTOS\Source/queue.c ****                     portYIELD_WITHIN_API();
 1635              		.loc 1 1617 0
 1636 0110 FFF7FEFF 		bl	vPortYield
 1637 0114 94E7     		b	.L166
 1638              	.L175:
1618:..\FreeRTOS\Source/queue.c ****                 }
1619:..\FreeRTOS\Source/queue.c ****                 else
1620:..\FreeRTOS\Source/queue.c ****                 {
1621:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1622:..\FreeRTOS\Source/queue.c ****                 }
1623:..\FreeRTOS\Source/queue.c ****             }
1624:..\FreeRTOS\Source/queue.c ****             else
1625:..\FreeRTOS\Source/queue.c ****             {
1626:..\FreeRTOS\Source/queue.c ****                 /* There was no timeout and the semaphore count was not 0, so
1627:..\FreeRTOS\Source/queue.c ****                  * attempt to take the semaphore again. */
1628:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1639              		.loc 1 1628 0
 1640 0116 BB69     		ldr	r3, [r7, #24]
 1641 0118 1800     		movs	r0, r3
 1642 011a FFF7FEFF 		bl	prvUnlockQueue
1629:..\FreeRTOS\Source/queue.c ****                 ( void ) xTaskResumeAll();
 1643              		.loc 1 1629 0
 1644 011e FFF7FEFF 		bl	xTaskResumeAll
 1645 0122 8DE7     		b	.L166
 1646              	.L174:
1630:..\FreeRTOS\Source/queue.c ****             }
1631:..\FreeRTOS\Source/queue.c ****         }
1632:..\FreeRTOS\Source/queue.c ****         else
1633:..\FreeRTOS\Source/queue.c ****         {
1634:..\FreeRTOS\Source/queue.c ****             /* Timed out. */
1635:..\FreeRTOS\Source/queue.c ****             prvUnlockQueue( pxQueue );
 1647              		.loc 1 1635 0
 1648 0124 BB69     		ldr	r3, [r7, #24]
 1649 0126 1800     		movs	r0, r3
 1650 0128 FFF7FEFF 		bl	prvUnlockQueue
1636:..\FreeRTOS\Source/queue.c ****             ( void ) xTaskResumeAll();
 1651              		.loc 1 1636 0
 1652 012c FFF7FEFF 		bl	xTaskResumeAll
1637:..\FreeRTOS\Source/queue.c **** 
1638:..\FreeRTOS\Source/queue.c ****             /* If the semaphore count is 0 exit now as the timeout has
1639:..\FreeRTOS\Source/queue.c ****              * expired.  Otherwise return to attempt to take the semaphore that is
1640:..\FreeRTOS\Source/queue.c ****              * known to be available.  As semaphores are implemented by queues the
1641:..\FreeRTOS\Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1642:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1653              		.loc 1 1642 0
 1654 0130 BB69     		ldr	r3, [r7, #24]
 1655 0132 1800     		movs	r0, r3
 1656 0134 FFF7FEFF 		bl	prvIsQueueEmpty
 1657 0138 031E     		subs	r3, r0, #0
 1658 013a 00D1     		bne	.LCB1357
 1659 013c 80E7     		b	.L166	@long jump
 1660              	.LCB1357:
1643:..\FreeRTOS\Source/queue.c ****             {
1644:..\FreeRTOS\Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1645:..\FreeRTOS\Source/queue.c ****                     {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 59


1646:..\FreeRTOS\Source/queue.c ****                         /* xInheritanceOccurred could only have be set if
1647:..\FreeRTOS\Source/queue.c ****                          * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1648:..\FreeRTOS\Source/queue.c ****                          * test the mutex type again to check it is actually a mutex. */
1649:..\FreeRTOS\Source/queue.c ****                         if( xInheritanceOccurred != pdFALSE )
1650:..\FreeRTOS\Source/queue.c ****                         {
1651:..\FreeRTOS\Source/queue.c ****                             taskENTER_CRITICAL();
1652:..\FreeRTOS\Source/queue.c ****                             {
1653:..\FreeRTOS\Source/queue.c ****                                 UBaseType_t uxHighestWaitingPriority;
1654:..\FreeRTOS\Source/queue.c **** 
1655:..\FreeRTOS\Source/queue.c ****                                 /* This task blocking on the mutex caused another
1656:..\FreeRTOS\Source/queue.c ****                                  * task to inherit this task's priority.  Now this task
1657:..\FreeRTOS\Source/queue.c ****                                  * has timed out the priority should be disinherited
1658:..\FreeRTOS\Source/queue.c ****                                  * again, but only as low as the next highest priority
1659:..\FreeRTOS\Source/queue.c ****                                  * task that is waiting for the same mutex. */
1660:..\FreeRTOS\Source/queue.c ****                                 uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( px
1661:..\FreeRTOS\Source/queue.c ****                                 vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHo
1662:..\FreeRTOS\Source/queue.c ****                             }
1663:..\FreeRTOS\Source/queue.c ****                             taskEXIT_CRITICAL();
1664:..\FreeRTOS\Source/queue.c ****                         }
1665:..\FreeRTOS\Source/queue.c ****                     }
1666:..\FreeRTOS\Source/queue.c ****                 #endif /* configUSE_MUTEXES */
1667:..\FreeRTOS\Source/queue.c **** 
1668:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1669:..\FreeRTOS\Source/queue.c ****                 return errQUEUE_EMPTY;
 1661              		.loc 1 1669 0
 1662 013e 0023     		movs	r3, #0
 1663              	.L178:
1670:..\FreeRTOS\Source/queue.c ****             }
1671:..\FreeRTOS\Source/queue.c ****             else
1672:..\FreeRTOS\Source/queue.c ****             {
1673:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1674:..\FreeRTOS\Source/queue.c ****             }
1675:..\FreeRTOS\Source/queue.c ****         }
1676:..\FreeRTOS\Source/queue.c ****     } /*lint -restore */
1677:..\FreeRTOS\Source/queue.c **** }
 1664              		.loc 1 1677 0 discriminator 6
 1665 0140 1800     		movs	r0, r3
 1666 0142 BD46     		mov	sp, r7
 1667 0144 08B0     		add	sp, sp, #32
 1668              		@ sp needed
 1669 0146 80BD     		pop	{r7, pc}
 1670              	.L180:
 1671              		.align	2
 1672              	.L179:
 1673 0148 00000000 		.word	x
 1674              		.cfi_endproc
 1675              	.LFE8:
 1676              		.size	xQueueSemaphoreTake, .-xQueueSemaphoreTake
 1677              		.section	.text.xQueuePeek,"ax",%progbits
 1678              		.align	2
 1679              		.global	xQueuePeek
 1680              		.code	16
 1681              		.thumb_func
 1682              		.type	xQueuePeek, %function
 1683              	xQueuePeek:
 1684              	.LFB9:
1678:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 60


1679:..\FreeRTOS\Source/queue.c **** 
1680:..\FreeRTOS\Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue,
1681:..\FreeRTOS\Source/queue.c ****                        void * const pvBuffer,
1682:..\FreeRTOS\Source/queue.c ****                        TickType_t xTicksToWait )
1683:..\FreeRTOS\Source/queue.c **** {
 1685              		.loc 1 1683 0
 1686              		.cfi_startproc
 1687              		@ args = 0, pretend = 0, frame = 40
 1688              		@ frame_needed = 1, uses_anonymous_args = 0
 1689 0000 80B5     		push	{r7, lr}
 1690              		.cfi_def_cfa_offset 8
 1691              		.cfi_offset 7, -8
 1692              		.cfi_offset 14, -4
 1693 0002 8AB0     		sub	sp, sp, #40
 1694              		.cfi_def_cfa_offset 48
 1695 0004 00AF     		add	r7, sp, #0
 1696              		.cfi_def_cfa_register 7
 1697 0006 F860     		str	r0, [r7, #12]
 1698 0008 B960     		str	r1, [r7, #8]
 1699 000a 7A60     		str	r2, [r7, #4]
1684:..\FreeRTOS\Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1700              		.loc 1 1684 0
 1701 000c 0023     		movs	r3, #0
 1702 000e 7B62     		str	r3, [r7, #36]
1685:..\FreeRTOS\Source/queue.c ****     TimeOut_t xTimeOut;
1686:..\FreeRTOS\Source/queue.c ****     int8_t * pcOriginalReadPosition;
1687:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1703              		.loc 1 1687 0
 1704 0010 FB68     		ldr	r3, [r7, #12]
 1705 0012 3B62     		str	r3, [r7, #32]
1688:..\FreeRTOS\Source/queue.c **** 
1689:..\FreeRTOS\Source/queue.c ****     /* Check the pointer is not NULL. */
1690:..\FreeRTOS\Source/queue.c ****     configASSERT( ( pxQueue ) );
 1706              		.loc 1 1690 0
 1707 0014 524B     		ldr	r3, .L207
 1708 0016 1B88     		ldrh	r3, [r3]
 1709 0018 002B     		cmp	r3, #0
 1710 001a 01D1     		bne	.L182
 1711              		.loc 1 1690 0 is_stmt 0 discriminator 1
 1712              		.syntax divided
 1713              	@ 1690 "..\FreeRTOS\Source\queue.c" 1
 1714 001c 72B6     		 cpsid i 
 1715              	@ 0 "" 2
 1716              		.thumb
 1717              		.syntax unified
 1718              	.L183:
 1719 001e FEE7     		b	.L183
 1720              	.L182:
1691:..\FreeRTOS\Source/queue.c **** 
1692:..\FreeRTOS\Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1693:..\FreeRTOS\Source/queue.c ****      * is zero (so no data is copied into the buffer. */
1694:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
 1721              		.loc 1 1694 0 is_stmt 1
 1722 0020 4F4B     		ldr	r3, .L207
 1723 0022 1B88     		ldrh	r3, [r3]
 1724 0024 002B     		cmp	r3, #0
 1725 0026 01D1     		bne	.L184
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 61


 1726              		.loc 1 1694 0 is_stmt 0 discriminator 1
 1727              		.syntax divided
 1728              	@ 1694 "..\FreeRTOS\Source\queue.c" 1
 1729 0028 72B6     		 cpsid i 
 1730              	@ 0 "" 2
 1731              		.thumb
 1732              		.syntax unified
 1733              	.L185:
 1734              		.loc 1 1694 0 discriminator 2
 1735 002a FEE7     		b	.L185
 1736              	.L184:
 1737 002c BB68     		ldr	r3, [r7, #8]
 1738 002e C046     		nop
1695:..\FreeRTOS\Source/queue.c **** 
1696:..\FreeRTOS\Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1697:..\FreeRTOS\Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1698:..\FreeRTOS\Source/queue.c ****         {
1699:..\FreeRTOS\Source/queue.c ****             configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToW
 1739              		.loc 1 1699 0 is_stmt 1 discriminator 2
 1740 0030 4B4B     		ldr	r3, .L207
 1741 0032 1B88     		ldrh	r3, [r3]
 1742 0034 002B     		cmp	r3, #0
 1743 0036 01D1     		bne	.L189
 1744              		.loc 1 1699 0 is_stmt 0 discriminator 1
 1745              		.syntax divided
 1746              	@ 1699 "..\FreeRTOS\Source\queue.c" 1
 1747 0038 72B6     		 cpsid i 
 1748              	@ 0 "" 2
 1749              		.thumb
 1750              		.syntax unified
 1751              	.L190:
 1752              		.loc 1 1699 0 discriminator 3
 1753 003a FEE7     		b	.L190
 1754              	.L189:
 1755              		.loc 1 1699 0 discriminator 2
 1756 003c FFF7FEFF 		bl	xTaskGetSchedulerState
 1757 0040 031E     		subs	r3, r0, #0
 1758 0042 00D1     		bne	.L193
 1759              		.loc 1 1699 0 discriminator 4
 1760 0044 7B68     		ldr	r3, [r7, #4]
 1761              	.L193:
1700:..\FreeRTOS\Source/queue.c ****         }
1701:..\FreeRTOS\Source/queue.c ****     #endif
1702:..\FreeRTOS\Source/queue.c **** 
1703:..\FreeRTOS\Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1704:..\FreeRTOS\Source/queue.c ****      * allow return statements within the function itself.  This is done in the
1705:..\FreeRTOS\Source/queue.c ****      * interest of execution time efficiency. */
1706:..\FreeRTOS\Source/queue.c ****     for( ; ; )
1707:..\FreeRTOS\Source/queue.c ****     {
1708:..\FreeRTOS\Source/queue.c ****         taskENTER_CRITICAL();
 1762              		.loc 1 1708 0 is_stmt 1
 1763 0046 FFF7FEFF 		bl	vPortEnterCritical
 1764              	.LBB8:
1709:..\FreeRTOS\Source/queue.c ****         {
1710:..\FreeRTOS\Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1765              		.loc 1 1710 0
 1766 004a 3B6A     		ldr	r3, [r7, #32]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 62


 1767 004c 9B6B     		ldr	r3, [r3, #56]
 1768 004e FB61     		str	r3, [r7, #28]
1711:..\FreeRTOS\Source/queue.c **** 
1712:..\FreeRTOS\Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1713:..\FreeRTOS\Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1714:..\FreeRTOS\Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1769              		.loc 1 1714 0
 1770 0050 FB69     		ldr	r3, [r7, #28]
 1771 0052 002B     		cmp	r3, #0
 1772 0054 1CD0     		beq	.L194
1715:..\FreeRTOS\Source/queue.c ****             {
1716:..\FreeRTOS\Source/queue.c ****                 /* Remember the read position so it can be reset after the data
1717:..\FreeRTOS\Source/queue.c ****                  * is read from the queue as this function is only peeking the
1718:..\FreeRTOS\Source/queue.c ****                  * data, not removing it. */
1719:..\FreeRTOS\Source/queue.c ****                 pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 1773              		.loc 1 1719 0
 1774 0056 3B6A     		ldr	r3, [r7, #32]
 1775 0058 DB68     		ldr	r3, [r3, #12]
 1776 005a BB61     		str	r3, [r7, #24]
1720:..\FreeRTOS\Source/queue.c **** 
1721:..\FreeRTOS\Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
 1777              		.loc 1 1721 0
 1778 005c BA68     		ldr	r2, [r7, #8]
 1779 005e 3B6A     		ldr	r3, [r7, #32]
 1780 0060 1100     		movs	r1, r2
 1781 0062 1800     		movs	r0, r3
 1782 0064 FFF7FEFF 		bl	prvCopyDataFromQueue
1722:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_PEEK( pxQueue );
1723:..\FreeRTOS\Source/queue.c **** 
1724:..\FreeRTOS\Source/queue.c ****                 /* The data is not being removed, so reset the read pointer. */
1725:..\FreeRTOS\Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 1783              		.loc 1 1725 0
 1784 0068 3B6A     		ldr	r3, [r7, #32]
 1785 006a BA69     		ldr	r2, [r7, #24]
 1786 006c DA60     		str	r2, [r3, #12]
1726:..\FreeRTOS\Source/queue.c **** 
1727:..\FreeRTOS\Source/queue.c ****                 /* The data is being left in the queue, so see if there are
1728:..\FreeRTOS\Source/queue.c ****                  * any other tasks waiting for the data. */
1729:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1787              		.loc 1 1729 0
 1788 006e 3B6A     		ldr	r3, [r7, #32]
 1789 0070 5B6A     		ldr	r3, [r3, #36]
 1790 0072 002B     		cmp	r3, #0
 1791 0074 08D0     		beq	.L195
1730:..\FreeRTOS\Source/queue.c ****                 {
1731:..\FreeRTOS\Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
 1792              		.loc 1 1731 0
 1793 0076 3B6A     		ldr	r3, [r7, #32]
 1794 0078 2433     		adds	r3, r3, #36
 1795 007a 1800     		movs	r0, r3
 1796 007c FFF7FEFF 		bl	xTaskRemoveFromEventList
 1797 0080 031E     		subs	r3, r0, #0
 1798 0082 01D0     		beq	.L195
1732:..\FreeRTOS\Source/queue.c ****                     {
1733:..\FreeRTOS\Source/queue.c ****                         /* The task waiting has a higher priority than this task. */
1734:..\FreeRTOS\Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 1799              		.loc 1 1734 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 63


 1800 0084 FFF7FEFF 		bl	vPortYield
 1801              	.L195:
1735:..\FreeRTOS\Source/queue.c ****                     }
1736:..\FreeRTOS\Source/queue.c ****                     else
1737:..\FreeRTOS\Source/queue.c ****                     {
1738:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1739:..\FreeRTOS\Source/queue.c ****                     }
1740:..\FreeRTOS\Source/queue.c ****                 }
1741:..\FreeRTOS\Source/queue.c ****                 else
1742:..\FreeRTOS\Source/queue.c ****                 {
1743:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1744:..\FreeRTOS\Source/queue.c ****                 }
1745:..\FreeRTOS\Source/queue.c **** 
1746:..\FreeRTOS\Source/queue.c ****                 taskEXIT_CRITICAL();
 1802              		.loc 1 1746 0
 1803 0088 FFF7FEFF 		bl	vPortExitCritical
1747:..\FreeRTOS\Source/queue.c ****                 return pdPASS;
 1804              		.loc 1 1747 0
 1805 008c 0123     		movs	r3, #1
 1806 008e 62E0     		b	.L205
 1807              	.L194:
1748:..\FreeRTOS\Source/queue.c ****             }
1749:..\FreeRTOS\Source/queue.c ****             else
1750:..\FreeRTOS\Source/queue.c ****             {
1751:..\FreeRTOS\Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 1808              		.loc 1 1751 0
 1809 0090 7B68     		ldr	r3, [r7, #4]
 1810 0092 002B     		cmp	r3, #0
 1811 0094 03D1     		bne	.L197
1752:..\FreeRTOS\Source/queue.c ****                 {
1753:..\FreeRTOS\Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1754:..\FreeRTOS\Source/queue.c ****                      * the block time has expired) so leave now. */
1755:..\FreeRTOS\Source/queue.c ****                     taskEXIT_CRITICAL();
 1812              		.loc 1 1755 0
 1813 0096 FFF7FEFF 		bl	vPortExitCritical
1756:..\FreeRTOS\Source/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
1757:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_EMPTY;
 1814              		.loc 1 1757 0
 1815 009a 0023     		movs	r3, #0
 1816 009c 5BE0     		b	.L205
 1817              	.L197:
1758:..\FreeRTOS\Source/queue.c ****                 }
1759:..\FreeRTOS\Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 1818              		.loc 1 1759 0
 1819 009e 7B6A     		ldr	r3, [r7, #36]
 1820 00a0 002B     		cmp	r3, #0
 1821 00a2 06D1     		bne	.L198
1760:..\FreeRTOS\Source/queue.c ****                 {
1761:..\FreeRTOS\Source/queue.c ****                     /* The queue was empty and a block time was specified so
1762:..\FreeRTOS\Source/queue.c ****                      * configure the timeout structure ready to enter the blocked
1763:..\FreeRTOS\Source/queue.c ****                      * state. */
1764:..\FreeRTOS\Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 1822              		.loc 1 1764 0
 1823 00a4 1023     		movs	r3, #16
 1824 00a6 FB18     		adds	r3, r7, r3
 1825 00a8 1800     		movs	r0, r3
 1826 00aa FFF7FEFF 		bl	vTaskInternalSetTimeOutState
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 64


1765:..\FreeRTOS\Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 1827              		.loc 1 1765 0
 1828 00ae 0123     		movs	r3, #1
 1829 00b0 7B62     		str	r3, [r7, #36]
 1830              	.L198:
 1831              	.LBE8:
1766:..\FreeRTOS\Source/queue.c ****                 }
1767:..\FreeRTOS\Source/queue.c ****                 else
1768:..\FreeRTOS\Source/queue.c ****                 {
1769:..\FreeRTOS\Source/queue.c ****                     /* Entry time was already set. */
1770:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1771:..\FreeRTOS\Source/queue.c ****                 }
1772:..\FreeRTOS\Source/queue.c ****             }
1773:..\FreeRTOS\Source/queue.c ****         }
1774:..\FreeRTOS\Source/queue.c ****         taskEXIT_CRITICAL();
 1832              		.loc 1 1774 0
 1833 00b2 FFF7FEFF 		bl	vPortExitCritical
1775:..\FreeRTOS\Source/queue.c **** 
1776:..\FreeRTOS\Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1777:..\FreeRTOS\Source/queue.c ****          * now the critical section has been exited. */
1778:..\FreeRTOS\Source/queue.c **** 
1779:..\FreeRTOS\Source/queue.c ****         vTaskSuspendAll();
 1834              		.loc 1 1779 0
 1835 00b6 FFF7FEFF 		bl	vTaskSuspendAll
1780:..\FreeRTOS\Source/queue.c ****         prvLockQueue( pxQueue );
 1836              		.loc 1 1780 0
 1837 00ba FFF7FEFF 		bl	vPortEnterCritical
 1838 00be 3B6A     		ldr	r3, [r7, #32]
 1839 00c0 4422     		movs	r2, #68
 1840 00c2 9B5C     		ldrb	r3, [r3, r2]
 1841 00c4 5BB2     		sxtb	r3, r3
 1842 00c6 0133     		adds	r3, r3, #1
 1843 00c8 03D1     		bne	.L199
 1844              		.loc 1 1780 0 is_stmt 0 discriminator 1
 1845 00ca 3B6A     		ldr	r3, [r7, #32]
 1846 00cc 4422     		movs	r2, #68
 1847 00ce 0021     		movs	r1, #0
 1848 00d0 9954     		strb	r1, [r3, r2]
 1849              	.L199:
 1850              		.loc 1 1780 0 discriminator 3
 1851 00d2 3B6A     		ldr	r3, [r7, #32]
 1852 00d4 4522     		movs	r2, #69
 1853 00d6 9B5C     		ldrb	r3, [r3, r2]
 1854 00d8 5BB2     		sxtb	r3, r3
 1855 00da 0133     		adds	r3, r3, #1
 1856 00dc 03D1     		bne	.L200
 1857              		.loc 1 1780 0 discriminator 4
 1858 00de 3B6A     		ldr	r3, [r7, #32]
 1859 00e0 4522     		movs	r2, #69
 1860 00e2 0021     		movs	r1, #0
 1861 00e4 9954     		strb	r1, [r3, r2]
 1862              	.L200:
 1863              		.loc 1 1780 0 discriminator 6
 1864 00e6 FFF7FEFF 		bl	vPortExitCritical
1781:..\FreeRTOS\Source/queue.c **** 
1782:..\FreeRTOS\Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1783:..\FreeRTOS\Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 65


 1865              		.loc 1 1783 0 is_stmt 1 discriminator 6
 1866 00ea 3A1D     		adds	r2, r7, #4
 1867 00ec 1023     		movs	r3, #16
 1868 00ee FB18     		adds	r3, r7, r3
 1869 00f0 1100     		movs	r1, r2
 1870 00f2 1800     		movs	r0, r3
 1871 00f4 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1872 00f8 031E     		subs	r3, r0, #0
 1873 00fa 1ED1     		bne	.L201
1784:..\FreeRTOS\Source/queue.c ****         {
1785:..\FreeRTOS\Source/queue.c ****             /* Timeout has not expired yet, check to see if there is data in the
1786:..\FreeRTOS\Source/queue.c ****             * queue now, and if not enter the Blocked state to wait for data. */
1787:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1874              		.loc 1 1787 0
 1875 00fc 3B6A     		ldr	r3, [r7, #32]
 1876 00fe 1800     		movs	r0, r3
 1877 0100 FFF7FEFF 		bl	prvIsQueueEmpty
 1878 0104 031E     		subs	r3, r0, #0
 1879 0106 11D0     		beq	.L202
1788:..\FreeRTOS\Source/queue.c ****             {
1789:..\FreeRTOS\Source/queue.c ****                 traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1790:..\FreeRTOS\Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1880              		.loc 1 1790 0
 1881 0108 3B6A     		ldr	r3, [r7, #32]
 1882 010a 2433     		adds	r3, r3, #36
 1883 010c 7A68     		ldr	r2, [r7, #4]
 1884 010e 1100     		movs	r1, r2
 1885 0110 1800     		movs	r0, r3
 1886 0112 FFF7FEFF 		bl	vTaskPlaceOnEventList
1791:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1887              		.loc 1 1791 0
 1888 0116 3B6A     		ldr	r3, [r7, #32]
 1889 0118 1800     		movs	r0, r3
 1890 011a FFF7FEFF 		bl	prvUnlockQueue
1792:..\FreeRTOS\Source/queue.c **** 
1793:..\FreeRTOS\Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 1891              		.loc 1 1793 0
 1892 011e FFF7FEFF 		bl	xTaskResumeAll
 1893 0122 031E     		subs	r3, r0, #0
 1894 0124 8FD1     		bne	.L193
1794:..\FreeRTOS\Source/queue.c ****                 {
1795:..\FreeRTOS\Source/queue.c ****                     portYIELD_WITHIN_API();
 1895              		.loc 1 1795 0
 1896 0126 FFF7FEFF 		bl	vPortYield
 1897 012a 8CE7     		b	.L193
 1898              	.L202:
1796:..\FreeRTOS\Source/queue.c ****                 }
1797:..\FreeRTOS\Source/queue.c ****                 else
1798:..\FreeRTOS\Source/queue.c ****                 {
1799:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1800:..\FreeRTOS\Source/queue.c ****                 }
1801:..\FreeRTOS\Source/queue.c ****             }
1802:..\FreeRTOS\Source/queue.c ****             else
1803:..\FreeRTOS\Source/queue.c ****             {
1804:..\FreeRTOS\Source/queue.c ****                 /* There is data in the queue now, so don't enter the blocked
1805:..\FreeRTOS\Source/queue.c ****                  * state, instead return to try and obtain the data. */
1806:..\FreeRTOS\Source/queue.c ****                 prvUnlockQueue( pxQueue );
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 66


 1899              		.loc 1 1806 0
 1900 012c 3B6A     		ldr	r3, [r7, #32]
 1901 012e 1800     		movs	r0, r3
 1902 0130 FFF7FEFF 		bl	prvUnlockQueue
1807:..\FreeRTOS\Source/queue.c ****                 ( void ) xTaskResumeAll();
 1903              		.loc 1 1807 0
 1904 0134 FFF7FEFF 		bl	xTaskResumeAll
 1905 0138 85E7     		b	.L193
 1906              	.L201:
1808:..\FreeRTOS\Source/queue.c ****             }
1809:..\FreeRTOS\Source/queue.c ****         }
1810:..\FreeRTOS\Source/queue.c ****         else
1811:..\FreeRTOS\Source/queue.c ****         {
1812:..\FreeRTOS\Source/queue.c ****             /* The timeout has expired.  If there is still no data in the queue
1813:..\FreeRTOS\Source/queue.c ****              * exit, otherwise go back and try to read the data again. */
1814:..\FreeRTOS\Source/queue.c ****             prvUnlockQueue( pxQueue );
 1907              		.loc 1 1814 0
 1908 013a 3B6A     		ldr	r3, [r7, #32]
 1909 013c 1800     		movs	r0, r3
 1910 013e FFF7FEFF 		bl	prvUnlockQueue
1815:..\FreeRTOS\Source/queue.c ****             ( void ) xTaskResumeAll();
 1911              		.loc 1 1815 0
 1912 0142 FFF7FEFF 		bl	xTaskResumeAll
1816:..\FreeRTOS\Source/queue.c **** 
1817:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1913              		.loc 1 1817 0
 1914 0146 3B6A     		ldr	r3, [r7, #32]
 1915 0148 1800     		movs	r0, r3
 1916 014a FFF7FEFF 		bl	prvIsQueueEmpty
 1917 014e 031E     		subs	r3, r0, #0
 1918 0150 00D1     		bne	.LCB1577
 1919 0152 78E7     		b	.L193	@long jump
 1920              	.LCB1577:
1818:..\FreeRTOS\Source/queue.c ****             {
1819:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_PEEK_FAILED( pxQueue );
1820:..\FreeRTOS\Source/queue.c ****                 return errQUEUE_EMPTY;
 1921              		.loc 1 1820 0
 1922 0154 0023     		movs	r3, #0
 1923              	.L205:
1821:..\FreeRTOS\Source/queue.c ****             }
1822:..\FreeRTOS\Source/queue.c ****             else
1823:..\FreeRTOS\Source/queue.c ****             {
1824:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1825:..\FreeRTOS\Source/queue.c ****             }
1826:..\FreeRTOS\Source/queue.c ****         }
1827:..\FreeRTOS\Source/queue.c ****     } /*lint -restore */
1828:..\FreeRTOS\Source/queue.c **** }
 1924              		.loc 1 1828 0 discriminator 6
 1925 0156 1800     		movs	r0, r3
 1926 0158 BD46     		mov	sp, r7
 1927 015a 0AB0     		add	sp, sp, #40
 1928              		@ sp needed
 1929 015c 80BD     		pop	{r7, pc}
 1930              	.L208:
 1931 015e C046     		.align	2
 1932              	.L207:
 1933 0160 00000000 		.word	x
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 67


 1934              		.cfi_endproc
 1935              	.LFE9:
 1936              		.size	xQueuePeek, .-xQueuePeek
 1937              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1938              		.align	2
 1939              		.global	xQueueReceiveFromISR
 1940              		.code	16
 1941              		.thumb_func
 1942              		.type	xQueueReceiveFromISR, %function
 1943              	xQueueReceiveFromISR:
 1944              	.LFB10:
1829:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
1830:..\FreeRTOS\Source/queue.c **** 
1831:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
1832:..\FreeRTOS\Source/queue.c ****                                  void * const pvBuffer,
1833:..\FreeRTOS\Source/queue.c ****                                  BaseType_t * const pxHigherPriorityTaskWoken )
1834:..\FreeRTOS\Source/queue.c **** {
 1945              		.loc 1 1834 0
 1946              		.cfi_startproc
 1947              		@ args = 0, pretend = 0, frame = 40
 1948              		@ frame_needed = 1, uses_anonymous_args = 0
 1949 0000 80B5     		push	{r7, lr}
 1950              		.cfi_def_cfa_offset 8
 1951              		.cfi_offset 7, -8
 1952              		.cfi_offset 14, -4
 1953 0002 8AB0     		sub	sp, sp, #40
 1954              		.cfi_def_cfa_offset 48
 1955 0004 00AF     		add	r7, sp, #0
 1956              		.cfi_def_cfa_register 7
 1957 0006 F860     		str	r0, [r7, #12]
 1958 0008 B960     		str	r1, [r7, #8]
 1959 000a 7A60     		str	r2, [r7, #4]
1835:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
1836:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1837:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1960              		.loc 1 1837 0
 1961 000c FB68     		ldr	r3, [r7, #12]
 1962 000e 3B62     		str	r3, [r7, #32]
1838:..\FreeRTOS\Source/queue.c **** 
1839:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 1963              		.loc 1 1839 0
 1964 0010 2E4B     		ldr	r3, .L225
 1965 0012 1B88     		ldrh	r3, [r3]
 1966 0014 002B     		cmp	r3, #0
 1967 0016 01D1     		bne	.L210
 1968              		.loc 1 1839 0 is_stmt 0 discriminator 1
 1969              		.syntax divided
 1970              	@ 1839 "..\FreeRTOS\Source\queue.c" 1
 1971 0018 72B6     		 cpsid i 
 1972              	@ 0 "" 2
 1973              		.thumb
 1974              		.syntax unified
 1975              	.L211:
 1976 001a FEE7     		b	.L211
 1977              	.L210:
1840:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 1978              		.loc 1 1840 0 is_stmt 1
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 68


 1979 001c 2B4B     		ldr	r3, .L225
 1980 001e 1B88     		ldrh	r3, [r3]
 1981 0020 002B     		cmp	r3, #0
 1982 0022 01D1     		bne	.L212
 1983              		.loc 1 1840 0 is_stmt 0 discriminator 1
 1984              		.syntax divided
 1985              	@ 1840 "..\FreeRTOS\Source\queue.c" 1
 1986 0024 72B6     		 cpsid i 
 1987              	@ 0 "" 2
 1988              		.thumb
 1989              		.syntax unified
 1990              	.L213:
 1991              		.loc 1 1840 0 discriminator 2
 1992 0026 FEE7     		b	.L213
 1993              	.L212:
 1994 0028 BB68     		ldr	r3, [r7, #8]
 1995 002a C046     		nop
1841:..\FreeRTOS\Source/queue.c **** 
1842:..\FreeRTOS\Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1843:..\FreeRTOS\Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1844:..\FreeRTOS\Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1845:..\FreeRTOS\Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1846:..\FreeRTOS\Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1847:..\FreeRTOS\Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1848:..\FreeRTOS\Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1849:..\FreeRTOS\Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1850:..\FreeRTOS\Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1851:..\FreeRTOS\Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1852:..\FreeRTOS\Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1853:..\FreeRTOS\Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1854:..\FreeRTOS\Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1855:..\FreeRTOS\Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1856:..\FreeRTOS\Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1857:..\FreeRTOS\Source/queue.c **** 
1858:..\FreeRTOS\Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1996              		.loc 1 1858 0 is_stmt 1 discriminator 2
 1997 002c FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 1998 0030 0300     		movs	r3, r0
 1999 0032 FB61     		str	r3, [r7, #28]
 2000              	.LBB9:
1859:..\FreeRTOS\Source/queue.c ****     {
1860:..\FreeRTOS\Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2001              		.loc 1 1860 0 discriminator 2
 2002 0034 3B6A     		ldr	r3, [r7, #32]
 2003 0036 9B6B     		ldr	r3, [r3, #56]
 2004 0038 BB61     		str	r3, [r7, #24]
1861:..\FreeRTOS\Source/queue.c **** 
1862:..\FreeRTOS\Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1863:..\FreeRTOS\Source/queue.c ****         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2005              		.loc 1 1863 0 discriminator 2
 2006 003a BB69     		ldr	r3, [r7, #24]
 2007 003c 002B     		cmp	r3, #0
 2008 003e 39D0     		beq	.L217
 2009              	.LBB10:
1864:..\FreeRTOS\Source/queue.c ****         {
1865:..\FreeRTOS\Source/queue.c ****             const int8_t cRxLock = pxQueue->cRxLock;
 2010              		.loc 1 1865 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 69


 2011 0040 1723     		movs	r3, #23
 2012 0042 FB18     		adds	r3, r7, r3
 2013 0044 3A6A     		ldr	r2, [r7, #32]
 2014 0046 4421     		movs	r1, #68
 2015 0048 525C     		ldrb	r2, [r2, r1]
 2016 004a 1A70     		strb	r2, [r3]
1866:..\FreeRTOS\Source/queue.c **** 
1867:..\FreeRTOS\Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1868:..\FreeRTOS\Source/queue.c **** 
1869:..\FreeRTOS\Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 2017              		.loc 1 1869 0
 2018 004c BA68     		ldr	r2, [r7, #8]
 2019 004e 3B6A     		ldr	r3, [r7, #32]
 2020 0050 1100     		movs	r1, r2
 2021 0052 1800     		movs	r0, r3
 2022 0054 FFF7FEFF 		bl	prvCopyDataFromQueue
1870:..\FreeRTOS\Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2023              		.loc 1 1870 0
 2024 0058 BB69     		ldr	r3, [r7, #24]
 2025 005a 5A1E     		subs	r2, r3, #1
 2026 005c 3B6A     		ldr	r3, [r7, #32]
 2027 005e 9A63     		str	r2, [r3, #56]
1871:..\FreeRTOS\Source/queue.c **** 
1872:..\FreeRTOS\Source/queue.c ****             /* If the queue is locked the event list will not be modified.
1873:..\FreeRTOS\Source/queue.c ****              * Instead update the lock count so the task that unlocks the queue
1874:..\FreeRTOS\Source/queue.c ****              * will know that an ISR has removed data while the queue was
1875:..\FreeRTOS\Source/queue.c ****              * locked. */
1876:..\FreeRTOS\Source/queue.c ****             if( cRxLock == queueUNLOCKED )
 2028              		.loc 1 1876 0
 2029 0060 1723     		movs	r3, #23
 2030 0062 FB18     		adds	r3, r7, r3
 2031 0064 1B78     		ldrb	r3, [r3]
 2032 0066 5BB2     		sxtb	r3, r3
 2033 0068 0133     		adds	r3, r3, #1
 2034 006a 11D1     		bne	.L218
1877:..\FreeRTOS\Source/queue.c ****             {
1878:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2035              		.loc 1 1878 0
 2036 006c 3B6A     		ldr	r3, [r7, #32]
 2037 006e 1B69     		ldr	r3, [r3, #16]
 2038 0070 002B     		cmp	r3, #0
 2039 0072 1CD0     		beq	.L219
1879:..\FreeRTOS\Source/queue.c ****                 {
1880:..\FreeRTOS\Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2040              		.loc 1 1880 0
 2041 0074 3B6A     		ldr	r3, [r7, #32]
 2042 0076 1033     		adds	r3, r3, #16
 2043 0078 1800     		movs	r0, r3
 2044 007a FFF7FEFF 		bl	xTaskRemoveFromEventList
 2045 007e 031E     		subs	r3, r0, #0
 2046 0080 15D0     		beq	.L219
1881:..\FreeRTOS\Source/queue.c ****                     {
1882:..\FreeRTOS\Source/queue.c ****                         /* The task waiting has a higher priority than us so
1883:..\FreeRTOS\Source/queue.c ****                          * force a context switch. */
1884:..\FreeRTOS\Source/queue.c ****                         if( pxHigherPriorityTaskWoken != NULL )
 2047              		.loc 1 1884 0
 2048 0082 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 70


 2049 0084 002B     		cmp	r3, #0
 2050 0086 12D0     		beq	.L219
1885:..\FreeRTOS\Source/queue.c ****                         {
1886:..\FreeRTOS\Source/queue.c ****                             *pxHigherPriorityTaskWoken = pdTRUE;
 2051              		.loc 1 1886 0
 2052 0088 7B68     		ldr	r3, [r7, #4]
 2053 008a 0122     		movs	r2, #1
 2054 008c 1A60     		str	r2, [r3]
 2055 008e 0EE0     		b	.L219
 2056              	.L218:
1887:..\FreeRTOS\Source/queue.c ****                         }
1888:..\FreeRTOS\Source/queue.c ****                         else
1889:..\FreeRTOS\Source/queue.c ****                         {
1890:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1891:..\FreeRTOS\Source/queue.c ****                         }
1892:..\FreeRTOS\Source/queue.c ****                     }
1893:..\FreeRTOS\Source/queue.c ****                     else
1894:..\FreeRTOS\Source/queue.c ****                     {
1895:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1896:..\FreeRTOS\Source/queue.c ****                     }
1897:..\FreeRTOS\Source/queue.c ****                 }
1898:..\FreeRTOS\Source/queue.c ****                 else
1899:..\FreeRTOS\Source/queue.c ****                 {
1900:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1901:..\FreeRTOS\Source/queue.c ****                 }
1902:..\FreeRTOS\Source/queue.c ****             }
1903:..\FreeRTOS\Source/queue.c ****             else
1904:..\FreeRTOS\Source/queue.c ****             {
1905:..\FreeRTOS\Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1906:..\FreeRTOS\Source/queue.c ****                  * knows that data was removed while it was locked. */
1907:..\FreeRTOS\Source/queue.c ****                 configASSERT( cRxLock != queueINT8_MAX );
 2057              		.loc 1 1907 0
 2058 0090 0E4B     		ldr	r3, .L225
 2059 0092 1B88     		ldrh	r3, [r3]
 2060 0094 002B     		cmp	r3, #0
 2061 0096 01D1     		bne	.L220
 2062              		.loc 1 1907 0 is_stmt 0 discriminator 1
 2063              		.syntax divided
 2064              	@ 1907 "..\FreeRTOS\Source\queue.c" 1
 2065 0098 72B6     		 cpsid i 
 2066              	@ 0 "" 2
 2067              		.thumb
 2068              		.syntax unified
 2069              	.L221:
 2070              		.loc 1 1907 0 discriminator 5
 2071 009a FEE7     		b	.L221
 2072              	.L220:
1908:..\FreeRTOS\Source/queue.c **** 
1909:..\FreeRTOS\Source/queue.c ****                 pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 2073              		.loc 1 1909 0 is_stmt 1
 2074 009c 1723     		movs	r3, #23
 2075 009e FB18     		adds	r3, r7, r3
 2076 00a0 1B78     		ldrb	r3, [r3]
 2077 00a2 0133     		adds	r3, r3, #1
 2078 00a4 DBB2     		uxtb	r3, r3
 2079 00a6 59B2     		sxtb	r1, r3
 2080 00a8 3B6A     		ldr	r3, [r7, #32]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 71


 2081 00aa 4422     		movs	r2, #68
 2082 00ac 9954     		strb	r1, [r3, r2]
 2083              	.L219:
1910:..\FreeRTOS\Source/queue.c ****             }
1911:..\FreeRTOS\Source/queue.c **** 
1912:..\FreeRTOS\Source/queue.c ****             xReturn = pdPASS;
 2084              		.loc 1 1912 0
 2085 00ae 0123     		movs	r3, #1
 2086 00b0 7B62     		str	r3, [r7, #36]
 2087              	.LBE10:
 2088 00b2 01E0     		b	.L222
 2089              	.L217:
1913:..\FreeRTOS\Source/queue.c ****         }
1914:..\FreeRTOS\Source/queue.c ****         else
1915:..\FreeRTOS\Source/queue.c ****         {
1916:..\FreeRTOS\Source/queue.c ****             xReturn = pdFAIL;
 2090              		.loc 1 1916 0
 2091 00b4 0023     		movs	r3, #0
 2092 00b6 7B62     		str	r3, [r7, #36]
 2093              	.L222:
 2094              	.LBE9:
1917:..\FreeRTOS\Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1918:..\FreeRTOS\Source/queue.c ****         }
1919:..\FreeRTOS\Source/queue.c ****     }
1920:..\FreeRTOS\Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 2095              		.loc 1 1920 0
 2096 00b8 FB69     		ldr	r3, [r7, #28]
 2097 00ba 1800     		movs	r0, r3
 2098 00bc FFF7FEFF 		bl	vClearInterruptMaskFromISR
1921:..\FreeRTOS\Source/queue.c **** 
1922:..\FreeRTOS\Source/queue.c ****     return xReturn;
 2099              		.loc 1 1922 0
 2100 00c0 7B6A     		ldr	r3, [r7, #36]
1923:..\FreeRTOS\Source/queue.c **** }
 2101              		.loc 1 1923 0
 2102 00c2 1800     		movs	r0, r3
 2103 00c4 BD46     		mov	sp, r7
 2104 00c6 0AB0     		add	sp, sp, #40
 2105              		@ sp needed
 2106 00c8 80BD     		pop	{r7, pc}
 2107              	.L226:
 2108 00ca C046     		.align	2
 2109              	.L225:
 2110 00cc 00000000 		.word	x
 2111              		.cfi_endproc
 2112              	.LFE10:
 2113              		.size	xQueueReceiveFromISR, .-xQueueReceiveFromISR
 2114              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 2115              		.align	2
 2116              		.global	xQueuePeekFromISR
 2117              		.code	16
 2118              		.thumb_func
 2119              		.type	xQueuePeekFromISR, %function
 2120              	xQueuePeekFromISR:
 2121              	.LFB11:
1924:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
1925:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 72


1926:..\FreeRTOS\Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
1927:..\FreeRTOS\Source/queue.c ****                               void * const pvBuffer )
1928:..\FreeRTOS\Source/queue.c **** {
 2122              		.loc 1 1928 0
 2123              		.cfi_startproc
 2124              		@ args = 0, pretend = 0, frame = 24
 2125              		@ frame_needed = 1, uses_anonymous_args = 0
 2126 0000 80B5     		push	{r7, lr}
 2127              		.cfi_def_cfa_offset 8
 2128              		.cfi_offset 7, -8
 2129              		.cfi_offset 14, -4
 2130 0002 86B0     		sub	sp, sp, #24
 2131              		.cfi_def_cfa_offset 32
 2132 0004 00AF     		add	r7, sp, #0
 2133              		.cfi_def_cfa_register 7
 2134 0006 7860     		str	r0, [r7, #4]
 2135 0008 3960     		str	r1, [r7]
1929:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
1930:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1931:..\FreeRTOS\Source/queue.c ****     int8_t * pcOriginalReadPosition;
1932:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2136              		.loc 1 1932 0
 2137 000a 7B68     		ldr	r3, [r7, #4]
 2138 000c 3B61     		str	r3, [r7, #16]
1933:..\FreeRTOS\Source/queue.c **** 
1934:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 2139              		.loc 1 1934 0
 2140 000e 1B4B     		ldr	r3, .L241
 2141 0010 1B88     		ldrh	r3, [r3]
 2142 0012 002B     		cmp	r3, #0
 2143 0014 01D1     		bne	.L228
 2144              		.loc 1 1934 0 is_stmt 0 discriminator 1
 2145              		.syntax divided
 2146              	@ 1934 "..\FreeRTOS\Source\queue.c" 1
 2147 0016 72B6     		 cpsid i 
 2148              	@ 0 "" 2
 2149              		.thumb
 2150              		.syntax unified
 2151              	.L229:
 2152 0018 FEE7     		b	.L229
 2153              	.L228:
1935:..\FreeRTOS\Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2154              		.loc 1 1935 0 is_stmt 1
 2155 001a 184B     		ldr	r3, .L241
 2156 001c 1B88     		ldrh	r3, [r3]
 2157 001e 002B     		cmp	r3, #0
 2158 0020 01D1     		bne	.L230
 2159              		.loc 1 1935 0 is_stmt 0 discriminator 1
 2160              		.syntax divided
 2161              	@ 1935 "..\FreeRTOS\Source\queue.c" 1
 2162 0022 72B6     		 cpsid i 
 2163              	@ 0 "" 2
 2164              		.thumb
 2165              		.syntax unified
 2166              	.L231:
 2167              		.loc 1 1935 0 discriminator 2
 2168 0024 FEE7     		b	.L231
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 73


 2169              	.L230:
 2170 0026 3B68     		ldr	r3, [r7]
 2171 0028 C046     		nop
1936:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 2172              		.loc 1 1936 0 is_stmt 1 discriminator 2
 2173 002a 144B     		ldr	r3, .L241
 2174 002c 1B88     		ldrh	r3, [r3]
 2175 002e 002B     		cmp	r3, #0
 2176 0030 01D1     		bne	.L235
 2177              		.loc 1 1936 0 is_stmt 0 discriminator 1
 2178              		.syntax divided
 2179              	@ 1936 "..\FreeRTOS\Source\queue.c" 1
 2180 0032 72B6     		 cpsid i 
 2181              	@ 0 "" 2
 2182              		.thumb
 2183              		.syntax unified
 2184              	.L236:
 2185              		.loc 1 1936 0 discriminator 3
 2186 0034 FEE7     		b	.L236
 2187              	.L235:
1937:..\FreeRTOS\Source/queue.c **** 
1938:..\FreeRTOS\Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1939:..\FreeRTOS\Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1940:..\FreeRTOS\Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1941:..\FreeRTOS\Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1942:..\FreeRTOS\Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1943:..\FreeRTOS\Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1944:..\FreeRTOS\Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1945:..\FreeRTOS\Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1946:..\FreeRTOS\Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1947:..\FreeRTOS\Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1948:..\FreeRTOS\Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1949:..\FreeRTOS\Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1950:..\FreeRTOS\Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1951:..\FreeRTOS\Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1952:..\FreeRTOS\Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1953:..\FreeRTOS\Source/queue.c **** 
1954:..\FreeRTOS\Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2188              		.loc 1 1954 0 is_stmt 1 discriminator 2
 2189 0036 FFF7FEFF 		bl	ulSetInterruptMaskFromISR
 2190 003a 0300     		movs	r3, r0
 2191 003c FB60     		str	r3, [r7, #12]
1955:..\FreeRTOS\Source/queue.c ****     {
1956:..\FreeRTOS\Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1957:..\FreeRTOS\Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2192              		.loc 1 1957 0 discriminator 2
 2193 003e 3B69     		ldr	r3, [r7, #16]
 2194 0040 9B6B     		ldr	r3, [r3, #56]
 2195 0042 002B     		cmp	r3, #0
 2196 0044 0ED0     		beq	.L237
1958:..\FreeRTOS\Source/queue.c ****         {
1959:..\FreeRTOS\Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR( pxQueue );
1960:..\FreeRTOS\Source/queue.c **** 
1961:..\FreeRTOS\Source/queue.c ****             /* Remember the read position so it can be reset as nothing is
1962:..\FreeRTOS\Source/queue.c ****              * actually being removed from the queue. */
1963:..\FreeRTOS\Source/queue.c ****             pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 2197              		.loc 1 1963 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 74


 2198 0046 3B69     		ldr	r3, [r7, #16]
 2199 0048 DB68     		ldr	r3, [r3, #12]
 2200 004a BB60     		str	r3, [r7, #8]
1964:..\FreeRTOS\Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 2201              		.loc 1 1964 0
 2202 004c 3A68     		ldr	r2, [r7]
 2203 004e 3B69     		ldr	r3, [r7, #16]
 2204 0050 1100     		movs	r1, r2
 2205 0052 1800     		movs	r0, r3
 2206 0054 FFF7FEFF 		bl	prvCopyDataFromQueue
1965:..\FreeRTOS\Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2207              		.loc 1 1965 0
 2208 0058 3B69     		ldr	r3, [r7, #16]
 2209 005a BA68     		ldr	r2, [r7, #8]
 2210 005c DA60     		str	r2, [r3, #12]
1966:..\FreeRTOS\Source/queue.c **** 
1967:..\FreeRTOS\Source/queue.c ****             xReturn = pdPASS;
 2211              		.loc 1 1967 0
 2212 005e 0123     		movs	r3, #1
 2213 0060 7B61     		str	r3, [r7, #20]
 2214 0062 01E0     		b	.L238
 2215              	.L237:
1968:..\FreeRTOS\Source/queue.c ****         }
1969:..\FreeRTOS\Source/queue.c ****         else
1970:..\FreeRTOS\Source/queue.c ****         {
1971:..\FreeRTOS\Source/queue.c ****             xReturn = pdFAIL;
 2216              		.loc 1 1971 0
 2217 0064 0023     		movs	r3, #0
 2218 0066 7B61     		str	r3, [r7, #20]
 2219              	.L238:
1972:..\FreeRTOS\Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1973:..\FreeRTOS\Source/queue.c ****         }
1974:..\FreeRTOS\Source/queue.c ****     }
1975:..\FreeRTOS\Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 2220              		.loc 1 1975 0
 2221 0068 FB68     		ldr	r3, [r7, #12]
 2222 006a 1800     		movs	r0, r3
 2223 006c FFF7FEFF 		bl	vClearInterruptMaskFromISR
1976:..\FreeRTOS\Source/queue.c **** 
1977:..\FreeRTOS\Source/queue.c ****     return xReturn;
 2224              		.loc 1 1977 0
 2225 0070 7B69     		ldr	r3, [r7, #20]
1978:..\FreeRTOS\Source/queue.c **** }
 2226              		.loc 1 1978 0
 2227 0072 1800     		movs	r0, r3
 2228 0074 BD46     		mov	sp, r7
 2229 0076 06B0     		add	sp, sp, #24
 2230              		@ sp needed
 2231 0078 80BD     		pop	{r7, pc}
 2232              	.L242:
 2233 007a C046     		.align	2
 2234              	.L241:
 2235 007c 00000000 		.word	x
 2236              		.cfi_endproc
 2237              	.LFE11:
 2238              		.size	xQueuePeekFromISR, .-xQueuePeekFromISR
 2239              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 75


 2240              		.align	2
 2241              		.global	uxQueueMessagesWaiting
 2242              		.code	16
 2243              		.thumb_func
 2244              		.type	uxQueueMessagesWaiting, %function
 2245              	uxQueueMessagesWaiting:
 2246              	.LFB12:
1979:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
1980:..\FreeRTOS\Source/queue.c **** 
1981:..\FreeRTOS\Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1982:..\FreeRTOS\Source/queue.c **** {
 2247              		.loc 1 1982 0
 2248              		.cfi_startproc
 2249              		@ args = 0, pretend = 0, frame = 16
 2250              		@ frame_needed = 1, uses_anonymous_args = 0
 2251 0000 80B5     		push	{r7, lr}
 2252              		.cfi_def_cfa_offset 8
 2253              		.cfi_offset 7, -8
 2254              		.cfi_offset 14, -4
 2255 0002 84B0     		sub	sp, sp, #16
 2256              		.cfi_def_cfa_offset 24
 2257 0004 00AF     		add	r7, sp, #0
 2258              		.cfi_def_cfa_register 7
 2259 0006 7860     		str	r0, [r7, #4]
1983:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxReturn;
1984:..\FreeRTOS\Source/queue.c **** 
1985:..\FreeRTOS\Source/queue.c ****     configASSERT( xQueue );
 2260              		.loc 1 1985 0
 2261 0008 084B     		ldr	r3, .L247
 2262 000a 1B88     		ldrh	r3, [r3]
 2263 000c 002B     		cmp	r3, #0
 2264 000e 01D1     		bne	.L244
 2265              		.loc 1 1985 0 is_stmt 0 discriminator 1
 2266              		.syntax divided
 2267              	@ 1985 "..\FreeRTOS\Source\queue.c" 1
 2268 0010 72B6     		 cpsid i 
 2269              	@ 0 "" 2
 2270              		.thumb
 2271              		.syntax unified
 2272              	.L245:
 2273 0012 FEE7     		b	.L245
 2274              	.L244:
1986:..\FreeRTOS\Source/queue.c **** 
1987:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();
 2275              		.loc 1 1987 0 is_stmt 1
 2276 0014 FFF7FEFF 		bl	vPortEnterCritical
1988:..\FreeRTOS\Source/queue.c ****     {
1989:..\FreeRTOS\Source/queue.c ****         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 2277              		.loc 1 1989 0
 2278 0018 7B68     		ldr	r3, [r7, #4]
 2279 001a 9B6B     		ldr	r3, [r3, #56]
 2280 001c FB60     		str	r3, [r7, #12]
1990:..\FreeRTOS\Source/queue.c ****     }
1991:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL();
 2281              		.loc 1 1991 0
 2282 001e FFF7FEFF 		bl	vPortExitCritical
1992:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 76


1993:..\FreeRTOS\Source/queue.c ****     return uxReturn;
 2283              		.loc 1 1993 0
 2284 0022 FB68     		ldr	r3, [r7, #12]
1994:..\FreeRTOS\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2285              		.loc 1 1994 0
 2286 0024 1800     		movs	r0, r3
 2287 0026 BD46     		mov	sp, r7
 2288 0028 04B0     		add	sp, sp, #16
 2289              		@ sp needed
 2290 002a 80BD     		pop	{r7, pc}
 2291              	.L248:
 2292              		.align	2
 2293              	.L247:
 2294 002c 00000000 		.word	x
 2295              		.cfi_endproc
 2296              	.LFE12:
 2297              		.size	uxQueueMessagesWaiting, .-uxQueueMessagesWaiting
 2298              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 2299              		.align	2
 2300              		.global	uxQueueSpacesAvailable
 2301              		.code	16
 2302              		.thumb_func
 2303              		.type	uxQueueSpacesAvailable, %function
 2304              	uxQueueSpacesAvailable:
 2305              	.LFB13:
1995:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
1996:..\FreeRTOS\Source/queue.c **** 
1997:..\FreeRTOS\Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1998:..\FreeRTOS\Source/queue.c **** {
 2306              		.loc 1 1998 0
 2307              		.cfi_startproc
 2308              		@ args = 0, pretend = 0, frame = 16
 2309              		@ frame_needed = 1, uses_anonymous_args = 0
 2310 0000 80B5     		push	{r7, lr}
 2311              		.cfi_def_cfa_offset 8
 2312              		.cfi_offset 7, -8
 2313              		.cfi_offset 14, -4
 2314 0002 84B0     		sub	sp, sp, #16
 2315              		.cfi_def_cfa_offset 24
 2316 0004 00AF     		add	r7, sp, #0
 2317              		.cfi_def_cfa_register 7
 2318 0006 7860     		str	r0, [r7, #4]
1999:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxReturn;
2000:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2319              		.loc 1 2000 0
 2320 0008 7B68     		ldr	r3, [r7, #4]
 2321 000a FB60     		str	r3, [r7, #12]
2001:..\FreeRTOS\Source/queue.c **** 
2002:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 2322              		.loc 1 2002 0
 2323 000c 0A4B     		ldr	r3, .L253
 2324 000e 1B88     		ldrh	r3, [r3]
 2325 0010 002B     		cmp	r3, #0
 2326 0012 01D1     		bne	.L250
 2327              		.loc 1 2002 0 is_stmt 0 discriminator 1
 2328              		.syntax divided
 2329              	@ 2002 "..\FreeRTOS\Source\queue.c" 1
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 77


 2330 0014 72B6     		 cpsid i 
 2331              	@ 0 "" 2
 2332              		.thumb
 2333              		.syntax unified
 2334              	.L251:
 2335 0016 FEE7     		b	.L251
 2336              	.L250:
2003:..\FreeRTOS\Source/queue.c **** 
2004:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();
 2337              		.loc 1 2004 0 is_stmt 1
 2338 0018 FFF7FEFF 		bl	vPortEnterCritical
2005:..\FreeRTOS\Source/queue.c ****     {
2006:..\FreeRTOS\Source/queue.c ****         uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 2339              		.loc 1 2006 0
 2340 001c FB68     		ldr	r3, [r7, #12]
 2341 001e DA6B     		ldr	r2, [r3, #60]
 2342 0020 FB68     		ldr	r3, [r7, #12]
 2343 0022 9B6B     		ldr	r3, [r3, #56]
 2344 0024 D31A     		subs	r3, r2, r3
 2345 0026 BB60     		str	r3, [r7, #8]
2007:..\FreeRTOS\Source/queue.c ****     }
2008:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL();
 2346              		.loc 1 2008 0
 2347 0028 FFF7FEFF 		bl	vPortExitCritical
2009:..\FreeRTOS\Source/queue.c **** 
2010:..\FreeRTOS\Source/queue.c ****     return uxReturn;
 2348              		.loc 1 2010 0
 2349 002c BB68     		ldr	r3, [r7, #8]
2011:..\FreeRTOS\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2350              		.loc 1 2011 0
 2351 002e 1800     		movs	r0, r3
 2352 0030 BD46     		mov	sp, r7
 2353 0032 04B0     		add	sp, sp, #16
 2354              		@ sp needed
 2355 0034 80BD     		pop	{r7, pc}
 2356              	.L254:
 2357 0036 C046     		.align	2
 2358              	.L253:
 2359 0038 00000000 		.word	x
 2360              		.cfi_endproc
 2361              	.LFE13:
 2362              		.size	uxQueueSpacesAvailable, .-uxQueueSpacesAvailable
 2363              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 2364              		.align	2
 2365              		.global	uxQueueMessagesWaitingFromISR
 2366              		.code	16
 2367              		.thumb_func
 2368              		.type	uxQueueMessagesWaitingFromISR, %function
 2369              	uxQueueMessagesWaitingFromISR:
 2370              	.LFB14:
2012:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2013:..\FreeRTOS\Source/queue.c **** 
2014:..\FreeRTOS\Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
2015:..\FreeRTOS\Source/queue.c **** {
 2371              		.loc 1 2015 0
 2372              		.cfi_startproc
 2373              		@ args = 0, pretend = 0, frame = 16
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 78


 2374              		@ frame_needed = 1, uses_anonymous_args = 0
 2375 0000 80B5     		push	{r7, lr}
 2376              		.cfi_def_cfa_offset 8
 2377              		.cfi_offset 7, -8
 2378              		.cfi_offset 14, -4
 2379 0002 84B0     		sub	sp, sp, #16
 2380              		.cfi_def_cfa_offset 24
 2381 0004 00AF     		add	r7, sp, #0
 2382              		.cfi_def_cfa_register 7
 2383 0006 7860     		str	r0, [r7, #4]
2016:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxReturn;
2017:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2384              		.loc 1 2017 0
 2385 0008 7B68     		ldr	r3, [r7, #4]
 2386 000a FB60     		str	r3, [r7, #12]
2018:..\FreeRTOS\Source/queue.c **** 
2019:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 2387              		.loc 1 2019 0
 2388 000c 064B     		ldr	r3, .L259
 2389 000e 1B88     		ldrh	r3, [r3]
 2390 0010 002B     		cmp	r3, #0
 2391 0012 01D1     		bne	.L256
 2392              		.loc 1 2019 0 is_stmt 0 discriminator 1
 2393              		.syntax divided
 2394              	@ 2019 "..\FreeRTOS\Source\queue.c" 1
 2395 0014 72B6     		 cpsid i 
 2396              	@ 0 "" 2
 2397              		.thumb
 2398              		.syntax unified
 2399              	.L257:
 2400 0016 FEE7     		b	.L257
 2401              	.L256:
2020:..\FreeRTOS\Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 2402              		.loc 1 2020 0 is_stmt 1
 2403 0018 FB68     		ldr	r3, [r7, #12]
 2404 001a 9B6B     		ldr	r3, [r3, #56]
 2405 001c BB60     		str	r3, [r7, #8]
2021:..\FreeRTOS\Source/queue.c **** 
2022:..\FreeRTOS\Source/queue.c ****     return uxReturn;
 2406              		.loc 1 2022 0
 2407 001e BB68     		ldr	r3, [r7, #8]
2023:..\FreeRTOS\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 2408              		.loc 1 2023 0
 2409 0020 1800     		movs	r0, r3
 2410 0022 BD46     		mov	sp, r7
 2411 0024 04B0     		add	sp, sp, #16
 2412              		@ sp needed
 2413 0026 80BD     		pop	{r7, pc}
 2414              	.L260:
 2415              		.align	2
 2416              	.L259:
 2417 0028 00000000 		.word	x
 2418              		.cfi_endproc
 2419              	.LFE14:
 2420              		.size	uxQueueMessagesWaitingFromISR, .-uxQueueMessagesWaitingFromISR
 2421              		.section	.text.vQueueDelete,"ax",%progbits
 2422              		.align	2
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 79


 2423              		.global	vQueueDelete
 2424              		.code	16
 2425              		.thumb_func
 2426              		.type	vQueueDelete, %function
 2427              	vQueueDelete:
 2428              	.LFB15:
2024:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2025:..\FreeRTOS\Source/queue.c **** 
2026:..\FreeRTOS\Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
2027:..\FreeRTOS\Source/queue.c **** {
 2429              		.loc 1 2027 0
 2430              		.cfi_startproc
 2431              		@ args = 0, pretend = 0, frame = 16
 2432              		@ frame_needed = 1, uses_anonymous_args = 0
 2433 0000 80B5     		push	{r7, lr}
 2434              		.cfi_def_cfa_offset 8
 2435              		.cfi_offset 7, -8
 2436              		.cfi_offset 14, -4
 2437 0002 84B0     		sub	sp, sp, #16
 2438              		.cfi_def_cfa_offset 24
 2439 0004 00AF     		add	r7, sp, #0
 2440              		.cfi_def_cfa_register 7
 2441 0006 7860     		str	r0, [r7, #4]
2028:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2442              		.loc 1 2028 0
 2443 0008 7B68     		ldr	r3, [r7, #4]
 2444 000a FB60     		str	r3, [r7, #12]
2029:..\FreeRTOS\Source/queue.c **** 
2030:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 2445              		.loc 1 2030 0
 2446 000c 0B4B     		ldr	r3, .L266
 2447 000e 1B88     		ldrh	r3, [r3]
 2448 0010 002B     		cmp	r3, #0
 2449 0012 01D1     		bne	.L262
 2450              		.loc 1 2030 0 is_stmt 0 discriminator 1
 2451              		.syntax divided
 2452              	@ 2030 "..\FreeRTOS\Source\queue.c" 1
 2453 0014 72B6     		 cpsid i 
 2454              	@ 0 "" 2
 2455              		.thumb
 2456              		.syntax unified
 2457              	.L263:
 2458 0016 FEE7     		b	.L263
 2459              	.L262:
2031:..\FreeRTOS\Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
2032:..\FreeRTOS\Source/queue.c **** 
2033:..\FreeRTOS\Source/queue.c ****     #if ( configQUEUE_REGISTRY_SIZE > 0 )
2034:..\FreeRTOS\Source/queue.c ****         {
2035:..\FreeRTOS\Source/queue.c ****             vQueueUnregisterQueue( pxQueue );
 2460              		.loc 1 2035 0 is_stmt 1
 2461 0018 FB68     		ldr	r3, [r7, #12]
 2462 001a 1800     		movs	r0, r3
 2463 001c FFF7FEFF 		bl	vQueueUnregisterQueue
2036:..\FreeRTOS\Source/queue.c ****         }
2037:..\FreeRTOS\Source/queue.c ****     #endif
2038:..\FreeRTOS\Source/queue.c **** 
2039:..\FreeRTOS\Source/queue.c ****     #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 80


2040:..\FreeRTOS\Source/queue.c ****         {
2041:..\FreeRTOS\Source/queue.c ****             /* The queue can only have been allocated dynamically - free it
2042:..\FreeRTOS\Source/queue.c ****              * again. */
2043:..\FreeRTOS\Source/queue.c ****             vPortFree( pxQueue );
2044:..\FreeRTOS\Source/queue.c ****         }
2045:..\FreeRTOS\Source/queue.c ****     #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
2046:..\FreeRTOS\Source/queue.c ****         {
2047:..\FreeRTOS\Source/queue.c ****             /* The queue could have been allocated statically or dynamically, so
2048:..\FreeRTOS\Source/queue.c ****              * check before attempting to free the memory. */
2049:..\FreeRTOS\Source/queue.c ****             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 2464              		.loc 1 2049 0
 2465 0020 FB68     		ldr	r3, [r7, #12]
 2466 0022 4622     		movs	r2, #70
 2467 0024 9B5C     		ldrb	r3, [r3, r2]
 2468 0026 002B     		cmp	r3, #0
 2469 0028 03D1     		bne	.L265
2050:..\FreeRTOS\Source/queue.c ****             {
2051:..\FreeRTOS\Source/queue.c ****                 vPortFree( pxQueue );
 2470              		.loc 1 2051 0
 2471 002a FB68     		ldr	r3, [r7, #12]
 2472 002c 1800     		movs	r0, r3
 2473 002e FFF7FEFF 		bl	vPortFree
 2474              	.L265:
2052:..\FreeRTOS\Source/queue.c ****             }
2053:..\FreeRTOS\Source/queue.c ****             else
2054:..\FreeRTOS\Source/queue.c ****             {
2055:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2056:..\FreeRTOS\Source/queue.c ****             }
2057:..\FreeRTOS\Source/queue.c ****         }
2058:..\FreeRTOS\Source/queue.c ****     #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION ==
2059:..\FreeRTOS\Source/queue.c ****         {
2060:..\FreeRTOS\Source/queue.c ****             /* The queue must have been statically allocated, so is not going to be
2061:..\FreeRTOS\Source/queue.c ****              * deleted.  Avoid compiler warnings about the unused parameter. */
2062:..\FreeRTOS\Source/queue.c ****             ( void ) pxQueue;
2063:..\FreeRTOS\Source/queue.c ****         }
2064:..\FreeRTOS\Source/queue.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2065:..\FreeRTOS\Source/queue.c **** }
 2475              		.loc 1 2065 0
 2476 0032 C046     		nop
 2477 0034 BD46     		mov	sp, r7
 2478 0036 04B0     		add	sp, sp, #16
 2479              		@ sp needed
 2480 0038 80BD     		pop	{r7, pc}
 2481              	.L267:
 2482 003a C046     		.align	2
 2483              	.L266:
 2484 003c 00000000 		.word	x
 2485              		.cfi_endproc
 2486              	.LFE15:
 2487              		.size	vQueueDelete, .-vQueueDelete
 2488              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 2489              		.align	2
 2490              		.code	16
 2491              		.thumb_func
 2492              		.type	prvCopyDataToQueue, %function
 2493              	prvCopyDataToQueue:
 2494              	.LFB16:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 81


2066:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2067:..\FreeRTOS\Source/queue.c **** 
2068:..\FreeRTOS\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2069:..\FreeRTOS\Source/queue.c **** 
2070:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2071:..\FreeRTOS\Source/queue.c ****     {
2072:..\FreeRTOS\Source/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2073:..\FreeRTOS\Source/queue.c ****     }
2074:..\FreeRTOS\Source/queue.c **** 
2075:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2076:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2077:..\FreeRTOS\Source/queue.c **** 
2078:..\FreeRTOS\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2079:..\FreeRTOS\Source/queue.c **** 
2080:..\FreeRTOS\Source/queue.c ****     void vQueueSetQueueNumber( QueueHandle_t xQueue,
2081:..\FreeRTOS\Source/queue.c ****                                UBaseType_t uxQueueNumber )
2082:..\FreeRTOS\Source/queue.c ****     {
2083:..\FreeRTOS\Source/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2084:..\FreeRTOS\Source/queue.c ****     }
2085:..\FreeRTOS\Source/queue.c **** 
2086:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2087:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2088:..\FreeRTOS\Source/queue.c **** 
2089:..\FreeRTOS\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2090:..\FreeRTOS\Source/queue.c **** 
2091:..\FreeRTOS\Source/queue.c ****     uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2092:..\FreeRTOS\Source/queue.c ****     {
2093:..\FreeRTOS\Source/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
2094:..\FreeRTOS\Source/queue.c ****     }
2095:..\FreeRTOS\Source/queue.c **** 
2096:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2097:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2098:..\FreeRTOS\Source/queue.c **** 
2099:..\FreeRTOS\Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
2100:..\FreeRTOS\Source/queue.c **** 
2101:..\FreeRTOS\Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2102:..\FreeRTOS\Source/queue.c ****     {
2103:..\FreeRTOS\Source/queue.c ****         UBaseType_t uxHighestPriorityOfWaitingTasks;
2104:..\FreeRTOS\Source/queue.c **** 
2105:..\FreeRTOS\Source/queue.c ****         /* If a task waiting for a mutex causes the mutex holder to inherit a
2106:..\FreeRTOS\Source/queue.c ****          * priority, but the waiting task times out, then the holder should
2107:..\FreeRTOS\Source/queue.c ****          * disinherit the priority - but only down to the highest priority of any
2108:..\FreeRTOS\Source/queue.c ****          * other tasks that are waiting for the same mutex.  For this purpose,
2109:..\FreeRTOS\Source/queue.c ****          * return the priority of the highest priority task that is waiting for the
2110:..\FreeRTOS\Source/queue.c ****          * mutex. */
2111:..\FreeRTOS\Source/queue.c ****         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2112:..\FreeRTOS\Source/queue.c ****         {
2113:..\FreeRTOS\Source/queue.c ****             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t 
2114:..\FreeRTOS\Source/queue.c ****         }
2115:..\FreeRTOS\Source/queue.c ****         else
2116:..\FreeRTOS\Source/queue.c ****         {
2117:..\FreeRTOS\Source/queue.c ****             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2118:..\FreeRTOS\Source/queue.c ****         }
2119:..\FreeRTOS\Source/queue.c **** 
2120:..\FreeRTOS\Source/queue.c ****         return uxHighestPriorityOfWaitingTasks;
2121:..\FreeRTOS\Source/queue.c ****     }
2122:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 82


2123:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_MUTEXES */
2124:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2125:..\FreeRTOS\Source/queue.c **** 
2126:..\FreeRTOS\Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
2127:..\FreeRTOS\Source/queue.c ****                                       const void * pvItemToQueue,
2128:..\FreeRTOS\Source/queue.c ****                                       const BaseType_t xPosition )
2129:..\FreeRTOS\Source/queue.c **** {
 2495              		.loc 1 2129 0
 2496              		.cfi_startproc
 2497              		@ args = 0, pretend = 0, frame = 24
 2498              		@ frame_needed = 1, uses_anonymous_args = 0
 2499 0000 80B5     		push	{r7, lr}
 2500              		.cfi_def_cfa_offset 8
 2501              		.cfi_offset 7, -8
 2502              		.cfi_offset 14, -4
 2503 0002 86B0     		sub	sp, sp, #24
 2504              		.cfi_def_cfa_offset 32
 2505 0004 00AF     		add	r7, sp, #0
 2506              		.cfi_def_cfa_register 7
 2507 0006 F860     		str	r0, [r7, #12]
 2508 0008 B960     		str	r1, [r7, #8]
 2509 000a 7A60     		str	r2, [r7, #4]
2130:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn = pdFALSE;
 2510              		.loc 1 2130 0
 2511 000c 0023     		movs	r3, #0
 2512 000e 3B61     		str	r3, [r7, #16]
2131:..\FreeRTOS\Source/queue.c ****     UBaseType_t uxMessagesWaiting;
2132:..\FreeRTOS\Source/queue.c **** 
2133:..\FreeRTOS\Source/queue.c ****     /* This function is called from a critical section. */
2134:..\FreeRTOS\Source/queue.c **** 
2135:..\FreeRTOS\Source/queue.c ****     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2513              		.loc 1 2135 0
 2514 0010 FB68     		ldr	r3, [r7, #12]
 2515 0012 9B6B     		ldr	r3, [r3, #56]
 2516 0014 7B61     		str	r3, [r7, #20]
2136:..\FreeRTOS\Source/queue.c **** 
2137:..\FreeRTOS\Source/queue.c ****     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 2517              		.loc 1 2137 0
 2518 0016 FB68     		ldr	r3, [r7, #12]
 2519 0018 1B6C     		ldr	r3, [r3, #64]
 2520 001a 002B     		cmp	r3, #0
 2521 001c 43D0     		beq	.L269
2138:..\FreeRTOS\Source/queue.c ****     {
2139:..\FreeRTOS\Source/queue.c ****         #if ( configUSE_MUTEXES == 1 )
2140:..\FreeRTOS\Source/queue.c ****             {
2141:..\FreeRTOS\Source/queue.c ****                 if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2142:..\FreeRTOS\Source/queue.c ****                 {
2143:..\FreeRTOS\Source/queue.c ****                     /* The mutex is no longer being held. */
2144:..\FreeRTOS\Source/queue.c ****                     xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2145:..\FreeRTOS\Source/queue.c ****                     pxQueue->u.xSemaphore.xMutexHolder = NULL;
2146:..\FreeRTOS\Source/queue.c ****                 }
2147:..\FreeRTOS\Source/queue.c ****                 else
2148:..\FreeRTOS\Source/queue.c ****                 {
2149:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2150:..\FreeRTOS\Source/queue.c ****                 }
2151:..\FreeRTOS\Source/queue.c ****             }
2152:..\FreeRTOS\Source/queue.c ****         #endif /* configUSE_MUTEXES */
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 83


2153:..\FreeRTOS\Source/queue.c ****     }
2154:..\FreeRTOS\Source/queue.c ****     else if( xPosition == queueSEND_TO_BACK )
 2522              		.loc 1 2154 0
 2523 001e 7B68     		ldr	r3, [r7, #4]
 2524 0020 002B     		cmp	r3, #0
 2525 0022 19D1     		bne	.L270
2155:..\FreeRTOS\Source/queue.c ****     {
2156:..\FreeRTOS\Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSi
 2526              		.loc 1 2156 0
 2527 0024 FB68     		ldr	r3, [r7, #12]
 2528 0026 5868     		ldr	r0, [r3, #4]
 2529 0028 FB68     		ldr	r3, [r7, #12]
 2530 002a 1A6C     		ldr	r2, [r3, #64]
 2531 002c BB68     		ldr	r3, [r7, #8]
 2532 002e 1900     		movs	r1, r3
 2533 0030 FFF7FEFF 		bl	memcpy
2157:..\FreeRTOS\Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 2534              		.loc 1 2157 0
 2535 0034 FB68     		ldr	r3, [r7, #12]
 2536 0036 5A68     		ldr	r2, [r3, #4]
 2537 0038 FB68     		ldr	r3, [r7, #12]
 2538 003a 1B6C     		ldr	r3, [r3, #64]
 2539 003c D218     		adds	r2, r2, r3
 2540 003e FB68     		ldr	r3, [r7, #12]
 2541 0040 5A60     		str	r2, [r3, #4]
2158:..\FreeRTOS\Source/queue.c **** 
2159:..\FreeRTOS\Source/queue.c ****         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                       
 2542              		.loc 1 2159 0
 2543 0042 FB68     		ldr	r3, [r7, #12]
 2544 0044 5A68     		ldr	r2, [r3, #4]
 2545 0046 FB68     		ldr	r3, [r7, #12]
 2546 0048 9B68     		ldr	r3, [r3, #8]
 2547 004a 9A42     		cmp	r2, r3
 2548 004c 2BD3     		bcc	.L269
2160:..\FreeRTOS\Source/queue.c ****         {
2161:..\FreeRTOS\Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 2549              		.loc 1 2161 0
 2550 004e FB68     		ldr	r3, [r7, #12]
 2551 0050 1A68     		ldr	r2, [r3]
 2552 0052 FB68     		ldr	r3, [r7, #12]
 2553 0054 5A60     		str	r2, [r3, #4]
 2554 0056 26E0     		b	.L269
 2555              	.L270:
2162:..\FreeRTOS\Source/queue.c ****         }
2163:..\FreeRTOS\Source/queue.c ****         else
2164:..\FreeRTOS\Source/queue.c ****         {
2165:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2166:..\FreeRTOS\Source/queue.c ****         }
2167:..\FreeRTOS\Source/queue.c ****     }
2168:..\FreeRTOS\Source/queue.c ****     else
2169:..\FreeRTOS\Source/queue.c ****     {
2170:..\FreeRTOS\Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue
 2556              		.loc 1 2170 0
 2557 0058 FB68     		ldr	r3, [r7, #12]
 2558 005a D868     		ldr	r0, [r3, #12]
 2559 005c FB68     		ldr	r3, [r7, #12]
 2560 005e 1A6C     		ldr	r2, [r3, #64]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 84


 2561 0060 BB68     		ldr	r3, [r7, #8]
 2562 0062 1900     		movs	r1, r3
 2563 0064 FFF7FEFF 		bl	memcpy
2171:..\FreeRTOS\Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 2564              		.loc 1 2171 0
 2565 0068 FB68     		ldr	r3, [r7, #12]
 2566 006a DA68     		ldr	r2, [r3, #12]
 2567 006c FB68     		ldr	r3, [r7, #12]
 2568 006e 1B6C     		ldr	r3, [r3, #64]
 2569 0070 5B42     		rsbs	r3, r3, #0
 2570 0072 D218     		adds	r2, r2, r3
 2571 0074 FB68     		ldr	r3, [r7, #12]
 2572 0076 DA60     		str	r2, [r3, #12]
2172:..\FreeRTOS\Source/queue.c **** 
2173:..\FreeRTOS\Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified
 2573              		.loc 1 2173 0
 2574 0078 FB68     		ldr	r3, [r7, #12]
 2575 007a DA68     		ldr	r2, [r3, #12]
 2576 007c FB68     		ldr	r3, [r7, #12]
 2577 007e 1B68     		ldr	r3, [r3]
 2578 0080 9A42     		cmp	r2, r3
 2579 0082 07D2     		bcs	.L271
2174:..\FreeRTOS\Source/queue.c ****         {
2175:..\FreeRTOS\Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 2580              		.loc 1 2175 0
 2581 0084 FB68     		ldr	r3, [r7, #12]
 2582 0086 9A68     		ldr	r2, [r3, #8]
 2583 0088 FB68     		ldr	r3, [r7, #12]
 2584 008a 1B6C     		ldr	r3, [r3, #64]
 2585 008c 5B42     		rsbs	r3, r3, #0
 2586 008e D218     		adds	r2, r2, r3
 2587 0090 FB68     		ldr	r3, [r7, #12]
 2588 0092 DA60     		str	r2, [r3, #12]
 2589              	.L271:
2176:..\FreeRTOS\Source/queue.c ****         }
2177:..\FreeRTOS\Source/queue.c ****         else
2178:..\FreeRTOS\Source/queue.c ****         {
2179:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2180:..\FreeRTOS\Source/queue.c ****         }
2181:..\FreeRTOS\Source/queue.c **** 
2182:..\FreeRTOS\Source/queue.c ****         if( xPosition == queueOVERWRITE )
 2590              		.loc 1 2182 0
 2591 0094 7B68     		ldr	r3, [r7, #4]
 2592 0096 022B     		cmp	r3, #2
 2593 0098 05D1     		bne	.L269
2183:..\FreeRTOS\Source/queue.c ****         {
2184:..\FreeRTOS\Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2594              		.loc 1 2184 0
 2595 009a 7B69     		ldr	r3, [r7, #20]
 2596 009c 002B     		cmp	r3, #0
 2597 009e 02D0     		beq	.L269
2185:..\FreeRTOS\Source/queue.c ****             {
2186:..\FreeRTOS\Source/queue.c ****                 /* An item is not being added but overwritten, so subtract
2187:..\FreeRTOS\Source/queue.c ****                  * one from the recorded number of items in the queue so when
2188:..\FreeRTOS\Source/queue.c ****                  * one is added again below the number of recorded items remains
2189:..\FreeRTOS\Source/queue.c ****                  * correct. */
2190:..\FreeRTOS\Source/queue.c ****                 --uxMessagesWaiting;
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 85


 2598              		.loc 1 2190 0
 2599 00a0 7B69     		ldr	r3, [r7, #20]
 2600 00a2 013B     		subs	r3, r3, #1
 2601 00a4 7B61     		str	r3, [r7, #20]
 2602              	.L269:
2191:..\FreeRTOS\Source/queue.c ****             }
2192:..\FreeRTOS\Source/queue.c ****             else
2193:..\FreeRTOS\Source/queue.c ****             {
2194:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2195:..\FreeRTOS\Source/queue.c ****             }
2196:..\FreeRTOS\Source/queue.c ****         }
2197:..\FreeRTOS\Source/queue.c ****         else
2198:..\FreeRTOS\Source/queue.c ****         {
2199:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2200:..\FreeRTOS\Source/queue.c ****         }
2201:..\FreeRTOS\Source/queue.c ****     }
2202:..\FreeRTOS\Source/queue.c **** 
2203:..\FreeRTOS\Source/queue.c ****     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 2603              		.loc 1 2203 0
 2604 00a6 7B69     		ldr	r3, [r7, #20]
 2605 00a8 5A1C     		adds	r2, r3, #1
 2606 00aa FB68     		ldr	r3, [r7, #12]
 2607 00ac 9A63     		str	r2, [r3, #56]
2204:..\FreeRTOS\Source/queue.c **** 
2205:..\FreeRTOS\Source/queue.c ****     return xReturn;
 2608              		.loc 1 2205 0
 2609 00ae 3B69     		ldr	r3, [r7, #16]
2206:..\FreeRTOS\Source/queue.c **** }
 2610              		.loc 1 2206 0
 2611 00b0 1800     		movs	r0, r3
 2612 00b2 BD46     		mov	sp, r7
 2613 00b4 06B0     		add	sp, sp, #24
 2614              		@ sp needed
 2615 00b6 80BD     		pop	{r7, pc}
 2616              		.cfi_endproc
 2617              	.LFE16:
 2618              		.size	prvCopyDataToQueue, .-prvCopyDataToQueue
 2619              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 2620              		.align	2
 2621              		.code	16
 2622              		.thumb_func
 2623              		.type	prvCopyDataFromQueue, %function
 2624              	prvCopyDataFromQueue:
 2625              	.LFB17:
2207:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2208:..\FreeRTOS\Source/queue.c **** 
2209:..\FreeRTOS\Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
2210:..\FreeRTOS\Source/queue.c ****                                   void * const pvBuffer )
2211:..\FreeRTOS\Source/queue.c **** {
 2626              		.loc 1 2211 0
 2627              		.cfi_startproc
 2628              		@ args = 0, pretend = 0, frame = 8
 2629              		@ frame_needed = 1, uses_anonymous_args = 0
 2630 0000 80B5     		push	{r7, lr}
 2631              		.cfi_def_cfa_offset 8
 2632              		.cfi_offset 7, -8
 2633              		.cfi_offset 14, -4
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 86


 2634 0002 82B0     		sub	sp, sp, #8
 2635              		.cfi_def_cfa_offset 16
 2636 0004 00AF     		add	r7, sp, #0
 2637              		.cfi_def_cfa_register 7
 2638 0006 7860     		str	r0, [r7, #4]
 2639 0008 3960     		str	r1, [r7]
2212:..\FreeRTOS\Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2640              		.loc 1 2212 0
 2641 000a 7B68     		ldr	r3, [r7, #4]
 2642 000c 1B6C     		ldr	r3, [r3, #64]
 2643 000e 002B     		cmp	r3, #0
 2644 0010 18D0     		beq	.L276
2213:..\FreeRTOS\Source/queue.c ****     {
2214:..\FreeRTOS\Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithm
 2645              		.loc 1 2214 0
 2646 0012 7B68     		ldr	r3, [r7, #4]
 2647 0014 DA68     		ldr	r2, [r3, #12]
 2648 0016 7B68     		ldr	r3, [r7, #4]
 2649 0018 1B6C     		ldr	r3, [r3, #64]
 2650 001a D218     		adds	r2, r2, r3
 2651 001c 7B68     		ldr	r3, [r7, #4]
 2652 001e DA60     		str	r2, [r3, #12]
2215:..\FreeRTOS\Source/queue.c **** 
2216:..\FreeRTOS\Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception
 2653              		.loc 1 2216 0
 2654 0020 7B68     		ldr	r3, [r7, #4]
 2655 0022 DA68     		ldr	r2, [r3, #12]
 2656 0024 7B68     		ldr	r3, [r7, #4]
 2657 0026 9B68     		ldr	r3, [r3, #8]
 2658 0028 9A42     		cmp	r2, r3
 2659 002a 03D3     		bcc	.L275
2217:..\FreeRTOS\Source/queue.c ****         {
2218:..\FreeRTOS\Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 2660              		.loc 1 2218 0
 2661 002c 7B68     		ldr	r3, [r7, #4]
 2662 002e 1A68     		ldr	r2, [r3]
 2663 0030 7B68     		ldr	r3, [r7, #4]
 2664 0032 DA60     		str	r2, [r3, #12]
 2665              	.L275:
2219:..\FreeRTOS\Source/queue.c ****         }
2220:..\FreeRTOS\Source/queue.c ****         else
2221:..\FreeRTOS\Source/queue.c ****         {
2222:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2223:..\FreeRTOS\Source/queue.c ****         }
2224:..\FreeRTOS\Source/queue.c **** 
2225:..\FreeRTOS\Source/queue.c ****         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) p
 2666              		.loc 1 2225 0
 2667 0034 7B68     		ldr	r3, [r7, #4]
 2668 0036 D968     		ldr	r1, [r3, #12]
 2669 0038 7B68     		ldr	r3, [r7, #4]
 2670 003a 1A6C     		ldr	r2, [r3, #64]
 2671 003c 3B68     		ldr	r3, [r7]
 2672 003e 1800     		movs	r0, r3
 2673 0040 FFF7FEFF 		bl	memcpy
 2674              	.L276:
2226:..\FreeRTOS\Source/queue.c ****     }
2227:..\FreeRTOS\Source/queue.c **** }
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 87


 2675              		.loc 1 2227 0
 2676 0044 C046     		nop
 2677 0046 BD46     		mov	sp, r7
 2678 0048 02B0     		add	sp, sp, #8
 2679              		@ sp needed
 2680 004a 80BD     		pop	{r7, pc}
 2681              		.cfi_endproc
 2682              	.LFE17:
 2683              		.size	prvCopyDataFromQueue, .-prvCopyDataFromQueue
 2684              		.section	.text.prvUnlockQueue,"ax",%progbits
 2685              		.align	2
 2686              		.code	16
 2687              		.thumb_func
 2688              		.type	prvUnlockQueue, %function
 2689              	prvUnlockQueue:
 2690              	.LFB18:
2228:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2229:..\FreeRTOS\Source/queue.c **** 
2230:..\FreeRTOS\Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2231:..\FreeRTOS\Source/queue.c **** {
 2691              		.loc 1 2231 0
 2692              		.cfi_startproc
 2693              		@ args = 0, pretend = 0, frame = 16
 2694              		@ frame_needed = 1, uses_anonymous_args = 0
 2695 0000 80B5     		push	{r7, lr}
 2696              		.cfi_def_cfa_offset 8
 2697              		.cfi_offset 7, -8
 2698              		.cfi_offset 14, -4
 2699 0002 84B0     		sub	sp, sp, #16
 2700              		.cfi_def_cfa_offset 24
 2701 0004 00AF     		add	r7, sp, #0
 2702              		.cfi_def_cfa_register 7
 2703 0006 7860     		str	r0, [r7, #4]
2232:..\FreeRTOS\Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2233:..\FreeRTOS\Source/queue.c **** 
2234:..\FreeRTOS\Source/queue.c ****     /* The lock counts contains the number of extra data items placed or
2235:..\FreeRTOS\Source/queue.c ****      * removed from the queue while the queue was locked.  When a queue is
2236:..\FreeRTOS\Source/queue.c ****      * locked items can be added or removed, but the event lists cannot be
2237:..\FreeRTOS\Source/queue.c ****      * updated. */
2238:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();
 2704              		.loc 1 2238 0
 2705 0008 FFF7FEFF 		bl	vPortEnterCritical
 2706              	.LBB11:
2239:..\FreeRTOS\Source/queue.c ****     {
2240:..\FreeRTOS\Source/queue.c ****         int8_t cTxLock = pxQueue->cTxLock;
 2707              		.loc 1 2240 0
 2708 000c 0F23     		movs	r3, #15
 2709 000e FB18     		adds	r3, r7, r3
 2710 0010 7A68     		ldr	r2, [r7, #4]
 2711 0012 4521     		movs	r1, #69
 2712 0014 525C     		ldrb	r2, [r2, r1]
 2713 0016 1A70     		strb	r2, [r3]
2241:..\FreeRTOS\Source/queue.c **** 
2242:..\FreeRTOS\Source/queue.c ****         /* See if data was added to the queue while it was locked. */
2243:..\FreeRTOS\Source/queue.c ****         while( cTxLock > queueLOCKED_UNMODIFIED )
 2714              		.loc 1 2243 0
 2715 0018 14E0     		b	.L278
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 88


 2716              	.L282:
2244:..\FreeRTOS\Source/queue.c ****         {
2245:..\FreeRTOS\Source/queue.c ****             /* Data was posted while the queue was locked.  Are any tasks
2246:..\FreeRTOS\Source/queue.c ****              * blocked waiting for data to become available? */
2247:..\FreeRTOS\Source/queue.c ****             #if ( configUSE_QUEUE_SETS == 1 )
2248:..\FreeRTOS\Source/queue.c ****                 {
2249:..\FreeRTOS\Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
2250:..\FreeRTOS\Source/queue.c ****                     {
2251:..\FreeRTOS\Source/queue.c ****                         if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2252:..\FreeRTOS\Source/queue.c ****                         {
2253:..\FreeRTOS\Source/queue.c ****                             /* The queue is a member of a queue set, and posting to
2254:..\FreeRTOS\Source/queue.c ****                              * the queue set caused a higher priority task to unblock.
2255:..\FreeRTOS\Source/queue.c ****                              * A context switch is required. */
2256:..\FreeRTOS\Source/queue.c ****                             vTaskMissedYield();
2257:..\FreeRTOS\Source/queue.c ****                         }
2258:..\FreeRTOS\Source/queue.c ****                         else
2259:..\FreeRTOS\Source/queue.c ****                         {
2260:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2261:..\FreeRTOS\Source/queue.c ****                         }
2262:..\FreeRTOS\Source/queue.c ****                     }
2263:..\FreeRTOS\Source/queue.c ****                     else
2264:..\FreeRTOS\Source/queue.c ****                     {
2265:..\FreeRTOS\Source/queue.c ****                         /* Tasks that are removed from the event list will get
2266:..\FreeRTOS\Source/queue.c ****                          * added to the pending ready list as the scheduler is still
2267:..\FreeRTOS\Source/queue.c ****                          * suspended. */
2268:..\FreeRTOS\Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2269:..\FreeRTOS\Source/queue.c ****                         {
2270:..\FreeRTOS\Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
2271:..\FreeRTOS\Source/queue.c ****                             {
2272:..\FreeRTOS\Source/queue.c ****                                 /* The task waiting has a higher priority so record that a
2273:..\FreeRTOS\Source/queue.c ****                                  * context switch is required. */
2274:..\FreeRTOS\Source/queue.c ****                                 vTaskMissedYield();
2275:..\FreeRTOS\Source/queue.c ****                             }
2276:..\FreeRTOS\Source/queue.c ****                             else
2277:..\FreeRTOS\Source/queue.c ****                             {
2278:..\FreeRTOS\Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
2279:..\FreeRTOS\Source/queue.c ****                             }
2280:..\FreeRTOS\Source/queue.c ****                         }
2281:..\FreeRTOS\Source/queue.c ****                         else
2282:..\FreeRTOS\Source/queue.c ****                         {
2283:..\FreeRTOS\Source/queue.c ****                             break;
2284:..\FreeRTOS\Source/queue.c ****                         }
2285:..\FreeRTOS\Source/queue.c ****                     }
2286:..\FreeRTOS\Source/queue.c ****                 }
2287:..\FreeRTOS\Source/queue.c ****             #else /* configUSE_QUEUE_SETS */
2288:..\FreeRTOS\Source/queue.c ****                 {
2289:..\FreeRTOS\Source/queue.c ****                     /* Tasks that are removed from the event list will get added to
2290:..\FreeRTOS\Source/queue.c ****                      * the pending ready list as the scheduler is still suspended. */
2291:..\FreeRTOS\Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2717              		.loc 1 2291 0
 2718 001a 7B68     		ldr	r3, [r7, #4]
 2719 001c 5B6A     		ldr	r3, [r3, #36]
 2720 001e 002B     		cmp	r3, #0
 2721 0020 17D0     		beq	.L288
2292:..\FreeRTOS\Source/queue.c ****                     {
2293:..\FreeRTOS\Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
 2722              		.loc 1 2293 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 89


 2723 0022 7B68     		ldr	r3, [r7, #4]
 2724 0024 2433     		adds	r3, r3, #36
 2725 0026 1800     		movs	r0, r3
 2726 0028 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2727 002c 031E     		subs	r3, r0, #0
 2728 002e 01D0     		beq	.L280
2294:..\FreeRTOS\Source/queue.c ****                         {
2295:..\FreeRTOS\Source/queue.c ****                             /* The task waiting has a higher priority so record that
2296:..\FreeRTOS\Source/queue.c ****                              * a context switch is required. */
2297:..\FreeRTOS\Source/queue.c ****                             vTaskMissedYield();
 2729              		.loc 1 2297 0
 2730 0030 FFF7FEFF 		bl	vTaskMissedYield
 2731              	.L280:
2298:..\FreeRTOS\Source/queue.c ****                         }
2299:..\FreeRTOS\Source/queue.c ****                         else
2300:..\FreeRTOS\Source/queue.c ****                         {
2301:..\FreeRTOS\Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2302:..\FreeRTOS\Source/queue.c ****                         }
2303:..\FreeRTOS\Source/queue.c ****                     }
2304:..\FreeRTOS\Source/queue.c ****                     else
2305:..\FreeRTOS\Source/queue.c ****                     {
2306:..\FreeRTOS\Source/queue.c ****                         break;
2307:..\FreeRTOS\Source/queue.c ****                     }
2308:..\FreeRTOS\Source/queue.c ****                 }
2309:..\FreeRTOS\Source/queue.c ****             #endif /* configUSE_QUEUE_SETS */
2310:..\FreeRTOS\Source/queue.c **** 
2311:..\FreeRTOS\Source/queue.c ****             --cTxLock;
 2732              		.loc 1 2311 0
 2733 0034 0F23     		movs	r3, #15
 2734 0036 FB18     		adds	r3, r7, r3
 2735 0038 1B78     		ldrb	r3, [r3]
 2736 003a 013B     		subs	r3, r3, #1
 2737 003c DAB2     		uxtb	r2, r3
 2738 003e 0F23     		movs	r3, #15
 2739 0040 FB18     		adds	r3, r7, r3
 2740 0042 1A70     		strb	r2, [r3]
 2741              	.L278:
2243:..\FreeRTOS\Source/queue.c ****         {
 2742              		.loc 1 2243 0
 2743 0044 0F23     		movs	r3, #15
 2744 0046 FB18     		adds	r3, r7, r3
 2745 0048 1B78     		ldrb	r3, [r3]
 2746 004a 5BB2     		sxtb	r3, r3
 2747 004c 002B     		cmp	r3, #0
 2748 004e E4DC     		bgt	.L282
 2749 0050 00E0     		b	.L281
 2750              	.L288:
2306:..\FreeRTOS\Source/queue.c ****                     }
 2751              		.loc 1 2306 0
 2752 0052 C046     		nop
 2753              	.L281:
2312:..\FreeRTOS\Source/queue.c ****         }
2313:..\FreeRTOS\Source/queue.c **** 
2314:..\FreeRTOS\Source/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 2754              		.loc 1 2314 0
 2755 0054 7B68     		ldr	r3, [r7, #4]
 2756 0056 4522     		movs	r2, #69
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 90


 2757 0058 FF21     		movs	r1, #255
 2758 005a 9954     		strb	r1, [r3, r2]
 2759              	.LBE11:
2315:..\FreeRTOS\Source/queue.c ****     }
2316:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL();
 2760              		.loc 1 2316 0
 2761 005c FFF7FEFF 		bl	vPortExitCritical
2317:..\FreeRTOS\Source/queue.c **** 
2318:..\FreeRTOS\Source/queue.c ****     /* Do the same for the Rx lock. */
2319:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();
 2762              		.loc 1 2319 0
 2763 0060 FFF7FEFF 		bl	vPortEnterCritical
 2764              	.LBB12:
2320:..\FreeRTOS\Source/queue.c ****     {
2321:..\FreeRTOS\Source/queue.c ****         int8_t cRxLock = pxQueue->cRxLock;
 2765              		.loc 1 2321 0
 2766 0064 0E23     		movs	r3, #14
 2767 0066 FB18     		adds	r3, r7, r3
 2768 0068 7A68     		ldr	r2, [r7, #4]
 2769 006a 4421     		movs	r1, #68
 2770 006c 525C     		ldrb	r2, [r2, r1]
 2771 006e 1A70     		strb	r2, [r3]
2322:..\FreeRTOS\Source/queue.c **** 
2323:..\FreeRTOS\Source/queue.c ****         while( cRxLock > queueLOCKED_UNMODIFIED )
 2772              		.loc 1 2323 0
 2773 0070 14E0     		b	.L283
 2774              	.L287:
2324:..\FreeRTOS\Source/queue.c ****         {
2325:..\FreeRTOS\Source/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2775              		.loc 1 2325 0
 2776 0072 7B68     		ldr	r3, [r7, #4]
 2777 0074 1B69     		ldr	r3, [r3, #16]
 2778 0076 002B     		cmp	r3, #0
 2779 0078 17D0     		beq	.L289
2326:..\FreeRTOS\Source/queue.c ****             {
2327:..\FreeRTOS\Source/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2780              		.loc 1 2327 0
 2781 007a 7B68     		ldr	r3, [r7, #4]
 2782 007c 1033     		adds	r3, r3, #16
 2783 007e 1800     		movs	r0, r3
 2784 0080 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2785 0084 031E     		subs	r3, r0, #0
 2786 0086 01D0     		beq	.L285
2328:..\FreeRTOS\Source/queue.c ****                 {
2329:..\FreeRTOS\Source/queue.c ****                     vTaskMissedYield();
 2787              		.loc 1 2329 0
 2788 0088 FFF7FEFF 		bl	vTaskMissedYield
 2789              	.L285:
2330:..\FreeRTOS\Source/queue.c ****                 }
2331:..\FreeRTOS\Source/queue.c ****                 else
2332:..\FreeRTOS\Source/queue.c ****                 {
2333:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2334:..\FreeRTOS\Source/queue.c ****                 }
2335:..\FreeRTOS\Source/queue.c **** 
2336:..\FreeRTOS\Source/queue.c ****                 --cRxLock;
 2790              		.loc 1 2336 0
 2791 008c 0E23     		movs	r3, #14
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 91


 2792 008e FB18     		adds	r3, r7, r3
 2793 0090 1B78     		ldrb	r3, [r3]
 2794 0092 013B     		subs	r3, r3, #1
 2795 0094 DAB2     		uxtb	r2, r3
 2796 0096 0E23     		movs	r3, #14
 2797 0098 FB18     		adds	r3, r7, r3
 2798 009a 1A70     		strb	r2, [r3]
 2799              	.L283:
2323:..\FreeRTOS\Source/queue.c ****         {
 2800              		.loc 1 2323 0
 2801 009c 0E23     		movs	r3, #14
 2802 009e FB18     		adds	r3, r7, r3
 2803 00a0 1B78     		ldrb	r3, [r3]
 2804 00a2 5BB2     		sxtb	r3, r3
 2805 00a4 002B     		cmp	r3, #0
 2806 00a6 E4DC     		bgt	.L287
 2807 00a8 00E0     		b	.L286
 2808              	.L289:
2337:..\FreeRTOS\Source/queue.c ****             }
2338:..\FreeRTOS\Source/queue.c ****             else
2339:..\FreeRTOS\Source/queue.c ****             {
2340:..\FreeRTOS\Source/queue.c ****                 break;
 2809              		.loc 1 2340 0
 2810 00aa C046     		nop
 2811              	.L286:
2341:..\FreeRTOS\Source/queue.c ****             }
2342:..\FreeRTOS\Source/queue.c ****         }
2343:..\FreeRTOS\Source/queue.c **** 
2344:..\FreeRTOS\Source/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 2812              		.loc 1 2344 0
 2813 00ac 7B68     		ldr	r3, [r7, #4]
 2814 00ae 4422     		movs	r2, #68
 2815 00b0 FF21     		movs	r1, #255
 2816 00b2 9954     		strb	r1, [r3, r2]
 2817              	.LBE12:
2345:..\FreeRTOS\Source/queue.c ****     }
2346:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL();
 2818              		.loc 1 2346 0
 2819 00b4 FFF7FEFF 		bl	vPortExitCritical
2347:..\FreeRTOS\Source/queue.c **** }
 2820              		.loc 1 2347 0
 2821 00b8 C046     		nop
 2822 00ba BD46     		mov	sp, r7
 2823 00bc 04B0     		add	sp, sp, #16
 2824              		@ sp needed
 2825 00be 80BD     		pop	{r7, pc}
 2826              		.cfi_endproc
 2827              	.LFE18:
 2828              		.size	prvUnlockQueue, .-prvUnlockQueue
 2829              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2830              		.align	2
 2831              		.code	16
 2832              		.thumb_func
 2833              		.type	prvIsQueueEmpty, %function
 2834              	prvIsQueueEmpty:
 2835              	.LFB19:
2348:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 92


2349:..\FreeRTOS\Source/queue.c **** 
2350:..\FreeRTOS\Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
2351:..\FreeRTOS\Source/queue.c **** {
 2836              		.loc 1 2351 0
 2837              		.cfi_startproc
 2838              		@ args = 0, pretend = 0, frame = 16
 2839              		@ frame_needed = 1, uses_anonymous_args = 0
 2840 0000 80B5     		push	{r7, lr}
 2841              		.cfi_def_cfa_offset 8
 2842              		.cfi_offset 7, -8
 2843              		.cfi_offset 14, -4
 2844 0002 84B0     		sub	sp, sp, #16
 2845              		.cfi_def_cfa_offset 24
 2846 0004 00AF     		add	r7, sp, #0
 2847              		.cfi_def_cfa_register 7
 2848 0006 7860     		str	r0, [r7, #4]
2352:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
2353:..\FreeRTOS\Source/queue.c **** 
2354:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();
 2849              		.loc 1 2354 0
 2850 0008 FFF7FEFF 		bl	vPortEnterCritical
2355:..\FreeRTOS\Source/queue.c ****     {
2356:..\FreeRTOS\Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2851              		.loc 1 2356 0
 2852 000c 7B68     		ldr	r3, [r7, #4]
 2853 000e 9B6B     		ldr	r3, [r3, #56]
 2854 0010 002B     		cmp	r3, #0
 2855 0012 02D1     		bne	.L291
2357:..\FreeRTOS\Source/queue.c ****         {
2358:..\FreeRTOS\Source/queue.c ****             xReturn = pdTRUE;
 2856              		.loc 1 2358 0
 2857 0014 0123     		movs	r3, #1
 2858 0016 FB60     		str	r3, [r7, #12]
 2859 0018 01E0     		b	.L292
 2860              	.L291:
2359:..\FreeRTOS\Source/queue.c ****         }
2360:..\FreeRTOS\Source/queue.c ****         else
2361:..\FreeRTOS\Source/queue.c ****         {
2362:..\FreeRTOS\Source/queue.c ****             xReturn = pdFALSE;
 2861              		.loc 1 2362 0
 2862 001a 0023     		movs	r3, #0
 2863 001c FB60     		str	r3, [r7, #12]
 2864              	.L292:
2363:..\FreeRTOS\Source/queue.c ****         }
2364:..\FreeRTOS\Source/queue.c ****     }
2365:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL();
 2865              		.loc 1 2365 0
 2866 001e FFF7FEFF 		bl	vPortExitCritical
2366:..\FreeRTOS\Source/queue.c **** 
2367:..\FreeRTOS\Source/queue.c ****     return xReturn;
 2867              		.loc 1 2367 0
 2868 0022 FB68     		ldr	r3, [r7, #12]
2368:..\FreeRTOS\Source/queue.c **** }
 2869              		.loc 1 2368 0
 2870 0024 1800     		movs	r0, r3
 2871 0026 BD46     		mov	sp, r7
 2872 0028 04B0     		add	sp, sp, #16
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 93


 2873              		@ sp needed
 2874 002a 80BD     		pop	{r7, pc}
 2875              		.cfi_endproc
 2876              	.LFE19:
 2877              		.size	prvIsQueueEmpty, .-prvIsQueueEmpty
 2878              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2879              		.align	2
 2880              		.global	xQueueIsQueueEmptyFromISR
 2881              		.code	16
 2882              		.thumb_func
 2883              		.type	xQueueIsQueueEmptyFromISR, %function
 2884              	xQueueIsQueueEmptyFromISR:
 2885              	.LFB20:
2369:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2370:..\FreeRTOS\Source/queue.c **** 
2371:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2372:..\FreeRTOS\Source/queue.c **** {
 2886              		.loc 1 2372 0
 2887              		.cfi_startproc
 2888              		@ args = 0, pretend = 0, frame = 16
 2889              		@ frame_needed = 1, uses_anonymous_args = 0
 2890 0000 80B5     		push	{r7, lr}
 2891              		.cfi_def_cfa_offset 8
 2892              		.cfi_offset 7, -8
 2893              		.cfi_offset 14, -4
 2894 0002 84B0     		sub	sp, sp, #16
 2895              		.cfi_def_cfa_offset 24
 2896 0004 00AF     		add	r7, sp, #0
 2897              		.cfi_def_cfa_register 7
 2898 0006 7860     		str	r0, [r7, #4]
2373:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
2374:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2899              		.loc 1 2374 0
 2900 0008 7B68     		ldr	r3, [r7, #4]
 2901 000a BB60     		str	r3, [r7, #8]
2375:..\FreeRTOS\Source/queue.c **** 
2376:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 2902              		.loc 1 2376 0
 2903 000c 094B     		ldr	r3, .L300
 2904 000e 1B88     		ldrh	r3, [r3]
 2905 0010 002B     		cmp	r3, #0
 2906 0012 01D1     		bne	.L295
 2907              		.loc 1 2376 0 is_stmt 0 discriminator 1
 2908              		.syntax divided
 2909              	@ 2376 "..\FreeRTOS\Source\queue.c" 1
 2910 0014 72B6     		 cpsid i 
 2911              	@ 0 "" 2
 2912              		.thumb
 2913              		.syntax unified
 2914              	.L296:
 2915 0016 FEE7     		b	.L296
 2916              	.L295:
2377:..\FreeRTOS\Source/queue.c **** 
2378:..\FreeRTOS\Source/queue.c ****     if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2917              		.loc 1 2378 0 is_stmt 1
 2918 0018 BB68     		ldr	r3, [r7, #8]
 2919 001a 9B6B     		ldr	r3, [r3, #56]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 94


 2920 001c 002B     		cmp	r3, #0
 2921 001e 02D1     		bne	.L297
2379:..\FreeRTOS\Source/queue.c ****     {
2380:..\FreeRTOS\Source/queue.c ****         xReturn = pdTRUE;
 2922              		.loc 1 2380 0
 2923 0020 0123     		movs	r3, #1
 2924 0022 FB60     		str	r3, [r7, #12]
 2925 0024 01E0     		b	.L298
 2926              	.L297:
2381:..\FreeRTOS\Source/queue.c ****     }
2382:..\FreeRTOS\Source/queue.c ****     else
2383:..\FreeRTOS\Source/queue.c ****     {
2384:..\FreeRTOS\Source/queue.c ****         xReturn = pdFALSE;
 2927              		.loc 1 2384 0
 2928 0026 0023     		movs	r3, #0
 2929 0028 FB60     		str	r3, [r7, #12]
 2930              	.L298:
2385:..\FreeRTOS\Source/queue.c ****     }
2386:..\FreeRTOS\Source/queue.c **** 
2387:..\FreeRTOS\Source/queue.c ****     return xReturn;
 2931              		.loc 1 2387 0
 2932 002a FB68     		ldr	r3, [r7, #12]
2388:..\FreeRTOS\Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2933              		.loc 1 2388 0
 2934 002c 1800     		movs	r0, r3
 2935 002e BD46     		mov	sp, r7
 2936 0030 04B0     		add	sp, sp, #16
 2937              		@ sp needed
 2938 0032 80BD     		pop	{r7, pc}
 2939              	.L301:
 2940              		.align	2
 2941              	.L300:
 2942 0034 00000000 		.word	x
 2943              		.cfi_endproc
 2944              	.LFE20:
 2945              		.size	xQueueIsQueueEmptyFromISR, .-xQueueIsQueueEmptyFromISR
 2946              		.section	.text.prvIsQueueFull,"ax",%progbits
 2947              		.align	2
 2948              		.code	16
 2949              		.thumb_func
 2950              		.type	prvIsQueueFull, %function
 2951              	prvIsQueueFull:
 2952              	.LFB21:
2389:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2390:..\FreeRTOS\Source/queue.c **** 
2391:..\FreeRTOS\Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
2392:..\FreeRTOS\Source/queue.c **** {
 2953              		.loc 1 2392 0
 2954              		.cfi_startproc
 2955              		@ args = 0, pretend = 0, frame = 16
 2956              		@ frame_needed = 1, uses_anonymous_args = 0
 2957 0000 80B5     		push	{r7, lr}
 2958              		.cfi_def_cfa_offset 8
 2959              		.cfi_offset 7, -8
 2960              		.cfi_offset 14, -4
 2961 0002 84B0     		sub	sp, sp, #16
 2962              		.cfi_def_cfa_offset 24
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 95


 2963 0004 00AF     		add	r7, sp, #0
 2964              		.cfi_def_cfa_register 7
 2965 0006 7860     		str	r0, [r7, #4]
2393:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
2394:..\FreeRTOS\Source/queue.c **** 
2395:..\FreeRTOS\Source/queue.c ****     taskENTER_CRITICAL();
 2966              		.loc 1 2395 0
 2967 0008 FFF7FEFF 		bl	vPortEnterCritical
2396:..\FreeRTOS\Source/queue.c ****     {
2397:..\FreeRTOS\Source/queue.c ****         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2968              		.loc 1 2397 0
 2969 000c 7B68     		ldr	r3, [r7, #4]
 2970 000e 9A6B     		ldr	r2, [r3, #56]
 2971 0010 7B68     		ldr	r3, [r7, #4]
 2972 0012 DB6B     		ldr	r3, [r3, #60]
 2973 0014 9A42     		cmp	r2, r3
 2974 0016 02D1     		bne	.L303
2398:..\FreeRTOS\Source/queue.c ****         {
2399:..\FreeRTOS\Source/queue.c ****             xReturn = pdTRUE;
 2975              		.loc 1 2399 0
 2976 0018 0123     		movs	r3, #1
 2977 001a FB60     		str	r3, [r7, #12]
 2978 001c 01E0     		b	.L304
 2979              	.L303:
2400:..\FreeRTOS\Source/queue.c ****         }
2401:..\FreeRTOS\Source/queue.c ****         else
2402:..\FreeRTOS\Source/queue.c ****         {
2403:..\FreeRTOS\Source/queue.c ****             xReturn = pdFALSE;
 2980              		.loc 1 2403 0
 2981 001e 0023     		movs	r3, #0
 2982 0020 FB60     		str	r3, [r7, #12]
 2983              	.L304:
2404:..\FreeRTOS\Source/queue.c ****         }
2405:..\FreeRTOS\Source/queue.c ****     }
2406:..\FreeRTOS\Source/queue.c ****     taskEXIT_CRITICAL();
 2984              		.loc 1 2406 0
 2985 0022 FFF7FEFF 		bl	vPortExitCritical
2407:..\FreeRTOS\Source/queue.c **** 
2408:..\FreeRTOS\Source/queue.c ****     return xReturn;
 2986              		.loc 1 2408 0
 2987 0026 FB68     		ldr	r3, [r7, #12]
2409:..\FreeRTOS\Source/queue.c **** }
 2988              		.loc 1 2409 0
 2989 0028 1800     		movs	r0, r3
 2990 002a BD46     		mov	sp, r7
 2991 002c 04B0     		add	sp, sp, #16
 2992              		@ sp needed
 2993 002e 80BD     		pop	{r7, pc}
 2994              		.cfi_endproc
 2995              	.LFE21:
 2996              		.size	prvIsQueueFull, .-prvIsQueueFull
 2997              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2998              		.align	2
 2999              		.global	xQueueIsQueueFullFromISR
 3000              		.code	16
 3001              		.thumb_func
 3002              		.type	xQueueIsQueueFullFromISR, %function
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 96


 3003              	xQueueIsQueueFullFromISR:
 3004              	.LFB22:
2410:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2411:..\FreeRTOS\Source/queue.c **** 
2412:..\FreeRTOS\Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2413:..\FreeRTOS\Source/queue.c **** {
 3005              		.loc 1 2413 0
 3006              		.cfi_startproc
 3007              		@ args = 0, pretend = 0, frame = 16
 3008              		@ frame_needed = 1, uses_anonymous_args = 0
 3009 0000 80B5     		push	{r7, lr}
 3010              		.cfi_def_cfa_offset 8
 3011              		.cfi_offset 7, -8
 3012              		.cfi_offset 14, -4
 3013 0002 84B0     		sub	sp, sp, #16
 3014              		.cfi_def_cfa_offset 24
 3015 0004 00AF     		add	r7, sp, #0
 3016              		.cfi_def_cfa_register 7
 3017 0006 7860     		str	r0, [r7, #4]
2414:..\FreeRTOS\Source/queue.c ****     BaseType_t xReturn;
2415:..\FreeRTOS\Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3018              		.loc 1 2415 0
 3019 0008 7B68     		ldr	r3, [r7, #4]
 3020 000a BB60     		str	r3, [r7, #8]
2416:..\FreeRTOS\Source/queue.c **** 
2417:..\FreeRTOS\Source/queue.c ****     configASSERT( pxQueue );
 3021              		.loc 1 2417 0
 3022 000c 0A4B     		ldr	r3, .L312
 3023 000e 1B88     		ldrh	r3, [r3]
 3024 0010 002B     		cmp	r3, #0
 3025 0012 01D1     		bne	.L307
 3026              		.loc 1 2417 0 is_stmt 0 discriminator 1
 3027              		.syntax divided
 3028              	@ 2417 "..\FreeRTOS\Source\queue.c" 1
 3029 0014 72B6     		 cpsid i 
 3030              	@ 0 "" 2
 3031              		.thumb
 3032              		.syntax unified
 3033              	.L308:
 3034 0016 FEE7     		b	.L308
 3035              	.L307:
2418:..\FreeRTOS\Source/queue.c **** 
2419:..\FreeRTOS\Source/queue.c ****     if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 3036              		.loc 1 2419 0 is_stmt 1
 3037 0018 BB68     		ldr	r3, [r7, #8]
 3038 001a 9A6B     		ldr	r2, [r3, #56]
 3039 001c BB68     		ldr	r3, [r7, #8]
 3040 001e DB6B     		ldr	r3, [r3, #60]
 3041 0020 9A42     		cmp	r2, r3
 3042 0022 02D1     		bne	.L309
2420:..\FreeRTOS\Source/queue.c ****     {
2421:..\FreeRTOS\Source/queue.c ****         xReturn = pdTRUE;
 3043              		.loc 1 2421 0
 3044 0024 0123     		movs	r3, #1
 3045 0026 FB60     		str	r3, [r7, #12]
 3046 0028 01E0     		b	.L310
 3047              	.L309:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 97


2422:..\FreeRTOS\Source/queue.c ****     }
2423:..\FreeRTOS\Source/queue.c ****     else
2424:..\FreeRTOS\Source/queue.c ****     {
2425:..\FreeRTOS\Source/queue.c ****         xReturn = pdFALSE;
 3048              		.loc 1 2425 0
 3049 002a 0023     		movs	r3, #0
 3050 002c FB60     		str	r3, [r7, #12]
 3051              	.L310:
2426:..\FreeRTOS\Source/queue.c ****     }
2427:..\FreeRTOS\Source/queue.c **** 
2428:..\FreeRTOS\Source/queue.c ****     return xReturn;
 3052              		.loc 1 2428 0
 3053 002e FB68     		ldr	r3, [r7, #12]
2429:..\FreeRTOS\Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3054              		.loc 1 2429 0
 3055 0030 1800     		movs	r0, r3
 3056 0032 BD46     		mov	sp, r7
 3057 0034 04B0     		add	sp, sp, #16
 3058              		@ sp needed
 3059 0036 80BD     		pop	{r7, pc}
 3060              	.L313:
 3061              		.align	2
 3062              	.L312:
 3063 0038 00000000 		.word	x
 3064              		.cfi_endproc
 3065              	.LFE22:
 3066              		.size	xQueueIsQueueFullFromISR, .-xQueueIsQueueFullFromISR
 3067              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 3068              		.align	2
 3069              		.global	vQueueAddToRegistry
 3070              		.code	16
 3071              		.thumb_func
 3072              		.type	vQueueAddToRegistry, %function
 3073              	vQueueAddToRegistry:
 3074              	.LFB23:
2430:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2431:..\FreeRTOS\Source/queue.c **** 
2432:..\FreeRTOS\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2433:..\FreeRTOS\Source/queue.c **** 
2434:..\FreeRTOS\Source/queue.c ****     BaseType_t xQueueCRSend( QueueHandle_t xQueue,
2435:..\FreeRTOS\Source/queue.c ****                              const void * pvItemToQueue,
2436:..\FreeRTOS\Source/queue.c ****                              TickType_t xTicksToWait )
2437:..\FreeRTOS\Source/queue.c ****     {
2438:..\FreeRTOS\Source/queue.c ****         BaseType_t xReturn;
2439:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2440:..\FreeRTOS\Source/queue.c **** 
2441:..\FreeRTOS\Source/queue.c ****         /* If the queue is already full we may have to block.  A critical section
2442:..\FreeRTOS\Source/queue.c ****          * is required to prevent an interrupt removing something from the queue
2443:..\FreeRTOS\Source/queue.c ****          * between the check to see if the queue is full and blocking on the queue. */
2444:..\FreeRTOS\Source/queue.c ****         portDISABLE_INTERRUPTS();
2445:..\FreeRTOS\Source/queue.c ****         {
2446:..\FreeRTOS\Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
2447:..\FreeRTOS\Source/queue.c ****             {
2448:..\FreeRTOS\Source/queue.c ****                 /* The queue is full - do we want to block or just leave without
2449:..\FreeRTOS\Source/queue.c ****                  * posting? */
2450:..\FreeRTOS\Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2451:..\FreeRTOS\Source/queue.c ****                 {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 98


2452:..\FreeRTOS\Source/queue.c ****                     /* As this is called from a coroutine we cannot block directly, but
2453:..\FreeRTOS\Source/queue.c ****                      * return indicating that we need to block. */
2454:..\FreeRTOS\Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2455:..\FreeRTOS\Source/queue.c ****                     portENABLE_INTERRUPTS();
2456:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_BLOCKED;
2457:..\FreeRTOS\Source/queue.c ****                 }
2458:..\FreeRTOS\Source/queue.c ****                 else
2459:..\FreeRTOS\Source/queue.c ****                 {
2460:..\FreeRTOS\Source/queue.c ****                     portENABLE_INTERRUPTS();
2461:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_FULL;
2462:..\FreeRTOS\Source/queue.c ****                 }
2463:..\FreeRTOS\Source/queue.c ****             }
2464:..\FreeRTOS\Source/queue.c ****         }
2465:..\FreeRTOS\Source/queue.c ****         portENABLE_INTERRUPTS();
2466:..\FreeRTOS\Source/queue.c **** 
2467:..\FreeRTOS\Source/queue.c ****         portDISABLE_INTERRUPTS();
2468:..\FreeRTOS\Source/queue.c ****         {
2469:..\FreeRTOS\Source/queue.c ****             if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2470:..\FreeRTOS\Source/queue.c ****             {
2471:..\FreeRTOS\Source/queue.c ****                 /* There is room in the queue, copy the data into the queue. */
2472:..\FreeRTOS\Source/queue.c ****                 prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2473:..\FreeRTOS\Source/queue.c ****                 xReturn = pdPASS;
2474:..\FreeRTOS\Source/queue.c **** 
2475:..\FreeRTOS\Source/queue.c ****                 /* Were any co-routines waiting for data to become available? */
2476:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2477:..\FreeRTOS\Source/queue.c ****                 {
2478:..\FreeRTOS\Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2479:..\FreeRTOS\Source/queue.c ****                      * into the ready list as we are within a critical section.
2480:..\FreeRTOS\Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2481:..\FreeRTOS\Source/queue.c ****                      * the event were caused from within an interrupt. */
2482:..\FreeRTOS\Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2483:..\FreeRTOS\Source/queue.c ****                     {
2484:..\FreeRTOS\Source/queue.c ****                         /* The co-routine waiting has a higher priority so record
2485:..\FreeRTOS\Source/queue.c ****                          * that a yield might be appropriate. */
2486:..\FreeRTOS\Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2487:..\FreeRTOS\Source/queue.c ****                     }
2488:..\FreeRTOS\Source/queue.c ****                     else
2489:..\FreeRTOS\Source/queue.c ****                     {
2490:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2491:..\FreeRTOS\Source/queue.c ****                     }
2492:..\FreeRTOS\Source/queue.c ****                 }
2493:..\FreeRTOS\Source/queue.c ****                 else
2494:..\FreeRTOS\Source/queue.c ****                 {
2495:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2496:..\FreeRTOS\Source/queue.c ****                 }
2497:..\FreeRTOS\Source/queue.c ****             }
2498:..\FreeRTOS\Source/queue.c ****             else
2499:..\FreeRTOS\Source/queue.c ****             {
2500:..\FreeRTOS\Source/queue.c ****                 xReturn = errQUEUE_FULL;
2501:..\FreeRTOS\Source/queue.c ****             }
2502:..\FreeRTOS\Source/queue.c ****         }
2503:..\FreeRTOS\Source/queue.c ****         portENABLE_INTERRUPTS();
2504:..\FreeRTOS\Source/queue.c **** 
2505:..\FreeRTOS\Source/queue.c ****         return xReturn;
2506:..\FreeRTOS\Source/queue.c ****     }
2507:..\FreeRTOS\Source/queue.c **** 
2508:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 99


2509:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2510:..\FreeRTOS\Source/queue.c **** 
2511:..\FreeRTOS\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2512:..\FreeRTOS\Source/queue.c **** 
2513:..\FreeRTOS\Source/queue.c ****     BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
2514:..\FreeRTOS\Source/queue.c ****                                 void * pvBuffer,
2515:..\FreeRTOS\Source/queue.c ****                                 TickType_t xTicksToWait )
2516:..\FreeRTOS\Source/queue.c ****     {
2517:..\FreeRTOS\Source/queue.c ****         BaseType_t xReturn;
2518:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2519:..\FreeRTOS\Source/queue.c **** 
2520:..\FreeRTOS\Source/queue.c ****         /* If the queue is already empty we may have to block.  A critical section
2521:..\FreeRTOS\Source/queue.c ****          * is required to prevent an interrupt adding something to the queue
2522:..\FreeRTOS\Source/queue.c ****          * between the check to see if the queue is empty and blocking on the queue. */
2523:..\FreeRTOS\Source/queue.c ****         portDISABLE_INTERRUPTS();
2524:..\FreeRTOS\Source/queue.c ****         {
2525:..\FreeRTOS\Source/queue.c ****             if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2526:..\FreeRTOS\Source/queue.c ****             {
2527:..\FreeRTOS\Source/queue.c ****                 /* There are no messages in the queue, do we want to block or just
2528:..\FreeRTOS\Source/queue.c ****                  * leave with nothing? */
2529:..\FreeRTOS\Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2530:..\FreeRTOS\Source/queue.c ****                 {
2531:..\FreeRTOS\Source/queue.c ****                     /* As this is a co-routine we cannot block directly, but return
2532:..\FreeRTOS\Source/queue.c ****                      * indicating that we need to block. */
2533:..\FreeRTOS\Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) 
2534:..\FreeRTOS\Source/queue.c ****                     portENABLE_INTERRUPTS();
2535:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_BLOCKED;
2536:..\FreeRTOS\Source/queue.c ****                 }
2537:..\FreeRTOS\Source/queue.c ****                 else
2538:..\FreeRTOS\Source/queue.c ****                 {
2539:..\FreeRTOS\Source/queue.c ****                     portENABLE_INTERRUPTS();
2540:..\FreeRTOS\Source/queue.c ****                     return errQUEUE_FULL;
2541:..\FreeRTOS\Source/queue.c ****                 }
2542:..\FreeRTOS\Source/queue.c ****             }
2543:..\FreeRTOS\Source/queue.c ****             else
2544:..\FreeRTOS\Source/queue.c ****             {
2545:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2546:..\FreeRTOS\Source/queue.c ****             }
2547:..\FreeRTOS\Source/queue.c ****         }
2548:..\FreeRTOS\Source/queue.c ****         portENABLE_INTERRUPTS();
2549:..\FreeRTOS\Source/queue.c **** 
2550:..\FreeRTOS\Source/queue.c ****         portDISABLE_INTERRUPTS();
2551:..\FreeRTOS\Source/queue.c ****         {
2552:..\FreeRTOS\Source/queue.c ****             if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2553:..\FreeRTOS\Source/queue.c ****             {
2554:..\FreeRTOS\Source/queue.c ****                 /* Data is available from the queue. */
2555:..\FreeRTOS\Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2556:..\FreeRTOS\Source/queue.c **** 
2557:..\FreeRTOS\Source/queue.c ****                 if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2558:..\FreeRTOS\Source/queue.c ****                 {
2559:..\FreeRTOS\Source/queue.c ****                     pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2560:..\FreeRTOS\Source/queue.c ****                 }
2561:..\FreeRTOS\Source/queue.c ****                 else
2562:..\FreeRTOS\Source/queue.c ****                 {
2563:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2564:..\FreeRTOS\Source/queue.c ****                 }
2565:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 100


2566:..\FreeRTOS\Source/queue.c ****                 --( pxQueue->uxMessagesWaiting );
2567:..\FreeRTOS\Source/queue.c ****                 ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( un
2568:..\FreeRTOS\Source/queue.c **** 
2569:..\FreeRTOS\Source/queue.c ****                 xReturn = pdPASS;
2570:..\FreeRTOS\Source/queue.c **** 
2571:..\FreeRTOS\Source/queue.c ****                 /* Were any co-routines waiting for space to become available? */
2572:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2573:..\FreeRTOS\Source/queue.c ****                 {
2574:..\FreeRTOS\Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2575:..\FreeRTOS\Source/queue.c ****                      * into the ready list as we are within a critical section.
2576:..\FreeRTOS\Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2577:..\FreeRTOS\Source/queue.c ****                      * the event were caused from within an interrupt. */
2578:..\FreeRTOS\Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2579:..\FreeRTOS\Source/queue.c ****                     {
2580:..\FreeRTOS\Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2581:..\FreeRTOS\Source/queue.c ****                     }
2582:..\FreeRTOS\Source/queue.c ****                     else
2583:..\FreeRTOS\Source/queue.c ****                     {
2584:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2585:..\FreeRTOS\Source/queue.c ****                     }
2586:..\FreeRTOS\Source/queue.c ****                 }
2587:..\FreeRTOS\Source/queue.c ****                 else
2588:..\FreeRTOS\Source/queue.c ****                 {
2589:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2590:..\FreeRTOS\Source/queue.c ****                 }
2591:..\FreeRTOS\Source/queue.c ****             }
2592:..\FreeRTOS\Source/queue.c ****             else
2593:..\FreeRTOS\Source/queue.c ****             {
2594:..\FreeRTOS\Source/queue.c ****                 xReturn = pdFAIL;
2595:..\FreeRTOS\Source/queue.c ****             }
2596:..\FreeRTOS\Source/queue.c ****         }
2597:..\FreeRTOS\Source/queue.c ****         portENABLE_INTERRUPTS();
2598:..\FreeRTOS\Source/queue.c **** 
2599:..\FreeRTOS\Source/queue.c ****         return xReturn;
2600:..\FreeRTOS\Source/queue.c ****     }
2601:..\FreeRTOS\Source/queue.c **** 
2602:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2603:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2604:..\FreeRTOS\Source/queue.c **** 
2605:..\FreeRTOS\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2606:..\FreeRTOS\Source/queue.c **** 
2607:..\FreeRTOS\Source/queue.c ****     BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
2608:..\FreeRTOS\Source/queue.c ****                                     const void * pvItemToQueue,
2609:..\FreeRTOS\Source/queue.c ****                                     BaseType_t xCoRoutinePreviouslyWoken )
2610:..\FreeRTOS\Source/queue.c ****     {
2611:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2612:..\FreeRTOS\Source/queue.c **** 
2613:..\FreeRTOS\Source/queue.c ****         /* Cannot block within an ISR so if there is no space on the queue then
2614:..\FreeRTOS\Source/queue.c ****          * exit without doing anything. */
2615:..\FreeRTOS\Source/queue.c ****         if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2616:..\FreeRTOS\Source/queue.c ****         {
2617:..\FreeRTOS\Source/queue.c ****             prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2618:..\FreeRTOS\Source/queue.c **** 
2619:..\FreeRTOS\Source/queue.c ****             /* We only want to wake one co-routine per ISR, so check that a
2620:..\FreeRTOS\Source/queue.c ****              * co-routine has not already been woken. */
2621:..\FreeRTOS\Source/queue.c ****             if( xCoRoutinePreviouslyWoken == pdFALSE )
2622:..\FreeRTOS\Source/queue.c ****             {
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 101


2623:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2624:..\FreeRTOS\Source/queue.c ****                 {
2625:..\FreeRTOS\Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2626:..\FreeRTOS\Source/queue.c ****                     {
2627:..\FreeRTOS\Source/queue.c ****                         return pdTRUE;
2628:..\FreeRTOS\Source/queue.c ****                     }
2629:..\FreeRTOS\Source/queue.c ****                     else
2630:..\FreeRTOS\Source/queue.c ****                     {
2631:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2632:..\FreeRTOS\Source/queue.c ****                     }
2633:..\FreeRTOS\Source/queue.c ****                 }
2634:..\FreeRTOS\Source/queue.c ****                 else
2635:..\FreeRTOS\Source/queue.c ****                 {
2636:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2637:..\FreeRTOS\Source/queue.c ****                 }
2638:..\FreeRTOS\Source/queue.c ****             }
2639:..\FreeRTOS\Source/queue.c ****             else
2640:..\FreeRTOS\Source/queue.c ****             {
2641:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2642:..\FreeRTOS\Source/queue.c ****             }
2643:..\FreeRTOS\Source/queue.c ****         }
2644:..\FreeRTOS\Source/queue.c ****         else
2645:..\FreeRTOS\Source/queue.c ****         {
2646:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2647:..\FreeRTOS\Source/queue.c ****         }
2648:..\FreeRTOS\Source/queue.c **** 
2649:..\FreeRTOS\Source/queue.c ****         return xCoRoutinePreviouslyWoken;
2650:..\FreeRTOS\Source/queue.c ****     }
2651:..\FreeRTOS\Source/queue.c **** 
2652:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2653:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2654:..\FreeRTOS\Source/queue.c **** 
2655:..\FreeRTOS\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2656:..\FreeRTOS\Source/queue.c **** 
2657:..\FreeRTOS\Source/queue.c ****     BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
2658:..\FreeRTOS\Source/queue.c ****                                        void * pvBuffer,
2659:..\FreeRTOS\Source/queue.c ****                                        BaseType_t * pxCoRoutineWoken )
2660:..\FreeRTOS\Source/queue.c ****     {
2661:..\FreeRTOS\Source/queue.c ****         BaseType_t xReturn;
2662:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2663:..\FreeRTOS\Source/queue.c **** 
2664:..\FreeRTOS\Source/queue.c ****         /* We cannot block from an ISR, so check there is data available. If
2665:..\FreeRTOS\Source/queue.c ****          * not then just leave without doing anything. */
2666:..\FreeRTOS\Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2667:..\FreeRTOS\Source/queue.c ****         {
2668:..\FreeRTOS\Source/queue.c ****             /* Copy the data from the queue. */
2669:..\FreeRTOS\Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2670:..\FreeRTOS\Source/queue.c **** 
2671:..\FreeRTOS\Source/queue.c ****             if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2672:..\FreeRTOS\Source/queue.c ****             {
2673:..\FreeRTOS\Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2674:..\FreeRTOS\Source/queue.c ****             }
2675:..\FreeRTOS\Source/queue.c ****             else
2676:..\FreeRTOS\Source/queue.c ****             {
2677:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2678:..\FreeRTOS\Source/queue.c ****             }
2679:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 102


2680:..\FreeRTOS\Source/queue.c ****             --( pxQueue->uxMessagesWaiting );
2681:..\FreeRTOS\Source/queue.c ****             ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsign
2682:..\FreeRTOS\Source/queue.c **** 
2683:..\FreeRTOS\Source/queue.c ****             if( ( *pxCoRoutineWoken ) == pdFALSE )
2684:..\FreeRTOS\Source/queue.c ****             {
2685:..\FreeRTOS\Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2686:..\FreeRTOS\Source/queue.c ****                 {
2687:..\FreeRTOS\Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2688:..\FreeRTOS\Source/queue.c ****                     {
2689:..\FreeRTOS\Source/queue.c ****                         *pxCoRoutineWoken = pdTRUE;
2690:..\FreeRTOS\Source/queue.c ****                     }
2691:..\FreeRTOS\Source/queue.c ****                     else
2692:..\FreeRTOS\Source/queue.c ****                     {
2693:..\FreeRTOS\Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2694:..\FreeRTOS\Source/queue.c ****                     }
2695:..\FreeRTOS\Source/queue.c ****                 }
2696:..\FreeRTOS\Source/queue.c ****                 else
2697:..\FreeRTOS\Source/queue.c ****                 {
2698:..\FreeRTOS\Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2699:..\FreeRTOS\Source/queue.c ****                 }
2700:..\FreeRTOS\Source/queue.c ****             }
2701:..\FreeRTOS\Source/queue.c ****             else
2702:..\FreeRTOS\Source/queue.c ****             {
2703:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2704:..\FreeRTOS\Source/queue.c ****             }
2705:..\FreeRTOS\Source/queue.c **** 
2706:..\FreeRTOS\Source/queue.c ****             xReturn = pdPASS;
2707:..\FreeRTOS\Source/queue.c ****         }
2708:..\FreeRTOS\Source/queue.c ****         else
2709:..\FreeRTOS\Source/queue.c ****         {
2710:..\FreeRTOS\Source/queue.c ****             xReturn = pdFAIL;
2711:..\FreeRTOS\Source/queue.c ****         }
2712:..\FreeRTOS\Source/queue.c **** 
2713:..\FreeRTOS\Source/queue.c ****         return xReturn;
2714:..\FreeRTOS\Source/queue.c ****     }
2715:..\FreeRTOS\Source/queue.c **** 
2716:..\FreeRTOS\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2717:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2718:..\FreeRTOS\Source/queue.c **** 
2719:..\FreeRTOS\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2720:..\FreeRTOS\Source/queue.c **** 
2721:..\FreeRTOS\Source/queue.c ****     void vQueueAddToRegistry( QueueHandle_t xQueue,
2722:..\FreeRTOS\Source/queue.c ****                               const char * pcQueueName ) /*lint !e971 Unqualified char types are al
2723:..\FreeRTOS\Source/queue.c ****     {
 3075              		.loc 1 2723 0
 3076              		.cfi_startproc
 3077              		@ args = 0, pretend = 0, frame = 16
 3078              		@ frame_needed = 1, uses_anonymous_args = 0
 3079 0000 80B5     		push	{r7, lr}
 3080              		.cfi_def_cfa_offset 8
 3081              		.cfi_offset 7, -8
 3082              		.cfi_offset 14, -4
 3083 0002 84B0     		sub	sp, sp, #16
 3084              		.cfi_def_cfa_offset 24
 3085 0004 00AF     		add	r7, sp, #0
 3086              		.cfi_def_cfa_register 7
 3087 0006 7860     		str	r0, [r7, #4]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 103


 3088 0008 3960     		str	r1, [r7]
2724:..\FreeRTOS\Source/queue.c ****         UBaseType_t ux;
2725:..\FreeRTOS\Source/queue.c **** 
2726:..\FreeRTOS\Source/queue.c ****         /* See if there is an empty space in the registry.  A NULL name denotes
2727:..\FreeRTOS\Source/queue.c ****          * a free slot. */
2728:..\FreeRTOS\Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3089              		.loc 1 2728 0
 3090 000a 0023     		movs	r3, #0
 3091 000c FB60     		str	r3, [r7, #12]
 3092 000e 15E0     		b	.L315
 3093              	.L318:
2729:..\FreeRTOS\Source/queue.c ****         {
2730:..\FreeRTOS\Source/queue.c ****             if( xQueueRegistry[ ux ].pcQueueName == NULL )
 3094              		.loc 1 2730 0
 3095 0010 0E4B     		ldr	r3, .L319
 3096 0012 FA68     		ldr	r2, [r7, #12]
 3097 0014 D200     		lsls	r2, r2, #3
 3098 0016 D358     		ldr	r3, [r2, r3]
 3099 0018 002B     		cmp	r3, #0
 3100 001a 0CD1     		bne	.L316
2731:..\FreeRTOS\Source/queue.c ****             {
2732:..\FreeRTOS\Source/queue.c ****                 /* Store the information on this queue. */
2733:..\FreeRTOS\Source/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 3101              		.loc 1 2733 0
 3102 001c 0B4B     		ldr	r3, .L319
 3103 001e FA68     		ldr	r2, [r7, #12]
 3104 0020 D200     		lsls	r2, r2, #3
 3105 0022 3968     		ldr	r1, [r7]
 3106 0024 D150     		str	r1, [r2, r3]
2734:..\FreeRTOS\Source/queue.c ****                 xQueueRegistry[ ux ].xHandle = xQueue;
 3107              		.loc 1 2734 0
 3108 0026 094A     		ldr	r2, .L319
 3109 0028 FB68     		ldr	r3, [r7, #12]
 3110 002a DB00     		lsls	r3, r3, #3
 3111 002c D318     		adds	r3, r2, r3
 3112 002e 0433     		adds	r3, r3, #4
 3113 0030 7A68     		ldr	r2, [r7, #4]
 3114 0032 1A60     		str	r2, [r3]
2735:..\FreeRTOS\Source/queue.c **** 
2736:..\FreeRTOS\Source/queue.c ****                 traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2737:..\FreeRTOS\Source/queue.c ****                 break;
 3115              		.loc 1 2737 0
 3116 0034 05E0     		b	.L317
 3117              	.L316:
2728:..\FreeRTOS\Source/queue.c ****         {
 3118              		.loc 1 2728 0 discriminator 2
 3119 0036 FB68     		ldr	r3, [r7, #12]
 3120 0038 0133     		adds	r3, r3, #1
 3121 003a FB60     		str	r3, [r7, #12]
 3122              	.L315:
2728:..\FreeRTOS\Source/queue.c ****         {
 3123              		.loc 1 2728 0 is_stmt 0 discriminator 1
 3124 003c FB68     		ldr	r3, [r7, #12]
 3125 003e 092B     		cmp	r3, #9
 3126 0040 E6D9     		bls	.L318
 3127              	.L317:
2738:..\FreeRTOS\Source/queue.c ****             }
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 104


2739:..\FreeRTOS\Source/queue.c ****             else
2740:..\FreeRTOS\Source/queue.c ****             {
2741:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2742:..\FreeRTOS\Source/queue.c ****             }
2743:..\FreeRTOS\Source/queue.c ****         }
2744:..\FreeRTOS\Source/queue.c ****     }
 3128              		.loc 1 2744 0 is_stmt 1
 3129 0042 C046     		nop
 3130 0044 BD46     		mov	sp, r7
 3131 0046 04B0     		add	sp, sp, #16
 3132              		@ sp needed
 3133 0048 80BD     		pop	{r7, pc}
 3134              	.L320:
 3135 004a C046     		.align	2
 3136              	.L319:
 3137 004c 00000000 		.word	xQueueRegistry
 3138              		.cfi_endproc
 3139              	.LFE23:
 3140              		.size	vQueueAddToRegistry, .-vQueueAddToRegistry
 3141              		.section	.text.pcQueueGetName,"ax",%progbits
 3142              		.align	2
 3143              		.global	pcQueueGetName
 3144              		.code	16
 3145              		.thumb_func
 3146              		.type	pcQueueGetName, %function
 3147              	pcQueueGetName:
 3148              	.LFB24:
2745:..\FreeRTOS\Source/queue.c **** 
2746:..\FreeRTOS\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2747:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2748:..\FreeRTOS\Source/queue.c **** 
2749:..\FreeRTOS\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2750:..\FreeRTOS\Source/queue.c **** 
2751:..\FreeRTOS\Source/queue.c ****     const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are all
2752:..\FreeRTOS\Source/queue.c ****     {
 3149              		.loc 1 2752 0
 3150              		.cfi_startproc
 3151              		@ args = 0, pretend = 0, frame = 16
 3152              		@ frame_needed = 1, uses_anonymous_args = 0
 3153 0000 80B5     		push	{r7, lr}
 3154              		.cfi_def_cfa_offset 8
 3155              		.cfi_offset 7, -8
 3156              		.cfi_offset 14, -4
 3157 0002 84B0     		sub	sp, sp, #16
 3158              		.cfi_def_cfa_offset 24
 3159 0004 00AF     		add	r7, sp, #0
 3160              		.cfi_def_cfa_register 7
 3161 0006 7860     		str	r0, [r7, #4]
2753:..\FreeRTOS\Source/queue.c ****         UBaseType_t ux;
2754:..\FreeRTOS\Source/queue.c ****         const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings a
 3162              		.loc 1 2754 0
 3163 0008 0023     		movs	r3, #0
 3164 000a BB60     		str	r3, [r7, #8]
2755:..\FreeRTOS\Source/queue.c **** 
2756:..\FreeRTOS\Source/queue.c ****         /* Note there is nothing here to protect against another task adding or
2757:..\FreeRTOS\Source/queue.c ****          * removing entries from the registry while it is being searched. */
2758:..\FreeRTOS\Source/queue.c **** 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 105


2759:..\FreeRTOS\Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3165              		.loc 1 2759 0
 3166 000c 0023     		movs	r3, #0
 3167 000e FB60     		str	r3, [r7, #12]
 3168 0010 11E0     		b	.L322
 3169              	.L325:
2760:..\FreeRTOS\Source/queue.c ****         {
2761:..\FreeRTOS\Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 3170              		.loc 1 2761 0
 3171 0012 0D4A     		ldr	r2, .L327
 3172 0014 FB68     		ldr	r3, [r7, #12]
 3173 0016 DB00     		lsls	r3, r3, #3
 3174 0018 D318     		adds	r3, r2, r3
 3175 001a 0433     		adds	r3, r3, #4
 3176 001c 1A68     		ldr	r2, [r3]
 3177 001e 7B68     		ldr	r3, [r7, #4]
 3178 0020 9A42     		cmp	r2, r3
 3179 0022 05D1     		bne	.L323
2762:..\FreeRTOS\Source/queue.c ****             {
2763:..\FreeRTOS\Source/queue.c ****                 pcReturn = xQueueRegistry[ ux ].pcQueueName;
 3180              		.loc 1 2763 0
 3181 0024 084B     		ldr	r3, .L327
 3182 0026 FA68     		ldr	r2, [r7, #12]
 3183 0028 D200     		lsls	r2, r2, #3
 3184 002a D358     		ldr	r3, [r2, r3]
 3185 002c BB60     		str	r3, [r7, #8]
2764:..\FreeRTOS\Source/queue.c ****                 break;
 3186              		.loc 1 2764 0
 3187 002e 05E0     		b	.L324
 3188              	.L323:
2759:..\FreeRTOS\Source/queue.c ****         {
 3189              		.loc 1 2759 0 discriminator 2
 3190 0030 FB68     		ldr	r3, [r7, #12]
 3191 0032 0133     		adds	r3, r3, #1
 3192 0034 FB60     		str	r3, [r7, #12]
 3193              	.L322:
2759:..\FreeRTOS\Source/queue.c ****         {
 3194              		.loc 1 2759 0 is_stmt 0 discriminator 1
 3195 0036 FB68     		ldr	r3, [r7, #12]
 3196 0038 092B     		cmp	r3, #9
 3197 003a EAD9     		bls	.L325
 3198              	.L324:
2765:..\FreeRTOS\Source/queue.c ****             }
2766:..\FreeRTOS\Source/queue.c ****             else
2767:..\FreeRTOS\Source/queue.c ****             {
2768:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2769:..\FreeRTOS\Source/queue.c ****             }
2770:..\FreeRTOS\Source/queue.c ****         }
2771:..\FreeRTOS\Source/queue.c **** 
2772:..\FreeRTOS\Source/queue.c ****         return pcReturn;
 3199              		.loc 1 2772 0 is_stmt 1
 3200 003c BB68     		ldr	r3, [r7, #8]
2773:..\FreeRTOS\Source/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 3201              		.loc 1 2773 0
 3202 003e 1800     		movs	r0, r3
 3203 0040 BD46     		mov	sp, r7
 3204 0042 04B0     		add	sp, sp, #16
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 106


 3205              		@ sp needed
 3206 0044 80BD     		pop	{r7, pc}
 3207              	.L328:
 3208 0046 C046     		.align	2
 3209              	.L327:
 3210 0048 00000000 		.word	xQueueRegistry
 3211              		.cfi_endproc
 3212              	.LFE24:
 3213              		.size	pcQueueGetName, .-pcQueueGetName
 3214              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 3215              		.align	2
 3216              		.global	vQueueUnregisterQueue
 3217              		.code	16
 3218              		.thumb_func
 3219              		.type	vQueueUnregisterQueue, %function
 3220              	vQueueUnregisterQueue:
 3221              	.LFB25:
2774:..\FreeRTOS\Source/queue.c **** 
2775:..\FreeRTOS\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2776:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2777:..\FreeRTOS\Source/queue.c **** 
2778:..\FreeRTOS\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2779:..\FreeRTOS\Source/queue.c **** 
2780:..\FreeRTOS\Source/queue.c ****     void vQueueUnregisterQueue( QueueHandle_t xQueue )
2781:..\FreeRTOS\Source/queue.c ****     {
 3222              		.loc 1 2781 0
 3223              		.cfi_startproc
 3224              		@ args = 0, pretend = 0, frame = 16
 3225              		@ frame_needed = 1, uses_anonymous_args = 0
 3226 0000 80B5     		push	{r7, lr}
 3227              		.cfi_def_cfa_offset 8
 3228              		.cfi_offset 7, -8
 3229              		.cfi_offset 14, -4
 3230 0002 84B0     		sub	sp, sp, #16
 3231              		.cfi_def_cfa_offset 24
 3232 0004 00AF     		add	r7, sp, #0
 3233              		.cfi_def_cfa_register 7
 3234 0006 7860     		str	r0, [r7, #4]
2782:..\FreeRTOS\Source/queue.c ****         UBaseType_t ux;
2783:..\FreeRTOS\Source/queue.c **** 
2784:..\FreeRTOS\Source/queue.c ****         /* See if the handle of the queue being unregistered in actually in the
2785:..\FreeRTOS\Source/queue.c ****          * registry. */
2786:..\FreeRTOS\Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3235              		.loc 1 2786 0
 3236 0008 0023     		movs	r3, #0
 3237 000a FB60     		str	r3, [r7, #12]
 3238 000c 18E0     		b	.L330
 3239              	.L333:
2787:..\FreeRTOS\Source/queue.c ****         {
2788:..\FreeRTOS\Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 3240              		.loc 1 2788 0
 3241 000e 104A     		ldr	r2, .L334
 3242 0010 FB68     		ldr	r3, [r7, #12]
 3243 0012 DB00     		lsls	r3, r3, #3
 3244 0014 D318     		adds	r3, r2, r3
 3245 0016 0433     		adds	r3, r3, #4
 3246 0018 1A68     		ldr	r2, [r3]
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 107


 3247 001a 7B68     		ldr	r3, [r7, #4]
 3248 001c 9A42     		cmp	r2, r3
 3249 001e 0CD1     		bne	.L331
2789:..\FreeRTOS\Source/queue.c ****             {
2790:..\FreeRTOS\Source/queue.c ****                 /* Set the name to NULL to show that this slot if free again. */
2791:..\FreeRTOS\Source/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = NULL;
 3250              		.loc 1 2791 0
 3251 0020 0B4B     		ldr	r3, .L334
 3252 0022 FA68     		ldr	r2, [r7, #12]
 3253 0024 D200     		lsls	r2, r2, #3
 3254 0026 0021     		movs	r1, #0
 3255 0028 D150     		str	r1, [r2, r3]
2792:..\FreeRTOS\Source/queue.c **** 
2793:..\FreeRTOS\Source/queue.c ****                 /* Set the handle to NULL to ensure the same queue handle cannot
2794:..\FreeRTOS\Source/queue.c ****                  * appear in the registry twice if it is added, removed, then
2795:..\FreeRTOS\Source/queue.c ****                  * added again. */
2796:..\FreeRTOS\Source/queue.c ****                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 3256              		.loc 1 2796 0
 3257 002a 094A     		ldr	r2, .L334
 3258 002c FB68     		ldr	r3, [r7, #12]
 3259 002e DB00     		lsls	r3, r3, #3
 3260 0030 D318     		adds	r3, r2, r3
 3261 0032 0433     		adds	r3, r3, #4
 3262 0034 0022     		movs	r2, #0
 3263 0036 1A60     		str	r2, [r3]
2797:..\FreeRTOS\Source/queue.c ****                 break;
 3264              		.loc 1 2797 0
 3265 0038 05E0     		b	.L332
 3266              	.L331:
2786:..\FreeRTOS\Source/queue.c ****         {
 3267              		.loc 1 2786 0 discriminator 2
 3268 003a FB68     		ldr	r3, [r7, #12]
 3269 003c 0133     		adds	r3, r3, #1
 3270 003e FB60     		str	r3, [r7, #12]
 3271              	.L330:
2786:..\FreeRTOS\Source/queue.c ****         {
 3272              		.loc 1 2786 0 is_stmt 0 discriminator 1
 3273 0040 FB68     		ldr	r3, [r7, #12]
 3274 0042 092B     		cmp	r3, #9
 3275 0044 E3D9     		bls	.L333
 3276              	.L332:
2798:..\FreeRTOS\Source/queue.c ****             }
2799:..\FreeRTOS\Source/queue.c ****             else
2800:..\FreeRTOS\Source/queue.c ****             {
2801:..\FreeRTOS\Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2802:..\FreeRTOS\Source/queue.c ****             }
2803:..\FreeRTOS\Source/queue.c ****         }
2804:..\FreeRTOS\Source/queue.c ****     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3277              		.loc 1 2804 0 is_stmt 1
 3278 0046 C046     		nop
 3279 0048 BD46     		mov	sp, r7
 3280 004a 04B0     		add	sp, sp, #16
 3281              		@ sp needed
 3282 004c 80BD     		pop	{r7, pc}
 3283              	.L335:
 3284 004e C046     		.align	2
 3285              	.L334:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 108


 3286 0050 00000000 		.word	xQueueRegistry
 3287              		.cfi_endproc
 3288              	.LFE25:
 3289              		.size	vQueueUnregisterQueue, .-vQueueUnregisterQueue
 3290              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 3291              		.align	2
 3292              		.global	vQueueWaitForMessageRestricted
 3293              		.code	16
 3294              		.thumb_func
 3295              		.type	vQueueWaitForMessageRestricted, %function
 3296              	vQueueWaitForMessageRestricted:
 3297              	.LFB26:
2805:..\FreeRTOS\Source/queue.c **** 
2806:..\FreeRTOS\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2807:..\FreeRTOS\Source/queue.c **** /*-----------------------------------------------------------*/
2808:..\FreeRTOS\Source/queue.c **** 
2809:..\FreeRTOS\Source/queue.c **** #if ( configUSE_TIMERS == 1 )
2810:..\FreeRTOS\Source/queue.c **** 
2811:..\FreeRTOS\Source/queue.c ****     void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
2812:..\FreeRTOS\Source/queue.c ****                                          TickType_t xTicksToWait,
2813:..\FreeRTOS\Source/queue.c ****                                          const BaseType_t xWaitIndefinitely )
2814:..\FreeRTOS\Source/queue.c ****     {
 3298              		.loc 1 2814 0
 3299              		.cfi_startproc
 3300              		@ args = 0, pretend = 0, frame = 24
 3301              		@ frame_needed = 1, uses_anonymous_args = 0
 3302 0000 80B5     		push	{r7, lr}
 3303              		.cfi_def_cfa_offset 8
 3304              		.cfi_offset 7, -8
 3305              		.cfi_offset 14, -4
 3306 0002 86B0     		sub	sp, sp, #24
 3307              		.cfi_def_cfa_offset 32
 3308 0004 00AF     		add	r7, sp, #0
 3309              		.cfi_def_cfa_register 7
 3310 0006 F860     		str	r0, [r7, #12]
 3311 0008 B960     		str	r1, [r7, #8]
 3312 000a 7A60     		str	r2, [r7, #4]
2815:..\FreeRTOS\Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 3313              		.loc 1 2815 0
 3314 000c FB68     		ldr	r3, [r7, #12]
 3315 000e 7B61     		str	r3, [r7, #20]
2816:..\FreeRTOS\Source/queue.c **** 
2817:..\FreeRTOS\Source/queue.c ****         /* This function should not be called by application code hence the
2818:..\FreeRTOS\Source/queue.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
2819:..\FreeRTOS\Source/queue.c ****          * designed for use by kernel code, and has special calling requirements.
2820:..\FreeRTOS\Source/queue.c ****          * It can result in vListInsert() being called on a list that can only
2821:..\FreeRTOS\Source/queue.c ****          * possibly ever have one item in it, so the list will be fast, but even
2822:..\FreeRTOS\Source/queue.c ****          * so it should be called with the scheduler locked and not from a critical
2823:..\FreeRTOS\Source/queue.c ****          * section. */
2824:..\FreeRTOS\Source/queue.c **** 
2825:..\FreeRTOS\Source/queue.c ****         /* Only do anything if there are no messages in the queue.  This function
2826:..\FreeRTOS\Source/queue.c ****          *  will not actually cause the task to block, just place it on a blocked
2827:..\FreeRTOS\Source/queue.c ****          *  list.  It will not block until the scheduler is unlocked - at which
2828:..\FreeRTOS\Source/queue.c ****          *  time a yield will be performed.  If an item is added to the queue while
2829:..\FreeRTOS\Source/queue.c ****          *  the queue is locked, and the calling task blocks on the queue, then the
2830:..\FreeRTOS\Source/queue.c ****          *  calling task will be immediately unblocked when the queue is unlocked. */
2831:..\FreeRTOS\Source/queue.c ****         prvLockQueue( pxQueue );
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 109


 3316              		.loc 1 2831 0
 3317 0010 FFF7FEFF 		bl	vPortEnterCritical
 3318 0014 7B69     		ldr	r3, [r7, #20]
 3319 0016 4422     		movs	r2, #68
 3320 0018 9B5C     		ldrb	r3, [r3, r2]
 3321 001a 5BB2     		sxtb	r3, r3
 3322 001c 0133     		adds	r3, r3, #1
 3323 001e 03D1     		bne	.L337
 3324              		.loc 1 2831 0 is_stmt 0 discriminator 1
 3325 0020 7B69     		ldr	r3, [r7, #20]
 3326 0022 4422     		movs	r2, #68
 3327 0024 0021     		movs	r1, #0
 3328 0026 9954     		strb	r1, [r3, r2]
 3329              	.L337:
 3330              		.loc 1 2831 0 discriminator 3
 3331 0028 7B69     		ldr	r3, [r7, #20]
 3332 002a 4522     		movs	r2, #69
 3333 002c 9B5C     		ldrb	r3, [r3, r2]
 3334 002e 5BB2     		sxtb	r3, r3
 3335 0030 0133     		adds	r3, r3, #1
 3336 0032 03D1     		bne	.L338
 3337              		.loc 1 2831 0 discriminator 4
 3338 0034 7B69     		ldr	r3, [r7, #20]
 3339 0036 4522     		movs	r2, #69
 3340 0038 0021     		movs	r1, #0
 3341 003a 9954     		strb	r1, [r3, r2]
 3342              	.L338:
 3343              		.loc 1 2831 0 discriminator 6
 3344 003c FFF7FEFF 		bl	vPortExitCritical
2832:..\FreeRTOS\Source/queue.c **** 
2833:..\FreeRTOS\Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 3345              		.loc 1 2833 0 is_stmt 1 discriminator 6
 3346 0040 7B69     		ldr	r3, [r7, #20]
 3347 0042 9B6B     		ldr	r3, [r3, #56]
 3348 0044 002B     		cmp	r3, #0
 3349 0046 06D1     		bne	.L339
2834:..\FreeRTOS\Source/queue.c ****         {
2835:..\FreeRTOS\Source/queue.c ****             /* There is nothing in the queue, block for the specified period. */
2836:..\FreeRTOS\Source/queue.c ****             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xW
 3350              		.loc 1 2836 0
 3351 0048 7B69     		ldr	r3, [r7, #20]
 3352 004a 2433     		adds	r3, r3, #36
 3353 004c 7A68     		ldr	r2, [r7, #4]
 3354 004e B968     		ldr	r1, [r7, #8]
 3355 0050 1800     		movs	r0, r3
 3356 0052 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 3357              	.L339:
2837:..\FreeRTOS\Source/queue.c ****         }
2838:..\FreeRTOS\Source/queue.c ****         else
2839:..\FreeRTOS\Source/queue.c ****         {
2840:..\FreeRTOS\Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2841:..\FreeRTOS\Source/queue.c ****         }
2842:..\FreeRTOS\Source/queue.c **** 
2843:..\FreeRTOS\Source/queue.c ****         prvUnlockQueue( pxQueue );
 3358              		.loc 1 2843 0
 3359 0056 7B69     		ldr	r3, [r7, #20]
 3360 0058 1800     		movs	r0, r3
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 110


 3361 005a FFF7FEFF 		bl	prvUnlockQueue
2844:..\FreeRTOS\Source/queue.c ****     }
 3362              		.loc 1 2844 0
 3363 005e C046     		nop
 3364 0060 BD46     		mov	sp, r7
 3365 0062 06B0     		add	sp, sp, #24
 3366              		@ sp needed
 3367 0064 80BD     		pop	{r7, pc}
 3368              		.cfi_endproc
 3369              	.LFE26:
 3370              		.size	vQueueWaitForMessageRestricted, .-vQueueWaitForMessageRestricted
 3371 0066 C046     		.text
 3372              	.Letext0:
 3373              		.file 2 "d:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 3374              		.file 3 "d:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 3375              		.file 4 "d:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 3376              		.file 5 "..\\FreeRTOS\\Source\\portable\\GCC\\ARM_CM0/portmacro.h"
 3377              		.file 6 "..\\FreeRTOS\\Source\\include/FreeRTOS.h"
 3378              		.file 7 "..\\FreeRTOS\\Source\\include/list.h"
 3379              		.file 8 "..\\FreeRTOS\\Source\\include/task.h"
 3380              		.file 9 "..\\FreeRTOS\\Source\\include/queue.h"
 3381              		.file 10 "./FreeRTOSConfig.h"
 3382              		.section	.debug_info,"",%progbits
 3383              	.Ldebug_info0:
 3384 0000 DD0F0000 		.4byte	0xfdd
 3385 0004 0400     		.2byte	0x4
 3386 0006 00000000 		.4byte	.Ldebug_abbrev0
 3387 000a 04       		.byte	0x4
 3388 000b 01       		.uleb128 0x1
 3389 000c 5D010000 		.4byte	.LASF142
 3390 0010 0C       		.byte	0xc
 3391 0011 9C070000 		.4byte	.LASF143
 3392 0015 F3000000 		.4byte	.LASF144
 3393 0019 00000000 		.4byte	.Ldebug_ranges0+0
 3394 001d 00000000 		.4byte	0
 3395 0021 00000000 		.4byte	.Ldebug_line0
 3396 0025 02       		.uleb128 0x2
 3397 0026 A2030000 		.4byte	.LASF3
 3398 002a 02       		.byte	0x2
 3399 002b D8       		.byte	0xd8
 3400 002c 30000000 		.4byte	0x30
 3401 0030 03       		.uleb128 0x3
 3402 0031 04       		.byte	0x4
 3403 0032 07       		.byte	0x7
 3404 0033 AA000000 		.4byte	.LASF0
 3405 0037 04       		.uleb128 0x4
 3406 0038 04       		.byte	0x4
 3407 0039 05       		.byte	0x5
 3408 003a 696E7400 		.ascii	"int\000"
 3409 003e 03       		.uleb128 0x3
 3410 003f 08       		.byte	0x8
 3411 0040 05       		.byte	0x5
 3412 0041 5C050000 		.4byte	.LASF1
 3413 0045 03       		.uleb128 0x3
 3414 0046 08       		.byte	0x8
 3415 0047 04       		.byte	0x4
 3416 0048 45060000 		.4byte	.LASF2
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 111


 3417 004c 02       		.uleb128 0x2
 3418 004d 25060000 		.4byte	.LASF4
 3419 0051 03       		.byte	0x3
 3420 0052 1B       		.byte	0x1b
 3421 0053 57000000 		.4byte	0x57
 3422 0057 03       		.uleb128 0x3
 3423 0058 01       		.byte	0x1
 3424 0059 06       		.byte	0x6
 3425 005a 8A080000 		.4byte	.LASF5
 3426 005e 02       		.uleb128 0x2
 3427 005f 2E070000 		.4byte	.LASF6
 3428 0063 03       		.byte	0x3
 3429 0064 1D       		.byte	0x1d
 3430 0065 69000000 		.4byte	0x69
 3431 0069 03       		.uleb128 0x3
 3432 006a 01       		.byte	0x1
 3433 006b 08       		.byte	0x8
 3434 006c D5070000 		.4byte	.LASF7
 3435 0070 03       		.uleb128 0x3
 3436 0071 02       		.byte	0x2
 3437 0072 05       		.byte	0x5
 3438 0073 B9060000 		.4byte	.LASF8
 3439 0077 02       		.uleb128 0x2
 3440 0078 61030000 		.4byte	.LASF9
 3441 007c 03       		.byte	0x3
 3442 007d 2B       		.byte	0x2b
 3443 007e 82000000 		.4byte	0x82
 3444 0082 03       		.uleb128 0x3
 3445 0083 02       		.byte	0x2
 3446 0084 07       		.byte	0x7
 3447 0085 96080000 		.4byte	.LASF10
 3448 0089 03       		.uleb128 0x3
 3449 008a 04       		.byte	0x4
 3450 008b 05       		.byte	0x5
 3451 008c CE060000 		.4byte	.LASF11
 3452 0090 02       		.uleb128 0x2
 3453 0091 E3070000 		.4byte	.LASF12
 3454 0095 03       		.byte	0x3
 3455 0096 41       		.byte	0x41
 3456 0097 9B000000 		.4byte	0x9b
 3457 009b 03       		.uleb128 0x3
 3458 009c 04       		.byte	0x4
 3459 009d 07       		.byte	0x7
 3460 009e 75070000 		.4byte	.LASF13
 3461 00a2 03       		.uleb128 0x3
 3462 00a3 08       		.byte	0x8
 3463 00a4 07       		.byte	0x7
 3464 00a5 18030000 		.4byte	.LASF14
 3465 00a9 03       		.uleb128 0x3
 3466 00aa 04       		.byte	0x4
 3467 00ab 07       		.byte	0x7
 3468 00ac 6C070000 		.4byte	.LASF15
 3469 00b0 05       		.uleb128 0x5
 3470 00b1 04       		.byte	0x4
 3471 00b2 03       		.uleb128 0x3
 3472 00b3 01       		.byte	0x1
 3473 00b4 08       		.byte	0x8
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 112


 3474 00b5 82040000 		.4byte	.LASF16
 3475 00b9 06       		.uleb128 0x6
 3476 00ba 04       		.byte	0x4
 3477 00bb BF000000 		.4byte	0xbf
 3478 00bf 07       		.uleb128 0x7
 3479 00c0 B2000000 		.4byte	0xb2
 3480 00c4 06       		.uleb128 0x6
 3481 00c5 04       		.byte	0x4
 3482 00c6 CA000000 		.4byte	0xca
 3483 00ca 08       		.uleb128 0x8
 3484 00cb 02       		.uleb128 0x2
 3485 00cc EB020000 		.4byte	.LASF17
 3486 00d0 04       		.byte	0x4
 3487 00d1 14       		.byte	0x14
 3488 00d2 4C000000 		.4byte	0x4c
 3489 00d6 02       		.uleb128 0x2
 3490 00d7 20050000 		.4byte	.LASF18
 3491 00db 04       		.byte	0x4
 3492 00dc 18       		.byte	0x18
 3493 00dd 5E000000 		.4byte	0x5e
 3494 00e1 02       		.uleb128 0x2
 3495 00e2 51060000 		.4byte	.LASF19
 3496 00e6 04       		.byte	0x4
 3497 00e7 24       		.byte	0x24
 3498 00e8 77000000 		.4byte	0x77
 3499 00ec 02       		.uleb128 0x2
 3500 00ed E2020000 		.4byte	.LASF20
 3501 00f1 04       		.byte	0x4
 3502 00f2 30       		.byte	0x30
 3503 00f3 90000000 		.4byte	0x90
 3504 00f7 02       		.uleb128 0x2
 3505 00f8 6A050000 		.4byte	.LASF21
 3506 00fc 05       		.byte	0x5
 3507 00fd 38       		.byte	0x38
 3508 00fe 89000000 		.4byte	0x89
 3509 0102 02       		.uleb128 0x2
 3510 0103 AF040000 		.4byte	.LASF22
 3511 0107 05       		.byte	0x5
 3512 0108 39       		.byte	0x39
 3513 0109 9B000000 		.4byte	0x9b
 3514 010d 02       		.uleb128 0x2
 3515 010e 1A060000 		.4byte	.LASF23
 3516 0112 05       		.byte	0x5
 3517 0113 3F       		.byte	0x3f
 3518 0114 EC000000 		.4byte	0xec
 3519 0118 06       		.uleb128 0x6
 3520 0119 04       		.byte	0x4
 3521 011a D6000000 		.4byte	0xd6
 3522 011e 09       		.uleb128 0x9
 3523 011f 37080000 		.4byte	.LASF27
 3524 0123 0C       		.byte	0xc
 3525 0124 06       		.byte	0x6
 3526 0125 6704     		.2byte	0x467
 3527 0127 46010000 		.4byte	0x146
 3528 012b 0A       		.uleb128 0xa
 3529 012c 18080000 		.4byte	.LASF24
 3530 0130 06       		.byte	0x6
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 113


 3531 0131 6C04     		.2byte	0x46c
 3532 0133 0D010000 		.4byte	0x10d
 3533 0137 00       		.byte	0
 3534 0138 0A       		.uleb128 0xa
 3535 0139 07040000 		.4byte	.LASF25
 3536 013d 06       		.byte	0x6
 3537 013e 6D04     		.2byte	0x46d
 3538 0140 46010000 		.4byte	0x146
 3539 0144 04       		.byte	0x4
 3540 0145 00       		.byte	0
 3541 0146 0B       		.uleb128 0xb
 3542 0147 B0000000 		.4byte	0xb0
 3543 014b 56010000 		.4byte	0x156
 3544 014f 0C       		.uleb128 0xc
 3545 0150 A9000000 		.4byte	0xa9
 3546 0154 01       		.byte	0x1
 3547 0155 00       		.byte	0
 3548 0156 0D       		.uleb128 0xd
 3549 0157 EB010000 		.4byte	.LASF26
 3550 015b 06       		.byte	0x6
 3551 015c 6F04     		.2byte	0x46f
 3552 015e 1E010000 		.4byte	0x11e
 3553 0162 09       		.uleb128 0x9
 3554 0163 4F050000 		.4byte	.LASF28
 3555 0167 14       		.byte	0x14
 3556 0168 06       		.byte	0x6
 3557 0169 7204     		.2byte	0x472
 3558 016b 97010000 		.4byte	0x197
 3559 016f 0A       		.uleb128 0xa
 3560 0170 10040000 		.4byte	.LASF29
 3561 0174 06       		.byte	0x6
 3562 0175 7704     		.2byte	0x477
 3563 0177 02010000 		.4byte	0x102
 3564 017b 00       		.byte	0
 3565 017c 0A       		.uleb128 0xa
 3566 017d 07040000 		.4byte	.LASF25
 3567 0181 06       		.byte	0x6
 3568 0182 7804     		.2byte	0x478
 3569 0184 B0000000 		.4byte	0xb0
 3570 0188 04       		.byte	0x4
 3571 0189 0A       		.uleb128 0xa
 3572 018a 28080000 		.4byte	.LASF30
 3573 018e 06       		.byte	0x6
 3574 018f 7904     		.2byte	0x479
 3575 0191 56010000 		.4byte	0x156
 3576 0195 08       		.byte	0x8
 3577 0196 00       		.byte	0
 3578 0197 0D       		.uleb128 0xd
 3579 0198 DD080000 		.4byte	.LASF31
 3580 019c 06       		.byte	0x6
 3581 019d 7D04     		.2byte	0x47d
 3582 019f 62010000 		.4byte	0x162
 3583 01a3 0E       		.uleb128 0xe
 3584 01a4 04       		.byte	0x4
 3585 01a5 06       		.byte	0x6
 3586 01a6 D004     		.2byte	0x4d0
 3587 01a8 C5010000 		.4byte	0x1c5
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 114


 3588 01ac 0F       		.uleb128 0xf
 3589 01ad FE030000 		.4byte	.LASF32
 3590 01b1 06       		.byte	0x6
 3591 01b2 D204     		.2byte	0x4d2
 3592 01b4 B0000000 		.4byte	0xb0
 3593 01b8 0F       		.uleb128 0xf
 3594 01b9 10040000 		.4byte	.LASF29
 3595 01bd 06       		.byte	0x6
 3596 01be D304     		.2byte	0x4d3
 3597 01c0 02010000 		.4byte	0x102
 3598 01c4 00       		.byte	0
 3599 01c5 09       		.uleb128 0x9
 3600 01c6 CF080000 		.4byte	.LASF33
 3601 01ca 48       		.byte	0x48
 3602 01cb 06       		.byte	0x6
 3603 01cc CC04     		.2byte	0x4cc
 3604 01ce 1F020000 		.4byte	0x21f
 3605 01d2 0A       		.uleb128 0xa
 3606 01d3 F5030000 		.4byte	.LASF34
 3607 01d7 06       		.byte	0x6
 3608 01d8 CE04     		.2byte	0x4ce
 3609 01da 1F020000 		.4byte	0x21f
 3610 01de 00       		.byte	0
 3611 01df 10       		.uleb128 0x10
 3612 01e0 7500     		.ascii	"u\000"
 3613 01e2 06       		.byte	0x6
 3614 01e3 D404     		.2byte	0x4d4
 3615 01e5 A3010000 		.4byte	0x1a3
 3616 01e9 0C       		.byte	0xc
 3617 01ea 0A       		.uleb128 0xa
 3618 01eb 20080000 		.4byte	.LASF35
 3619 01ef 06       		.byte	0x6
 3620 01f0 D604     		.2byte	0x4d6
 3621 01f2 2F020000 		.4byte	0x22f
 3622 01f6 10       		.byte	0x10
 3623 01f7 0A       		.uleb128 0xa
 3624 01f8 19040000 		.4byte	.LASF36
 3625 01fc 06       		.byte	0x6
 3626 01fd D704     		.2byte	0x4d7
 3627 01ff 3F020000 		.4byte	0x23f
 3628 0203 38       		.byte	0x38
 3629 0204 0A       		.uleb128 0xa
 3630 0205 5A060000 		.4byte	.LASF37
 3631 0209 06       		.byte	0x6
 3632 020a D804     		.2byte	0x4d8
 3633 020c 4F020000 		.4byte	0x24f
 3634 0210 44       		.byte	0x44
 3635 0211 0A       		.uleb128 0xa
 3636 0212 63060000 		.4byte	.LASF38
 3637 0216 06       		.byte	0x6
 3638 0217 DB04     		.2byte	0x4db
 3639 0219 D6000000 		.4byte	0xd6
 3640 021d 46       		.byte	0x46
 3641 021e 00       		.byte	0
 3642 021f 0B       		.uleb128 0xb
 3643 0220 B0000000 		.4byte	0xb0
 3644 0224 2F020000 		.4byte	0x22f
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 115


 3645 0228 0C       		.uleb128 0xc
 3646 0229 A9000000 		.4byte	0xa9
 3647 022d 02       		.byte	0x2
 3648 022e 00       		.byte	0
 3649 022f 0B       		.uleb128 0xb
 3650 0230 97010000 		.4byte	0x197
 3651 0234 3F020000 		.4byte	0x23f
 3652 0238 0C       		.uleb128 0xc
 3653 0239 A9000000 		.4byte	0xa9
 3654 023d 01       		.byte	0x1
 3655 023e 00       		.byte	0
 3656 023f 0B       		.uleb128 0xb
 3657 0240 02010000 		.4byte	0x102
 3658 0244 4F020000 		.4byte	0x24f
 3659 0248 0C       		.uleb128 0xc
 3660 0249 A9000000 		.4byte	0xa9
 3661 024d 02       		.byte	0x2
 3662 024e 00       		.byte	0
 3663 024f 0B       		.uleb128 0xb
 3664 0250 D6000000 		.4byte	0xd6
 3665 0254 5F020000 		.4byte	0x25f
 3666 0258 0C       		.uleb128 0xc
 3667 0259 A9000000 		.4byte	0xa9
 3668 025d 01       		.byte	0x1
 3669 025e 00       		.byte	0
 3670 025f 0D       		.uleb128 0xd
 3671 0260 B0050000 		.4byte	.LASF39
 3672 0264 06       		.byte	0x6
 3673 0265 E604     		.2byte	0x4e6
 3674 0267 C5010000 		.4byte	0x1c5
 3675 026b 11       		.uleb128 0x11
 3676 026c D4000000 		.4byte	.LASF40
 3677 0270 14       		.byte	0x14
 3678 0271 07       		.byte	0x7
 3679 0272 8E       		.byte	0x8e
 3680 0273 B4020000 		.4byte	0x2b4
 3681 0277 12       		.uleb128 0x12
 3682 0278 C3060000 		.4byte	.LASF41
 3683 027c 07       		.byte	0x7
 3684 027d 91       		.byte	0x91
 3685 027e 0D010000 		.4byte	0x10d
 3686 0282 00       		.byte	0
 3687 0283 12       		.uleb128 0x12
 3688 0284 A9050000 		.4byte	.LASF42
 3689 0288 07       		.byte	0x7
 3690 0289 92       		.byte	0x92
 3691 028a B4020000 		.4byte	0x2b4
 3692 028e 04       		.byte	0x4
 3693 028f 12       		.uleb128 0x12
 3694 0290 56030000 		.4byte	.LASF43
 3695 0294 07       		.byte	0x7
 3696 0295 93       		.byte	0x93
 3697 0296 B4020000 		.4byte	0x2b4
 3698 029a 08       		.byte	0x8
 3699 029b 12       		.uleb128 0x12
 3700 029c 10080000 		.4byte	.LASF44
 3701 02a0 07       		.byte	0x7
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 116


 3702 02a1 94       		.byte	0x94
 3703 02a2 B0000000 		.4byte	0xb0
 3704 02a6 0C       		.byte	0xc
 3705 02a7 12       		.uleb128 0x12
 3706 02a8 C9070000 		.4byte	.LASF45
 3707 02ac 07       		.byte	0x7
 3708 02ad 95       		.byte	0x95
 3709 02ae EB020000 		.4byte	0x2eb
 3710 02b2 10       		.byte	0x10
 3711 02b3 00       		.byte	0
 3712 02b4 06       		.uleb128 0x6
 3713 02b5 04       		.byte	0x4
 3714 02b6 6B020000 		.4byte	0x26b
 3715 02ba 11       		.uleb128 0x11
 3716 02bb D6030000 		.4byte	.LASF46
 3717 02bf 14       		.byte	0x14
 3718 02c0 07       		.byte	0x7
 3719 02c1 A6       		.byte	0xa6
 3720 02c2 EB020000 		.4byte	0x2eb
 3721 02c6 12       		.uleb128 0x12
 3722 02c7 00000000 		.4byte	.LASF47
 3723 02cb 07       		.byte	0x7
 3724 02cc A9       		.byte	0xa9
 3725 02cd 38030000 		.4byte	0x338
 3726 02d1 00       		.byte	0
 3727 02d2 12       		.uleb128 0x12
 3728 02d3 B7000000 		.4byte	.LASF48
 3729 02d7 07       		.byte	0x7
 3730 02d8 AA       		.byte	0xaa
 3731 02d9 3D030000 		.4byte	0x33d
 3732 02dd 04       		.byte	0x4
 3733 02de 12       		.uleb128 0x12
 3734 02df EA040000 		.4byte	.LASF49
 3735 02e3 07       		.byte	0x7
 3736 02e4 AB       		.byte	0xab
 3737 02e5 2D030000 		.4byte	0x32d
 3738 02e9 08       		.byte	0x8
 3739 02ea 00       		.byte	0
 3740 02eb 06       		.uleb128 0x6
 3741 02ec 04       		.byte	0x4
 3742 02ed BA020000 		.4byte	0x2ba
 3743 02f1 02       		.uleb128 0x2
 3744 02f2 87040000 		.4byte	.LASF50
 3745 02f6 07       		.byte	0x7
 3746 02f7 98       		.byte	0x98
 3747 02f8 6B020000 		.4byte	0x26b
 3748 02fc 11       		.uleb128 0x11
 3749 02fd C6030000 		.4byte	.LASF51
 3750 0301 0C       		.byte	0xc
 3751 0302 07       		.byte	0x7
 3752 0303 9A       		.byte	0x9a
 3753 0304 2D030000 		.4byte	0x32d
 3754 0308 12       		.uleb128 0x12
 3755 0309 C3060000 		.4byte	.LASF41
 3756 030d 07       		.byte	0x7
 3757 030e 9D       		.byte	0x9d
 3758 030f 0D010000 		.4byte	0x10d
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 117


 3759 0313 00       		.byte	0
 3760 0314 12       		.uleb128 0x12
 3761 0315 A9050000 		.4byte	.LASF42
 3762 0319 07       		.byte	0x7
 3763 031a 9E       		.byte	0x9e
 3764 031b B4020000 		.4byte	0x2b4
 3765 031f 04       		.byte	0x4
 3766 0320 12       		.uleb128 0x12
 3767 0321 56030000 		.4byte	.LASF43
 3768 0325 07       		.byte	0x7
 3769 0326 9F       		.byte	0x9f
 3770 0327 B4020000 		.4byte	0x2b4
 3771 032b 08       		.byte	0x8
 3772 032c 00       		.byte	0
 3773 032d 02       		.uleb128 0x2
 3774 032e 11050000 		.4byte	.LASF52
 3775 0332 07       		.byte	0x7
 3776 0333 A1       		.byte	0xa1
 3777 0334 FC020000 		.4byte	0x2fc
 3778 0338 13       		.uleb128 0x13
 3779 0339 02010000 		.4byte	0x102
 3780 033d 06       		.uleb128 0x6
 3781 033e 04       		.byte	0x4
 3782 033f F1020000 		.4byte	0x2f1
 3783 0343 02       		.uleb128 0x2
 3784 0344 F8050000 		.4byte	.LASF53
 3785 0348 07       		.byte	0x7
 3786 0349 AD       		.byte	0xad
 3787 034a BA020000 		.4byte	0x2ba
 3788 034e 02       		.uleb128 0x2
 3789 034f DF050000 		.4byte	.LASF54
 3790 0353 08       		.byte	0x8
 3791 0354 4E       		.byte	0x4e
 3792 0355 59030000 		.4byte	0x359
 3793 0359 06       		.uleb128 0x6
 3794 035a 04       		.byte	0x4
 3795 035b 5F030000 		.4byte	0x35f
 3796 035f 14       		.uleb128 0x14
 3797 0360 1E000000 		.4byte	.LASF145
 3798 0364 11       		.uleb128 0x11
 3799 0365 BF000000 		.4byte	.LASF55
 3800 0369 08       		.byte	0x8
 3801 036a 08       		.byte	0x8
 3802 036b 6E       		.byte	0x6e
 3803 036c 89030000 		.4byte	0x389
 3804 0370 12       		.uleb128 0x12
 3805 0371 45020000 		.4byte	.LASF56
 3806 0375 08       		.byte	0x8
 3807 0376 70       		.byte	0x70
 3808 0377 F7000000 		.4byte	0xf7
 3809 037b 00       		.byte	0
 3810 037c 12       		.uleb128 0x12
 3811 037d 85050000 		.4byte	.LASF57
 3812 0381 08       		.byte	0x8
 3813 0382 71       		.byte	0x71
 3814 0383 0D010000 		.4byte	0x10d
 3815 0387 04       		.byte	0x4
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 118


 3816 0388 00       		.byte	0
 3817 0389 02       		.uleb128 0x2
 3818 038a BE050000 		.4byte	.LASF58
 3819 038e 08       		.byte	0x8
 3820 038f 72       		.byte	0x72
 3821 0390 64030000 		.4byte	0x364
 3822 0394 02       		.uleb128 0x2
 3823 0395 DC040000 		.4byte	.LASF59
 3824 0399 09       		.byte	0x9
 3825 039a 31       		.byte	0x31
 3826 039b 9F030000 		.4byte	0x39f
 3827 039f 06       		.uleb128 0x6
 3828 03a0 04       		.byte	0x4
 3829 03a1 A5030000 		.4byte	0x3a5
 3830 03a5 11       		.uleb128 0x11
 3831 03a6 08030000 		.4byte	.LASF60
 3832 03aa 48       		.byte	0x48
 3833 03ab 01       		.byte	0x1
 3834 03ac 62       		.byte	0x62
 3835 03ad 34040000 		.4byte	0x434
 3836 03b1 12       		.uleb128 0x12
 3837 03b2 30080000 		.4byte	.LASF61
 3838 03b6 01       		.byte	0x1
 3839 03b7 64       		.byte	0x64
 3840 03b8 59040000 		.4byte	0x459
 3841 03bc 00       		.byte	0
 3842 03bd 12       		.uleb128 0x12
 3843 03be 10060000 		.4byte	.LASF62
 3844 03c2 01       		.byte	0x1
 3845 03c3 65       		.byte	0x65
 3846 03c4 59040000 		.4byte	0x459
 3847 03c8 04       		.byte	0x4
 3848 03c9 15       		.uleb128 0x15
 3849 03ca 7500     		.ascii	"u\000"
 3850 03cc 01       		.byte	0x1
 3851 03cd 6B       		.byte	0x6b
 3852 03ce 9A040000 		.4byte	0x49a
 3853 03d2 08       		.byte	0x8
 3854 03d3 12       		.uleb128 0x12
 3855 03d4 12020000 		.4byte	.LASF63
 3856 03d8 01       		.byte	0x1
 3857 03d9 6D       		.byte	0x6d
 3858 03da 43030000 		.4byte	0x343
 3859 03de 10       		.byte	0x10
 3860 03df 12       		.uleb128 0x12
 3861 03e0 65000000 		.4byte	.LASF64
 3862 03e4 01       		.byte	0x1
 3863 03e5 6E       		.byte	0x6e
 3864 03e6 43030000 		.4byte	0x343
 3865 03ea 24       		.byte	0x24
 3866 03eb 12       		.uleb128 0x12
 3867 03ec 6C030000 		.4byte	.LASF65
 3868 03f0 01       		.byte	0x1
 3869 03f1 70       		.byte	0x70
 3870 03f2 38030000 		.4byte	0x338
 3871 03f6 38       		.byte	0x38
 3872 03f7 12       		.uleb128 0x12
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 119


 3873 03f8 91060000 		.4byte	.LASF66
 3874 03fc 01       		.byte	0x1
 3875 03fd 71       		.byte	0x71
 3876 03fe 02010000 		.4byte	0x102
 3877 0402 3C       		.byte	0x3c
 3878 0403 12       		.uleb128 0x12
 3879 0404 5D040000 		.4byte	.LASF67
 3880 0408 01       		.byte	0x1
 3881 0409 72       		.byte	0x72
 3882 040a 02010000 		.4byte	0x102
 3883 040e 40       		.byte	0x40
 3884 040f 12       		.uleb128 0x12
 3885 0410 C7080000 		.4byte	.LASF68
 3886 0414 01       		.byte	0x1
 3887 0415 74       		.byte	0x74
 3888 0416 B9040000 		.4byte	0x4b9
 3889 041a 44       		.byte	0x44
 3890 041b 12       		.uleb128 0x12
 3891 041c 3D020000 		.4byte	.LASF69
 3892 0420 01       		.byte	0x1
 3893 0421 75       		.byte	0x75
 3894 0422 B9040000 		.4byte	0x4b9
 3895 0426 45       		.byte	0x45
 3896 0427 12       		.uleb128 0x12
 3897 0428 47040000 		.4byte	.LASF70
 3898 042c 01       		.byte	0x1
 3899 042d 78       		.byte	0x78
 3900 042e D6000000 		.4byte	0xd6
 3901 0432 46       		.byte	0x46
 3902 0433 00       		.byte	0
 3903 0434 11       		.uleb128 0x11
 3904 0435 A1040000 		.4byte	.LASF71
 3905 0439 08       		.byte	0x8
 3906 043a 01       		.byte	0x1
 3907 043b 43       		.byte	0x43
 3908 043c 59040000 		.4byte	0x459
 3909 0440 12       		.uleb128 0x12
 3910 0441 27070000 		.4byte	.LASF72
 3911 0445 01       		.byte	0x1
 3912 0446 45       		.byte	0x45
 3913 0447 59040000 		.4byte	0x459
 3914 044b 00       		.byte	0
 3915 044c 12       		.uleb128 0x12
 3916 044d 94020000 		.4byte	.LASF73
 3917 0451 01       		.byte	0x1
 3918 0452 46       		.byte	0x46
 3919 0453 59040000 		.4byte	0x459
 3920 0457 04       		.byte	0x4
 3921 0458 00       		.byte	0
 3922 0459 06       		.uleb128 0x6
 3923 045a 04       		.byte	0x4
 3924 045b CB000000 		.4byte	0xcb
 3925 045f 02       		.uleb128 0x2
 3926 0460 7B060000 		.4byte	.LASF74
 3927 0464 01       		.byte	0x1
 3928 0465 47       		.byte	0x47
 3929 0466 34040000 		.4byte	0x434
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 120


 3930 046a 11       		.uleb128 0x11
 3931 046b 10000000 		.4byte	.LASF75
 3932 046f 08       		.byte	0x8
 3933 0470 01       		.byte	0x1
 3934 0471 49       		.byte	0x49
 3935 0472 8F040000 		.4byte	0x48f
 3936 0476 12       		.uleb128 0x12
 3937 0477 B0080000 		.4byte	.LASF76
 3938 047b 01       		.byte	0x1
 3939 047c 4B       		.byte	0x4b
 3940 047d 4E030000 		.4byte	0x34e
 3941 0481 00       		.byte	0
 3942 0482 12       		.uleb128 0x12
 3943 0483 87070000 		.4byte	.LASF77
 3944 0487 01       		.byte	0x1
 3945 0488 4C       		.byte	0x4c
 3946 0489 02010000 		.4byte	0x102
 3947 048d 04       		.byte	0x4
 3948 048e 00       		.byte	0
 3949 048f 02       		.uleb128 0x2
 3950 0490 32000000 		.4byte	.LASF78
 3951 0494 01       		.byte	0x1
 3952 0495 4D       		.byte	0x4d
 3953 0496 6A040000 		.4byte	0x46a
 3954 049a 16       		.uleb128 0x16
 3955 049b 08       		.byte	0x8
 3956 049c 01       		.byte	0x1
 3957 049d 67       		.byte	0x67
 3958 049e B9040000 		.4byte	0x4b9
 3959 04a2 17       		.uleb128 0x17
 3960 04a3 01030000 		.4byte	.LASF79
 3961 04a7 01       		.byte	0x1
 3962 04a8 69       		.byte	0x69
 3963 04a9 5F040000 		.4byte	0x45f
 3964 04ad 17       		.uleb128 0x17
 3965 04ae 7E030000 		.4byte	.LASF80
 3966 04b2 01       		.byte	0x1
 3967 04b3 6A       		.byte	0x6a
 3968 04b4 8F040000 		.4byte	0x48f
 3969 04b8 00       		.byte	0
 3970 04b9 13       		.uleb128 0x13
 3971 04ba CB000000 		.4byte	0xcb
 3972 04be 02       		.uleb128 0x2
 3973 04bf A9080000 		.4byte	.LASF81
 3974 04c3 01       		.byte	0x1
 3975 04c4 83       		.byte	0x83
 3976 04c5 A5030000 		.4byte	0x3a5
 3977 04c9 02       		.uleb128 0x2
 3978 04ca 54020000 		.4byte	.LASF82
 3979 04ce 01       		.byte	0x1
 3980 04cf 87       		.byte	0x87
 3981 04d0 BE040000 		.4byte	0x4be
 3982 04d4 11       		.uleb128 0x11
 3983 04d5 DF000000 		.4byte	.LASF83
 3984 04d9 08       		.byte	0x8
 3985 04da 01       		.byte	0x1
 3986 04db 94       		.byte	0x94
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 121


 3987 04dc F9040000 		.4byte	0x4f9
 3988 04e0 12       		.uleb128 0x12
 3989 04e1 BA030000 		.4byte	.LASF84
 3990 04e5 01       		.byte	0x1
 3991 04e6 96       		.byte	0x96
 3992 04e7 B9000000 		.4byte	0xb9
 3993 04eb 00       		.byte	0
 3994 04ec 12       		.uleb128 0x12
 3995 04ed B2030000 		.4byte	.LASF85
 3996 04f1 01       		.byte	0x1
 3997 04f2 97       		.byte	0x97
 3998 04f3 94030000 		.4byte	0x394
 3999 04f7 04       		.byte	0x4
 4000 04f8 00       		.byte	0
 4001 04f9 02       		.uleb128 0x2
 4002 04fa 28050000 		.4byte	.LASF86
 4003 04fe 01       		.byte	0x1
 4004 04ff 98       		.byte	0x98
 4005 0500 D4040000 		.4byte	0x4d4
 4006 0504 02       		.uleb128 0x2
 4007 0505 73020000 		.4byte	.LASF87
 4008 0509 01       		.byte	0x1
 4009 050a 9D       		.byte	0x9d
 4010 050b F9040000 		.4byte	0x4f9
 4011 050f 18       		.uleb128 0x18
 4012 0510 5D080000 		.4byte	.LASF89
 4013 0514 01       		.byte	0x1
 4014 0515 0801     		.2byte	0x108
 4015 0517 F7000000 		.4byte	0xf7
 4016 051b 00000000 		.4byte	.LFB0
 4017 051f B0000000 		.4byte	.LFE0-.LFB0
 4018 0523 01       		.uleb128 0x1
 4019 0524 9C       		.byte	0x9c
 4020 0525 57050000 		.4byte	0x557
 4021 0529 19       		.uleb128 0x19
 4022 052a 01030000 		.4byte	.LASF79
 4023 052e 01       		.byte	0x1
 4024 052f 0801     		.2byte	0x108
 4025 0531 94030000 		.4byte	0x394
 4026 0535 02       		.uleb128 0x2
 4027 0536 91       		.byte	0x91
 4028 0537 6C       		.sleb128 -20
 4029 0538 19       		.uleb128 0x19
 4030 0539 5A070000 		.4byte	.LASF88
 4031 053d 01       		.byte	0x1
 4032 053e 0901     		.2byte	0x109
 4033 0540 F7000000 		.4byte	0xf7
 4034 0544 02       		.uleb128 0x2
 4035 0545 91       		.byte	0x91
 4036 0546 68       		.sleb128 -24
 4037 0547 1A       		.uleb128 0x1a
 4038 0548 52070000 		.4byte	.LASF95
 4039 054c 01       		.byte	0x1
 4040 054d 0B01     		.2byte	0x10b
 4041 054f 5D050000 		.4byte	0x55d
 4042 0553 02       		.uleb128 0x2
 4043 0554 91       		.byte	0x91
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 122


 4044 0555 74       		.sleb128 -12
 4045 0556 00       		.byte	0
 4046 0557 06       		.uleb128 0x6
 4047 0558 04       		.byte	0x4
 4048 0559 C9040000 		.4byte	0x4c9
 4049 055d 07       		.uleb128 0x7
 4050 055e 57050000 		.4byte	0x557
 4051 0562 18       		.uleb128 0x18
 4052 0563 38070000 		.4byte	.LASF90
 4053 0567 01       		.byte	0x1
 4054 0568 4001     		.2byte	0x140
 4055 056a 94030000 		.4byte	0x394
 4056 056e 00000000 		.4byte	.LFB1
 4057 0572 8C000000 		.4byte	.LFE1-.LFB1
 4058 0576 01       		.uleb128 0x1
 4059 0577 9C       		.byte	0x9c
 4060 0578 F0050000 		.4byte	0x5f0
 4061 057c 19       		.uleb128 0x19
 4062 057d 37060000 		.4byte	.LASF91
 4063 0581 01       		.byte	0x1
 4064 0582 4001     		.2byte	0x140
 4065 0584 F0050000 		.4byte	0x5f0
 4066 0588 02       		.uleb128 0x2
 4067 0589 91       		.byte	0x91
 4068 058a 64       		.sleb128 -28
 4069 058b 19       		.uleb128 0x19
 4070 058c 5D040000 		.4byte	.LASF67
 4071 0590 01       		.byte	0x1
 4072 0591 4101     		.2byte	0x141
 4073 0593 F0050000 		.4byte	0x5f0
 4074 0597 02       		.uleb128 0x2
 4075 0598 91       		.byte	0x91
 4076 0599 60       		.sleb128 -32
 4077 059a 19       		.uleb128 0x19
 4078 059b 75050000 		.4byte	.LASF92
 4079 059f 01       		.byte	0x1
 4080 05a0 4201     		.2byte	0x142
 4081 05a2 18010000 		.4byte	0x118
 4082 05a6 02       		.uleb128 0x2
 4083 05a7 91       		.byte	0x91
 4084 05a8 5C       		.sleb128 -36
 4085 05a9 19       		.uleb128 0x19
 4086 05aa 48030000 		.4byte	.LASF93
 4087 05ae 01       		.byte	0x1
 4088 05af 4301     		.2byte	0x143
 4089 05b1 F5050000 		.4byte	0x5f5
 4090 05b5 02       		.uleb128 0x2
 4091 05b6 91       		.byte	0x91
 4092 05b7 58       		.sleb128 -40
 4093 05b8 19       		.uleb128 0x19
 4094 05b9 EC050000 		.4byte	.LASF94
 4095 05bd 01       		.byte	0x1
 4096 05be 4401     		.2byte	0x144
 4097 05c0 FB050000 		.4byte	0x5fb
 4098 05c4 02       		.uleb128 0x2
 4099 05c5 91       		.byte	0x91
 4100 05c6 00       		.sleb128 0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 123


 4101 05c7 1A       		.uleb128 0x1a
 4102 05c8 C9000000 		.4byte	.LASF96
 4103 05cc 01       		.byte	0x1
 4104 05cd 4601     		.2byte	0x146
 4105 05cf 57050000 		.4byte	0x557
 4106 05d3 02       		.uleb128 0x2
 4107 05d4 91       		.byte	0x91
 4108 05d5 6C       		.sleb128 -20
 4109 05d6 1B       		.uleb128 0x1b
 4110 05d7 42000000 		.4byte	.LBB2
 4111 05db 14000000 		.4byte	.LBE2-.LBB2
 4112 05df 1A       		.uleb128 0x1a
 4113 05e0 8B060000 		.4byte	.LASF97
 4114 05e4 01       		.byte	0x1
 4115 05e5 5801     		.2byte	0x158
 4116 05e7 00060000 		.4byte	0x600
 4117 05eb 02       		.uleb128 0x2
 4118 05ec 91       		.byte	0x91
 4119 05ed 68       		.sleb128 -24
 4120 05ee 00       		.byte	0
 4121 05ef 00       		.byte	0
 4122 05f0 07       		.uleb128 0x7
 4123 05f1 02010000 		.4byte	0x102
 4124 05f5 06       		.uleb128 0x6
 4125 05f6 04       		.byte	0x4
 4126 05f7 5F020000 		.4byte	0x25f
 4127 05fb 07       		.uleb128 0x7
 4128 05fc D6000000 		.4byte	0xd6
 4129 0600 13       		.uleb128 0x13
 4130 0601 25000000 		.4byte	0x25
 4131 0605 18       		.uleb128 0x18
 4132 0606 3B050000 		.4byte	.LASF98
 4133 060a 01       		.byte	0x1
 4134 060b 7E01     		.2byte	0x17e
 4135 060d 94030000 		.4byte	0x394
 4136 0611 00000000 		.4byte	.LFB2
 4137 0615 90000000 		.4byte	.LFE2-.LFB2
 4138 0619 01       		.uleb128 0x1
 4139 061a 9C       		.byte	0x9c
 4140 061b 7A060000 		.4byte	0x67a
 4141 061f 19       		.uleb128 0x19
 4142 0620 37060000 		.4byte	.LASF91
 4143 0624 01       		.byte	0x1
 4144 0625 7E01     		.2byte	0x17e
 4145 0627 F0050000 		.4byte	0x5f0
 4146 062b 02       		.uleb128 0x2
 4147 062c 91       		.byte	0x91
 4148 062d 5C       		.sleb128 -36
 4149 062e 19       		.uleb128 0x19
 4150 062f 5D040000 		.4byte	.LASF67
 4151 0633 01       		.byte	0x1
 4152 0634 7F01     		.2byte	0x17f
 4153 0636 F0050000 		.4byte	0x5f0
 4154 063a 02       		.uleb128 0x2
 4155 063b 91       		.byte	0x91
 4156 063c 58       		.sleb128 -40
 4157 063d 19       		.uleb128 0x19
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 124


 4158 063e EC050000 		.4byte	.LASF94
 4159 0642 01       		.byte	0x1
 4160 0643 8001     		.2byte	0x180
 4161 0645 FB050000 		.4byte	0x5fb
 4162 0649 02       		.uleb128 0x2
 4163 064a 91       		.byte	0x91
 4164 064b 57       		.sleb128 -41
 4165 064c 1A       		.uleb128 0x1a
 4166 064d C9000000 		.4byte	.LASF96
 4167 0651 01       		.byte	0x1
 4168 0652 8201     		.2byte	0x182
 4169 0654 57050000 		.4byte	0x557
 4170 0658 02       		.uleb128 0x2
 4171 0659 91       		.byte	0x91
 4172 065a 68       		.sleb128 -24
 4173 065b 1A       		.uleb128 0x1a
 4174 065c D7060000 		.4byte	.LASF99
 4175 0660 01       		.byte	0x1
 4176 0661 8301     		.2byte	0x183
 4177 0663 25000000 		.4byte	0x25
 4178 0667 02       		.uleb128 0x2
 4179 0668 91       		.byte	0x91
 4180 0669 6C       		.sleb128 -20
 4181 066a 1A       		.uleb128 0x1a
 4182 066b 75050000 		.4byte	.LASF92
 4183 066f 01       		.byte	0x1
 4184 0670 8401     		.2byte	0x184
 4185 0672 18010000 		.4byte	0x118
 4186 0676 02       		.uleb128 0x2
 4187 0677 91       		.byte	0x91
 4188 0678 64       		.sleb128 -28
 4189 0679 00       		.byte	0
 4190 067a 1C       		.uleb128 0x1c
 4191 067b CC020000 		.4byte	.LASF126
 4192 067f 01       		.byte	0x1
 4193 0680 BC01     		.2byte	0x1bc
 4194 0682 00000000 		.4byte	.LFB3
 4195 0686 44000000 		.4byte	.LFE3-.LFB3
 4196 068a 01       		.uleb128 0x1
 4197 068b 9C       		.byte	0x9c
 4198 068c DC060000 		.4byte	0x6dc
 4199 0690 19       		.uleb128 0x19
 4200 0691 37060000 		.4byte	.LASF91
 4201 0695 01       		.byte	0x1
 4202 0696 BC01     		.2byte	0x1bc
 4203 0698 F0050000 		.4byte	0x5f0
 4204 069c 02       		.uleb128 0x2
 4205 069d 91       		.byte	0x91
 4206 069e 74       		.sleb128 -12
 4207 069f 19       		.uleb128 0x19
 4208 06a0 5D040000 		.4byte	.LASF67
 4209 06a4 01       		.byte	0x1
 4210 06a5 BD01     		.2byte	0x1bd
 4211 06a7 F0050000 		.4byte	0x5f0
 4212 06ab 02       		.uleb128 0x2
 4213 06ac 91       		.byte	0x91
 4214 06ad 70       		.sleb128 -16
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 125


 4215 06ae 19       		.uleb128 0x19
 4216 06af 75050000 		.4byte	.LASF92
 4217 06b3 01       		.byte	0x1
 4218 06b4 BE01     		.2byte	0x1be
 4219 06b6 18010000 		.4byte	0x118
 4220 06ba 02       		.uleb128 0x2
 4221 06bb 91       		.byte	0x91
 4222 06bc 6C       		.sleb128 -20
 4223 06bd 19       		.uleb128 0x19
 4224 06be EC050000 		.4byte	.LASF94
 4225 06c2 01       		.byte	0x1
 4226 06c3 BF01     		.2byte	0x1bf
 4227 06c5 FB050000 		.4byte	0x5fb
 4228 06c9 02       		.uleb128 0x2
 4229 06ca 91       		.byte	0x91
 4230 06cb 6B       		.sleb128 -21
 4231 06cc 19       		.uleb128 0x19
 4232 06cd C9000000 		.4byte	.LASF96
 4233 06d1 01       		.byte	0x1
 4234 06d2 C001     		.2byte	0x1c0
 4235 06d4 57050000 		.4byte	0x557
 4236 06d8 02       		.uleb128 0x2
 4237 06d9 91       		.byte	0x91
 4238 06da 00       		.sleb128 0
 4239 06db 00       		.byte	0
 4240 06dc 18       		.uleb128 0x18
 4241 06dd 35040000 		.4byte	.LASF100
 4242 06e1 01       		.byte	0x1
 4243 06e2 0303     		.2byte	0x303
 4244 06e4 F7000000 		.4byte	0xf7
 4245 06e8 00000000 		.4byte	.LFB4
 4246 06ec 70010000 		.4byte	.LFE4-.LFB4
 4247 06f0 01       		.uleb128 0x1
 4248 06f1 9C       		.byte	0x9c
 4249 06f2 6F070000 		.4byte	0x76f
 4250 06f6 19       		.uleb128 0x19
 4251 06f7 01030000 		.4byte	.LASF79
 4252 06fb 01       		.byte	0x1
 4253 06fc 0303     		.2byte	0x303
 4254 06fe 94030000 		.4byte	0x394
 4255 0702 02       		.uleb128 0x2
 4256 0703 91       		.byte	0x91
 4257 0704 5C       		.sleb128 -36
 4258 0705 19       		.uleb128 0x19
 4259 0706 E9060000 		.4byte	.LASF101
 4260 070a 01       		.byte	0x1
 4261 070b 0403     		.2byte	0x304
 4262 070d 6F070000 		.4byte	0x76f
 4263 0711 02       		.uleb128 0x2
 4264 0712 91       		.byte	0x91
 4265 0713 58       		.sleb128 -40
 4266 0714 19       		.uleb128 0x19
 4267 0715 03080000 		.4byte	.LASF102
 4268 0719 01       		.byte	0x1
 4269 071a 0503     		.2byte	0x305
 4270 071c 0D010000 		.4byte	0x10d
 4271 0720 02       		.uleb128 0x2
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 126


 4272 0721 91       		.byte	0x91
 4273 0722 54       		.sleb128 -44
 4274 0723 19       		.uleb128 0x19
 4275 0724 5C020000 		.4byte	.LASF103
 4276 0728 01       		.byte	0x1
 4277 0729 0603     		.2byte	0x306
 4278 072b 74070000 		.4byte	0x774
 4279 072f 02       		.uleb128 0x2
 4280 0730 91       		.byte	0x91
 4281 0731 50       		.sleb128 -48
 4282 0732 1A       		.uleb128 0x1a
 4283 0733 94030000 		.4byte	.LASF104
 4284 0737 01       		.byte	0x1
 4285 0738 0803     		.2byte	0x308
 4286 073a F7000000 		.4byte	0xf7
 4287 073e 02       		.uleb128 0x2
 4288 073f 91       		.byte	0x91
 4289 0740 74       		.sleb128 -12
 4290 0741 1A       		.uleb128 0x1a
 4291 0742 F2020000 		.4byte	.LASF105
 4292 0746 01       		.byte	0x1
 4293 0747 0803     		.2byte	0x308
 4294 0749 F7000000 		.4byte	0xf7
 4295 074d 02       		.uleb128 0x2
 4296 074e 91       		.byte	0x91
 4297 074f 6C       		.sleb128 -20
 4298 0750 1A       		.uleb128 0x1a
 4299 0751 A9030000 		.4byte	.LASF106
 4300 0755 01       		.byte	0x1
 4301 0756 0903     		.2byte	0x309
 4302 0758 89030000 		.4byte	0x389
 4303 075c 02       		.uleb128 0x2
 4304 075d 91       		.byte	0x91
 4305 075e 64       		.sleb128 -28
 4306 075f 1A       		.uleb128 0x1a
 4307 0760 52070000 		.4byte	.LASF95
 4308 0764 01       		.byte	0x1
 4309 0765 0A03     		.2byte	0x30a
 4310 0767 5D050000 		.4byte	0x55d
 4311 076b 02       		.uleb128 0x2
 4312 076c 91       		.byte	0x91
 4313 076d 70       		.sleb128 -16
 4314 076e 00       		.byte	0
 4315 076f 07       		.uleb128 0x7
 4316 0770 C4000000 		.4byte	0xc4
 4317 0774 07       		.uleb128 0x7
 4318 0775 F7000000 		.4byte	0xf7
 4319 0779 18       		.uleb128 0x18
 4320 077a DC030000 		.4byte	.LASF107
 4321 077e 01       		.byte	0x1
 4322 077f D703     		.2byte	0x3d7
 4323 0781 F7000000 		.4byte	0xf7
 4324 0785 00000000 		.4byte	.LFB5
 4325 0789 E4000000 		.4byte	.LFE5-.LFB5
 4326 078d 01       		.uleb128 0x1
 4327 078e 9C       		.byte	0x9c
 4328 078f 25080000 		.4byte	0x825
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 127


 4329 0793 19       		.uleb128 0x19
 4330 0794 01030000 		.4byte	.LASF79
 4331 0798 01       		.byte	0x1
 4332 0799 D703     		.2byte	0x3d7
 4333 079b 94030000 		.4byte	0x394
 4334 079f 02       		.uleb128 0x2
 4335 07a0 91       		.byte	0x91
 4336 07a1 5C       		.sleb128 -36
 4337 07a2 19       		.uleb128 0x19
 4338 07a3 E9060000 		.4byte	.LASF101
 4339 07a7 01       		.byte	0x1
 4340 07a8 D803     		.2byte	0x3d8
 4341 07aa 6F070000 		.4byte	0x76f
 4342 07ae 02       		.uleb128 0x2
 4343 07af 91       		.byte	0x91
 4344 07b0 58       		.sleb128 -40
 4345 07b1 19       		.uleb128 0x19
 4346 07b2 7C000000 		.4byte	.LASF108
 4347 07b6 01       		.byte	0x1
 4348 07b7 D903     		.2byte	0x3d9
 4349 07b9 2B080000 		.4byte	0x82b
 4350 07bd 02       		.uleb128 0x2
 4351 07be 91       		.byte	0x91
 4352 07bf 54       		.sleb128 -44
 4353 07c0 19       		.uleb128 0x19
 4354 07c1 5C020000 		.4byte	.LASF103
 4355 07c5 01       		.byte	0x1
 4356 07c6 DA03     		.2byte	0x3da
 4357 07c8 74070000 		.4byte	0x774
 4358 07cc 02       		.uleb128 0x2
 4359 07cd 91       		.byte	0x91
 4360 07ce 50       		.sleb128 -48
 4361 07cf 1A       		.uleb128 0x1a
 4362 07d0 64070000 		.4byte	.LASF109
 4363 07d4 01       		.byte	0x1
 4364 07d5 DC03     		.2byte	0x3dc
 4365 07d7 F7000000 		.4byte	0xf7
 4366 07db 02       		.uleb128 0x2
 4367 07dc 91       		.byte	0x91
 4368 07dd 74       		.sleb128 -12
 4369 07de 1A       		.uleb128 0x1a
 4370 07df B5020000 		.4byte	.LASF110
 4371 07e3 01       		.byte	0x1
 4372 07e4 DD03     		.2byte	0x3dd
 4373 07e6 02010000 		.4byte	0x102
 4374 07ea 02       		.uleb128 0x2
 4375 07eb 91       		.byte	0x91
 4376 07ec 6C       		.sleb128 -20
 4377 07ed 1A       		.uleb128 0x1a
 4378 07ee 52070000 		.4byte	.LASF95
 4379 07f2 01       		.byte	0x1
 4380 07f3 DE03     		.2byte	0x3de
 4381 07f5 5D050000 		.4byte	0x55d
 4382 07f9 02       		.uleb128 0x2
 4383 07fa 91       		.byte	0x91
 4384 07fb 70       		.sleb128 -16
 4385 07fc 1B       		.uleb128 0x1b
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 128


 4386 07fd 58000000 		.4byte	.LBB3
 4387 0801 70000000 		.4byte	.LBE3-.LBB3
 4388 0805 1A       		.uleb128 0x1a
 4389 0806 3D020000 		.4byte	.LASF69
 4390 080a 01       		.byte	0x1
 4391 080b FD03     		.2byte	0x3fd
 4392 080d 30080000 		.4byte	0x830
 4393 0811 02       		.uleb128 0x2
 4394 0812 91       		.byte	0x91
 4395 0813 6B       		.sleb128 -21
 4396 0814 1A       		.uleb128 0x1a
 4397 0815 68040000 		.4byte	.LASF111
 4398 0819 01       		.byte	0x1
 4399 081a FE03     		.2byte	0x3fe
 4400 081c F0050000 		.4byte	0x5f0
 4401 0820 02       		.uleb128 0x2
 4402 0821 91       		.byte	0x91
 4403 0822 64       		.sleb128 -28
 4404 0823 00       		.byte	0
 4405 0824 00       		.byte	0
 4406 0825 06       		.uleb128 0x6
 4407 0826 04       		.byte	0x4
 4408 0827 F7000000 		.4byte	0xf7
 4409 082b 07       		.uleb128 0x7
 4410 082c 25080000 		.4byte	0x825
 4411 0830 07       		.uleb128 0x7
 4412 0831 CB000000 		.4byte	0xcb
 4413 0835 18       		.uleb128 0x18
 4414 0836 BB040000 		.4byte	.LASF112
 4415 083a 01       		.byte	0x1
 4416 083b 7E04     		.2byte	0x47e
 4417 083d F7000000 		.4byte	0xf7
 4418 0841 00000000 		.4byte	.LFB6
 4419 0845 D4000000 		.4byte	.LFE6-.LFB6
 4420 0849 01       		.uleb128 0x1
 4421 084a 9C       		.byte	0x9c
 4422 084b CD080000 		.4byte	0x8cd
 4423 084f 19       		.uleb128 0x19
 4424 0850 01030000 		.4byte	.LASF79
 4425 0854 01       		.byte	0x1
 4426 0855 7E04     		.2byte	0x47e
 4427 0857 94030000 		.4byte	0x394
 4428 085b 02       		.uleb128 0x2
 4429 085c 91       		.byte	0x91
 4430 085d 5C       		.sleb128 -36
 4431 085e 19       		.uleb128 0x19
 4432 085f 7C000000 		.4byte	.LASF108
 4433 0863 01       		.byte	0x1
 4434 0864 7F04     		.2byte	0x47f
 4435 0866 2B080000 		.4byte	0x82b
 4436 086a 02       		.uleb128 0x2
 4437 086b 91       		.byte	0x91
 4438 086c 58       		.sleb128 -40
 4439 086d 1A       		.uleb128 0x1a
 4440 086e 64070000 		.4byte	.LASF109
 4441 0872 01       		.byte	0x1
 4442 0873 8104     		.2byte	0x481
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 129


 4443 0875 F7000000 		.4byte	0xf7
 4444 0879 02       		.uleb128 0x2
 4445 087a 91       		.byte	0x91
 4446 087b 74       		.sleb128 -12
 4447 087c 1A       		.uleb128 0x1a
 4448 087d B5020000 		.4byte	.LASF110
 4449 0881 01       		.byte	0x1
 4450 0882 8204     		.2byte	0x482
 4451 0884 02010000 		.4byte	0x102
 4452 0888 02       		.uleb128 0x2
 4453 0889 91       		.byte	0x91
 4454 088a 6C       		.sleb128 -20
 4455 088b 1A       		.uleb128 0x1a
 4456 088c 52070000 		.4byte	.LASF95
 4457 0890 01       		.byte	0x1
 4458 0891 8304     		.2byte	0x483
 4459 0893 5D050000 		.4byte	0x55d
 4460 0897 02       		.uleb128 0x2
 4461 0898 91       		.byte	0x91
 4462 0899 70       		.sleb128 -16
 4463 089a 1B       		.uleb128 0x1b
 4464 089b 40000000 		.4byte	.LBB4
 4465 089f 7C000000 		.4byte	.LBE4-.LBB4
 4466 08a3 1A       		.uleb128 0x1a
 4467 08a4 6C030000 		.4byte	.LASF65
 4468 08a8 01       		.byte	0x1
 4469 08a9 A804     		.2byte	0x4a8
 4470 08ab F0050000 		.4byte	0x5f0
 4471 08af 02       		.uleb128 0x2
 4472 08b0 91       		.byte	0x91
 4473 08b1 68       		.sleb128 -24
 4474 08b2 1B       		.uleb128 0x1b
 4475 08b3 50000000 		.4byte	.LBB5
 4476 08b7 66000000 		.4byte	.LBE5-.LBB5
 4477 08bb 1A       		.uleb128 0x1a
 4478 08bc 3D020000 		.4byte	.LASF69
 4479 08c0 01       		.byte	0x1
 4480 08c1 AF04     		.2byte	0x4af
 4481 08c3 30080000 		.4byte	0x830
 4482 08c7 02       		.uleb128 0x2
 4483 08c8 91       		.byte	0x91
 4484 08c9 67       		.sleb128 -25
 4485 08ca 00       		.byte	0
 4486 08cb 00       		.byte	0
 4487 08cc 00       		.byte	0
 4488 08cd 18       		.uleb128 0x18
 4489 08ce 42000000 		.4byte	.LASF113
 4490 08d2 01       		.byte	0x1
 4491 08d3 2605     		.2byte	0x526
 4492 08d5 F7000000 		.4byte	0xf7
 4493 08d9 00000000 		.4byte	.LFB7
 4494 08dd 60010000 		.4byte	.LFE7-.LFB7
 4495 08e1 01       		.uleb128 0x1
 4496 08e2 9C       		.byte	0x9c
 4497 08e3 5B090000 		.4byte	0x95b
 4498 08e7 19       		.uleb128 0x19
 4499 08e8 01030000 		.4byte	.LASF79
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 130


 4500 08ec 01       		.byte	0x1
 4501 08ed 2605     		.2byte	0x526
 4502 08ef 94030000 		.4byte	0x394
 4503 08f3 02       		.uleb128 0x2
 4504 08f4 91       		.byte	0x91
 4505 08f5 5C       		.sleb128 -36
 4506 08f6 19       		.uleb128 0x19
 4507 08f7 3F030000 		.4byte	.LASF114
 4508 08fb 01       		.byte	0x1
 4509 08fc 2705     		.2byte	0x527
 4510 08fe 5B090000 		.4byte	0x95b
 4511 0902 02       		.uleb128 0x2
 4512 0903 91       		.byte	0x91
 4513 0904 58       		.sleb128 -40
 4514 0905 19       		.uleb128 0x19
 4515 0906 03080000 		.4byte	.LASF102
 4516 090a 01       		.byte	0x1
 4517 090b 2805     		.2byte	0x528
 4518 090d 0D010000 		.4byte	0x10d
 4519 0911 02       		.uleb128 0x2
 4520 0912 91       		.byte	0x91
 4521 0913 54       		.sleb128 -44
 4522 0914 1A       		.uleb128 0x1a
 4523 0915 94030000 		.4byte	.LASF104
 4524 0919 01       		.byte	0x1
 4525 091a 2A05     		.2byte	0x52a
 4526 091c F7000000 		.4byte	0xf7
 4527 0920 02       		.uleb128 0x2
 4528 0921 91       		.byte	0x91
 4529 0922 74       		.sleb128 -12
 4530 0923 1A       		.uleb128 0x1a
 4531 0924 A9030000 		.4byte	.LASF106
 4532 0928 01       		.byte	0x1
 4533 0929 2B05     		.2byte	0x52b
 4534 092b 89030000 		.4byte	0x389
 4535 092f 02       		.uleb128 0x2
 4536 0930 91       		.byte	0x91
 4537 0931 64       		.sleb128 -28
 4538 0932 1A       		.uleb128 0x1a
 4539 0933 52070000 		.4byte	.LASF95
 4540 0937 01       		.byte	0x1
 4541 0938 2C05     		.2byte	0x52c
 4542 093a 5D050000 		.4byte	0x55d
 4543 093e 02       		.uleb128 0x2
 4544 093f 91       		.byte	0x91
 4545 0940 70       		.sleb128 -16
 4546 0941 1B       		.uleb128 0x1b
 4547 0942 4A000000 		.4byte	.LBB6
 4548 0946 64000000 		.4byte	.LBE6-.LBB6
 4549 094a 1A       		.uleb128 0x1a
 4550 094b 6C030000 		.4byte	.LASF65
 4551 094f 01       		.byte	0x1
 4552 0950 4305     		.2byte	0x543
 4553 0952 F0050000 		.4byte	0x5f0
 4554 0956 02       		.uleb128 0x2
 4555 0957 91       		.byte	0x91
 4556 0958 6C       		.sleb128 -20
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 131


 4557 0959 00       		.byte	0
 4558 095a 00       		.byte	0
 4559 095b 07       		.uleb128 0x7
 4560 095c B0000000 		.4byte	0xb0
 4561 0960 18       		.uleb128 0x18
 4562 0961 96000000 		.4byte	.LASF115
 4563 0965 01       		.byte	0x1
 4564 0966 B505     		.2byte	0x5b5
 4565 0968 F7000000 		.4byte	0xf7
 4566 096c 00000000 		.4byte	.LFB8
 4567 0970 4C010000 		.4byte	.LFE8-.LFB8
 4568 0974 01       		.uleb128 0x1
 4569 0975 9C       		.byte	0x9c
 4570 0976 DF090000 		.4byte	0x9df
 4571 097a 19       		.uleb128 0x19
 4572 097b 01030000 		.4byte	.LASF79
 4573 097f 01       		.byte	0x1
 4574 0980 B505     		.2byte	0x5b5
 4575 0982 94030000 		.4byte	0x394
 4576 0986 02       		.uleb128 0x2
 4577 0987 91       		.byte	0x91
 4578 0988 5C       		.sleb128 -36
 4579 0989 19       		.uleb128 0x19
 4580 098a 03080000 		.4byte	.LASF102
 4581 098e 01       		.byte	0x1
 4582 098f B605     		.2byte	0x5b6
 4583 0991 0D010000 		.4byte	0x10d
 4584 0995 02       		.uleb128 0x2
 4585 0996 91       		.byte	0x91
 4586 0997 58       		.sleb128 -40
 4587 0998 1A       		.uleb128 0x1a
 4588 0999 94030000 		.4byte	.LASF104
 4589 099d 01       		.byte	0x1
 4590 099e B805     		.2byte	0x5b8
 4591 09a0 F7000000 		.4byte	0xf7
 4592 09a4 02       		.uleb128 0x2
 4593 09a5 91       		.byte	0x91
 4594 09a6 74       		.sleb128 -12
 4595 09a7 1A       		.uleb128 0x1a
 4596 09a8 A9030000 		.4byte	.LASF106
 4597 09ac 01       		.byte	0x1
 4598 09ad B905     		.2byte	0x5b9
 4599 09af 89030000 		.4byte	0x389
 4600 09b3 02       		.uleb128 0x2
 4601 09b4 91       		.byte	0x91
 4602 09b5 64       		.sleb128 -28
 4603 09b6 1A       		.uleb128 0x1a
 4604 09b7 52070000 		.4byte	.LASF95
 4605 09bb 01       		.byte	0x1
 4606 09bc BA05     		.2byte	0x5ba
 4607 09be 5D050000 		.4byte	0x55d
 4608 09c2 02       		.uleb128 0x2
 4609 09c3 91       		.byte	0x91
 4610 09c4 70       		.sleb128 -16
 4611 09c5 1B       		.uleb128 0x1b
 4612 09c6 44000000 		.4byte	.LBB7
 4613 09ca 58000000 		.4byte	.LBE7-.LBB7
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 132


 4614 09ce 1A       		.uleb128 0x1a
 4615 09cf FF050000 		.4byte	.LASF116
 4616 09d3 01       		.byte	0x1
 4617 09d4 D705     		.2byte	0x5d7
 4618 09d6 F0050000 		.4byte	0x5f0
 4619 09da 02       		.uleb128 0x2
 4620 09db 91       		.byte	0x91
 4621 09dc 6C       		.sleb128 -20
 4622 09dd 00       		.byte	0
 4623 09de 00       		.byte	0
 4624 09df 18       		.uleb128 0x18
 4625 09e0 89030000 		.4byte	.LASF117
 4626 09e4 01       		.byte	0x1
 4627 09e5 9006     		.2byte	0x690
 4628 09e7 F7000000 		.4byte	0xf7
 4629 09eb 00000000 		.4byte	.LFB9
 4630 09ef 64010000 		.4byte	.LFE9-.LFB9
 4631 09f3 01       		.uleb128 0x1
 4632 09f4 9C       		.byte	0x9c
 4633 09f5 7C0A0000 		.4byte	0xa7c
 4634 09f9 19       		.uleb128 0x19
 4635 09fa 01030000 		.4byte	.LASF79
 4636 09fe 01       		.byte	0x1
 4637 09ff 9006     		.2byte	0x690
 4638 0a01 94030000 		.4byte	0x394
 4639 0a05 02       		.uleb128 0x2
 4640 0a06 91       		.byte	0x91
 4641 0a07 5C       		.sleb128 -36
 4642 0a08 19       		.uleb128 0x19
 4643 0a09 3F030000 		.4byte	.LASF114
 4644 0a0d 01       		.byte	0x1
 4645 0a0e 9106     		.2byte	0x691
 4646 0a10 5B090000 		.4byte	0x95b
 4647 0a14 02       		.uleb128 0x2
 4648 0a15 91       		.byte	0x91
 4649 0a16 58       		.sleb128 -40
 4650 0a17 19       		.uleb128 0x19
 4651 0a18 03080000 		.4byte	.LASF102
 4652 0a1c 01       		.byte	0x1
 4653 0a1d 9206     		.2byte	0x692
 4654 0a1f 0D010000 		.4byte	0x10d
 4655 0a23 02       		.uleb128 0x2
 4656 0a24 91       		.byte	0x91
 4657 0a25 54       		.sleb128 -44
 4658 0a26 1A       		.uleb128 0x1a
 4659 0a27 94030000 		.4byte	.LASF104
 4660 0a2b 01       		.byte	0x1
 4661 0a2c 9406     		.2byte	0x694
 4662 0a2e F7000000 		.4byte	0xf7
 4663 0a32 02       		.uleb128 0x2
 4664 0a33 91       		.byte	0x91
 4665 0a34 74       		.sleb128 -12
 4666 0a35 1A       		.uleb128 0x1a
 4667 0a36 A9030000 		.4byte	.LASF106
 4668 0a3a 01       		.byte	0x1
 4669 0a3b 9506     		.2byte	0x695
 4670 0a3d 89030000 		.4byte	0x389
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 133


 4671 0a41 02       		.uleb128 0x2
 4672 0a42 91       		.byte	0x91
 4673 0a43 60       		.sleb128 -32
 4674 0a44 1A       		.uleb128 0x1a
 4675 0a45 C8050000 		.4byte	.LASF118
 4676 0a49 01       		.byte	0x1
 4677 0a4a 9606     		.2byte	0x696
 4678 0a4c 59040000 		.4byte	0x459
 4679 0a50 02       		.uleb128 0x2
 4680 0a51 91       		.byte	0x91
 4681 0a52 68       		.sleb128 -24
 4682 0a53 1A       		.uleb128 0x1a
 4683 0a54 52070000 		.4byte	.LASF95
 4684 0a58 01       		.byte	0x1
 4685 0a59 9706     		.2byte	0x697
 4686 0a5b 5D050000 		.4byte	0x55d
 4687 0a5f 02       		.uleb128 0x2
 4688 0a60 91       		.byte	0x91
 4689 0a61 70       		.sleb128 -16
 4690 0a62 1B       		.uleb128 0x1b
 4691 0a63 4A000000 		.4byte	.LBB8
 4692 0a67 68000000 		.4byte	.LBE8-.LBB8
 4693 0a6b 1A       		.uleb128 0x1a
 4694 0a6c 6C030000 		.4byte	.LASF65
 4695 0a70 01       		.byte	0x1
 4696 0a71 AE06     		.2byte	0x6ae
 4697 0a73 F0050000 		.4byte	0x5f0
 4698 0a77 02       		.uleb128 0x2
 4699 0a78 91       		.byte	0x91
 4700 0a79 6C       		.sleb128 -20
 4701 0a7a 00       		.byte	0
 4702 0a7b 00       		.byte	0
 4703 0a7c 18       		.uleb128 0x18
 4704 0a7d 50000000 		.4byte	.LASF119
 4705 0a81 01       		.byte	0x1
 4706 0a82 2707     		.2byte	0x727
 4707 0a84 F7000000 		.4byte	0xf7
 4708 0a88 00000000 		.4byte	.LFB10
 4709 0a8c D0000000 		.4byte	.LFE10-.LFB10
 4710 0a90 01       		.uleb128 0x1
 4711 0a91 9C       		.byte	0x9c
 4712 0a92 230B0000 		.4byte	0xb23
 4713 0a96 19       		.uleb128 0x19
 4714 0a97 01030000 		.4byte	.LASF79
 4715 0a9b 01       		.byte	0x1
 4716 0a9c 2707     		.2byte	0x727
 4717 0a9e 94030000 		.4byte	0x394
 4718 0aa2 02       		.uleb128 0x2
 4719 0aa3 91       		.byte	0x91
 4720 0aa4 5C       		.sleb128 -36
 4721 0aa5 19       		.uleb128 0x19
 4722 0aa6 3F030000 		.4byte	.LASF114
 4723 0aaa 01       		.byte	0x1
 4724 0aab 2807     		.2byte	0x728
 4725 0aad 5B090000 		.4byte	0x95b
 4726 0ab1 02       		.uleb128 0x2
 4727 0ab2 91       		.byte	0x91
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 134


 4728 0ab3 58       		.sleb128 -40
 4729 0ab4 19       		.uleb128 0x19
 4730 0ab5 7C000000 		.4byte	.LASF108
 4731 0ab9 01       		.byte	0x1
 4732 0aba 2907     		.2byte	0x729
 4733 0abc 2B080000 		.4byte	0x82b
 4734 0ac0 02       		.uleb128 0x2
 4735 0ac1 91       		.byte	0x91
 4736 0ac2 54       		.sleb128 -44
 4737 0ac3 1A       		.uleb128 0x1a
 4738 0ac4 64070000 		.4byte	.LASF109
 4739 0ac8 01       		.byte	0x1
 4740 0ac9 2B07     		.2byte	0x72b
 4741 0acb F7000000 		.4byte	0xf7
 4742 0acf 02       		.uleb128 0x2
 4743 0ad0 91       		.byte	0x91
 4744 0ad1 74       		.sleb128 -12
 4745 0ad2 1A       		.uleb128 0x1a
 4746 0ad3 B5020000 		.4byte	.LASF110
 4747 0ad7 01       		.byte	0x1
 4748 0ad8 2C07     		.2byte	0x72c
 4749 0ada 02010000 		.4byte	0x102
 4750 0ade 02       		.uleb128 0x2
 4751 0adf 91       		.byte	0x91
 4752 0ae0 6C       		.sleb128 -20
 4753 0ae1 1A       		.uleb128 0x1a
 4754 0ae2 52070000 		.4byte	.LASF95
 4755 0ae6 01       		.byte	0x1
 4756 0ae7 2D07     		.2byte	0x72d
 4757 0ae9 5D050000 		.4byte	0x55d
 4758 0aed 02       		.uleb128 0x2
 4759 0aee 91       		.byte	0x91
 4760 0aef 70       		.sleb128 -16
 4761 0af0 1B       		.uleb128 0x1b
 4762 0af1 34000000 		.4byte	.LBB9
 4763 0af5 84000000 		.4byte	.LBE9-.LBB9
 4764 0af9 1A       		.uleb128 0x1a
 4765 0afa 6C030000 		.4byte	.LASF65
 4766 0afe 01       		.byte	0x1
 4767 0aff 4407     		.2byte	0x744
 4768 0b01 F0050000 		.4byte	0x5f0
 4769 0b05 02       		.uleb128 0x2
 4770 0b06 91       		.byte	0x91
 4771 0b07 68       		.sleb128 -24
 4772 0b08 1B       		.uleb128 0x1b
 4773 0b09 40000000 		.4byte	.LBB10
 4774 0b0d 72000000 		.4byte	.LBE10-.LBB10
 4775 0b11 1A       		.uleb128 0x1a
 4776 0b12 C7080000 		.4byte	.LASF68
 4777 0b16 01       		.byte	0x1
 4778 0b17 4907     		.2byte	0x749
 4779 0b19 30080000 		.4byte	0x830
 4780 0b1d 02       		.uleb128 0x2
 4781 0b1e 91       		.byte	0x91
 4782 0b1f 67       		.sleb128 -25
 4783 0b20 00       		.byte	0
 4784 0b21 00       		.byte	0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 135


 4785 0b22 00       		.byte	0
 4786 0b23 18       		.uleb128 0x18
 4787 0b24 B7070000 		.4byte	.LASF120
 4788 0b28 01       		.byte	0x1
 4789 0b29 8607     		.2byte	0x786
 4790 0b2b F7000000 		.4byte	0xf7
 4791 0b2f 00000000 		.4byte	.LFB11
 4792 0b33 80000000 		.4byte	.LFE11-.LFB11
 4793 0b37 01       		.uleb128 0x1
 4794 0b38 9C       		.byte	0x9c
 4795 0b39 980B0000 		.4byte	0xb98
 4796 0b3d 19       		.uleb128 0x19
 4797 0b3e 01030000 		.4byte	.LASF79
 4798 0b42 01       		.byte	0x1
 4799 0b43 8607     		.2byte	0x786
 4800 0b45 94030000 		.4byte	0x394
 4801 0b49 02       		.uleb128 0x2
 4802 0b4a 91       		.byte	0x91
 4803 0b4b 64       		.sleb128 -28
 4804 0b4c 19       		.uleb128 0x19
 4805 0b4d 3F030000 		.4byte	.LASF114
 4806 0b51 01       		.byte	0x1
 4807 0b52 8707     		.2byte	0x787
 4808 0b54 5B090000 		.4byte	0x95b
 4809 0b58 02       		.uleb128 0x2
 4810 0b59 91       		.byte	0x91
 4811 0b5a 60       		.sleb128 -32
 4812 0b5b 1A       		.uleb128 0x1a
 4813 0b5c 64070000 		.4byte	.LASF109
 4814 0b60 01       		.byte	0x1
 4815 0b61 8907     		.2byte	0x789
 4816 0b63 F7000000 		.4byte	0xf7
 4817 0b67 02       		.uleb128 0x2
 4818 0b68 91       		.byte	0x91
 4819 0b69 74       		.sleb128 -12
 4820 0b6a 1A       		.uleb128 0x1a
 4821 0b6b B5020000 		.4byte	.LASF110
 4822 0b6f 01       		.byte	0x1
 4823 0b70 8A07     		.2byte	0x78a
 4824 0b72 02010000 		.4byte	0x102
 4825 0b76 02       		.uleb128 0x2
 4826 0b77 91       		.byte	0x91
 4827 0b78 6C       		.sleb128 -20
 4828 0b79 1A       		.uleb128 0x1a
 4829 0b7a C8050000 		.4byte	.LASF118
 4830 0b7e 01       		.byte	0x1
 4831 0b7f 8B07     		.2byte	0x78b
 4832 0b81 59040000 		.4byte	0x459
 4833 0b85 02       		.uleb128 0x2
 4834 0b86 91       		.byte	0x91
 4835 0b87 68       		.sleb128 -24
 4836 0b88 1A       		.uleb128 0x1a
 4837 0b89 52070000 		.4byte	.LASF95
 4838 0b8d 01       		.byte	0x1
 4839 0b8e 8C07     		.2byte	0x78c
 4840 0b90 5D050000 		.4byte	0x55d
 4841 0b94 02       		.uleb128 0x2
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 136


 4842 0b95 91       		.byte	0x91
 4843 0b96 70       		.sleb128 -16
 4844 0b97 00       		.byte	0
 4845 0b98 18       		.uleb128 0x18
 4846 0b99 10070000 		.4byte	.LASF121
 4847 0b9d 01       		.byte	0x1
 4848 0b9e BD07     		.2byte	0x7bd
 4849 0ba0 02010000 		.4byte	0x102
 4850 0ba4 00000000 		.4byte	.LFB12
 4851 0ba8 30000000 		.4byte	.LFE12-.LFB12
 4852 0bac 01       		.uleb128 0x1
 4853 0bad 9C       		.byte	0x9c
 4854 0bae D10B0000 		.4byte	0xbd1
 4855 0bb2 19       		.uleb128 0x19
 4856 0bb3 01030000 		.4byte	.LASF79
 4857 0bb7 01       		.byte	0x1
 4858 0bb8 BD07     		.2byte	0x7bd
 4859 0bba D10B0000 		.4byte	0xbd1
 4860 0bbe 02       		.uleb128 0x2
 4861 0bbf 91       		.byte	0x91
 4862 0bc0 6C       		.sleb128 -20
 4863 0bc1 1A       		.uleb128 0x1a
 4864 0bc2 6A020000 		.4byte	.LASF122
 4865 0bc6 01       		.byte	0x1
 4866 0bc7 BF07     		.2byte	0x7bf
 4867 0bc9 02010000 		.4byte	0x102
 4868 0bcd 02       		.uleb128 0x2
 4869 0bce 91       		.byte	0x91
 4870 0bcf 74       		.sleb128 -12
 4871 0bd0 00       		.byte	0
 4872 0bd1 07       		.uleb128 0x7
 4873 0bd2 94030000 		.4byte	0x394
 4874 0bd6 18       		.uleb128 0x18
 4875 0bd7 26020000 		.4byte	.LASF123
 4876 0bdb 01       		.byte	0x1
 4877 0bdc CD07     		.2byte	0x7cd
 4878 0bde 02010000 		.4byte	0x102
 4879 0be2 00000000 		.4byte	.LFB13
 4880 0be6 3C000000 		.4byte	.LFE13-.LFB13
 4881 0bea 01       		.uleb128 0x1
 4882 0beb 9C       		.byte	0x9c
 4883 0bec 1E0C0000 		.4byte	0xc1e
 4884 0bf0 19       		.uleb128 0x19
 4885 0bf1 01030000 		.4byte	.LASF79
 4886 0bf5 01       		.byte	0x1
 4887 0bf6 CD07     		.2byte	0x7cd
 4888 0bf8 D10B0000 		.4byte	0xbd1
 4889 0bfc 02       		.uleb128 0x2
 4890 0bfd 91       		.byte	0x91
 4891 0bfe 6C       		.sleb128 -20
 4892 0bff 1A       		.uleb128 0x1a
 4893 0c00 6A020000 		.4byte	.LASF122
 4894 0c04 01       		.byte	0x1
 4895 0c05 CF07     		.2byte	0x7cf
 4896 0c07 02010000 		.4byte	0x102
 4897 0c0b 02       		.uleb128 0x2
 4898 0c0c 91       		.byte	0x91
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 137


 4899 0c0d 70       		.sleb128 -16
 4900 0c0e 1A       		.uleb128 0x1a
 4901 0c0f 52070000 		.4byte	.LASF95
 4902 0c13 01       		.byte	0x1
 4903 0c14 D007     		.2byte	0x7d0
 4904 0c16 5D050000 		.4byte	0x55d
 4905 0c1a 02       		.uleb128 0x2
 4906 0c1b 91       		.byte	0x91
 4907 0c1c 74       		.sleb128 -12
 4908 0c1d 00       		.byte	0
 4909 0c1e 1D       		.uleb128 0x1d
 4910 0c1f F3040000 		.4byte	.LASF124
 4911 0c23 01       		.byte	0x1
 4912 0c24 DE07     		.2byte	0x7de
 4913 0c26 02010000 		.4byte	0x102
 4914 0c2a 00000000 		.4byte	.LFB14
 4915 0c2e 2C000000 		.4byte	.LFE14-.LFB14
 4916 0c32 01       		.uleb128 0x1
 4917 0c33 9C       		.byte	0x9c
 4918 0c34 660C0000 		.4byte	0xc66
 4919 0c38 19       		.uleb128 0x19
 4920 0c39 01030000 		.4byte	.LASF79
 4921 0c3d 01       		.byte	0x1
 4922 0c3e DE07     		.2byte	0x7de
 4923 0c40 D10B0000 		.4byte	0xbd1
 4924 0c44 02       		.uleb128 0x2
 4925 0c45 91       		.byte	0x91
 4926 0c46 6C       		.sleb128 -20
 4927 0c47 1A       		.uleb128 0x1a
 4928 0c48 6A020000 		.4byte	.LASF122
 4929 0c4c 01       		.byte	0x1
 4930 0c4d E007     		.2byte	0x7e0
 4931 0c4f 02010000 		.4byte	0x102
 4932 0c53 02       		.uleb128 0x2
 4933 0c54 91       		.byte	0x91
 4934 0c55 70       		.sleb128 -16
 4935 0c56 1A       		.uleb128 0x1a
 4936 0c57 52070000 		.4byte	.LASF95
 4937 0c5b 01       		.byte	0x1
 4938 0c5c E107     		.2byte	0x7e1
 4939 0c5e 5D050000 		.4byte	0x55d
 4940 0c62 02       		.uleb128 0x2
 4941 0c63 91       		.byte	0x91
 4942 0c64 74       		.sleb128 -12
 4943 0c65 00       		.byte	0
 4944 0c66 1E       		.uleb128 0x1e
 4945 0c67 87020000 		.4byte	.LASF134
 4946 0c6b 01       		.byte	0x1
 4947 0c6c EA07     		.2byte	0x7ea
 4948 0c6e 00000000 		.4byte	.LFB15
 4949 0c72 40000000 		.4byte	.LFE15-.LFB15
 4950 0c76 01       		.uleb128 0x1
 4951 0c77 9C       		.byte	0x9c
 4952 0c78 9B0C0000 		.4byte	0xc9b
 4953 0c7c 19       		.uleb128 0x19
 4954 0c7d 01030000 		.4byte	.LASF79
 4955 0c81 01       		.byte	0x1
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 138


 4956 0c82 EA07     		.2byte	0x7ea
 4957 0c84 94030000 		.4byte	0x394
 4958 0c88 02       		.uleb128 0x2
 4959 0c89 91       		.byte	0x91
 4960 0c8a 6C       		.sleb128 -20
 4961 0c8b 1A       		.uleb128 0x1a
 4962 0c8c 52070000 		.4byte	.LASF95
 4963 0c90 01       		.byte	0x1
 4964 0c91 EC07     		.2byte	0x7ec
 4965 0c93 5D050000 		.4byte	0x55d
 4966 0c97 02       		.uleb128 0x2
 4967 0c98 91       		.byte	0x91
 4968 0c99 74       		.sleb128 -12
 4969 0c9a 00       		.byte	0
 4970 0c9b 1F       		.uleb128 0x1f
 4971 0c9c 22040000 		.4byte	.LASF129
 4972 0ca0 01       		.byte	0x1
 4973 0ca1 4E08     		.2byte	0x84e
 4974 0ca3 F7000000 		.4byte	0xf7
 4975 0ca7 00000000 		.4byte	.LFB16
 4976 0cab B8000000 		.4byte	.LFE16-.LFB16
 4977 0caf 01       		.uleb128 0x1
 4978 0cb0 9C       		.byte	0x9c
 4979 0cb1 010D0000 		.4byte	0xd01
 4980 0cb5 19       		.uleb128 0x19
 4981 0cb6 52070000 		.4byte	.LASF95
 4982 0cba 01       		.byte	0x1
 4983 0cbb 4E08     		.2byte	0x84e
 4984 0cbd 5D050000 		.4byte	0x55d
 4985 0cc1 02       		.uleb128 0x2
 4986 0cc2 91       		.byte	0x91
 4987 0cc3 6C       		.sleb128 -20
 4988 0cc4 19       		.uleb128 0x19
 4989 0cc5 E9060000 		.4byte	.LASF101
 4990 0cc9 01       		.byte	0x1
 4991 0cca 4F08     		.2byte	0x84f
 4992 0ccc C4000000 		.4byte	0xc4
 4993 0cd0 02       		.uleb128 0x2
 4994 0cd1 91       		.byte	0x91
 4995 0cd2 68       		.sleb128 -24
 4996 0cd3 19       		.uleb128 0x19
 4997 0cd4 BD080000 		.4byte	.LASF125
 4998 0cd8 01       		.byte	0x1
 4999 0cd9 5008     		.2byte	0x850
 5000 0cdb 74070000 		.4byte	0x774
 5001 0cdf 02       		.uleb128 0x2
 5002 0ce0 91       		.byte	0x91
 5003 0ce1 64       		.sleb128 -28
 5004 0ce2 1A       		.uleb128 0x1a
 5005 0ce3 64070000 		.4byte	.LASF109
 5006 0ce7 01       		.byte	0x1
 5007 0ce8 5208     		.2byte	0x852
 5008 0cea F7000000 		.4byte	0xf7
 5009 0cee 02       		.uleb128 0x2
 5010 0cef 91       		.byte	0x91
 5011 0cf0 70       		.sleb128 -16
 5012 0cf1 1A       		.uleb128 0x1a
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 139


 5013 0cf2 6C030000 		.4byte	.LASF65
 5014 0cf6 01       		.byte	0x1
 5015 0cf7 5308     		.2byte	0x853
 5016 0cf9 02010000 		.4byte	0x102
 5017 0cfd 02       		.uleb128 0x2
 5018 0cfe 91       		.byte	0x91
 5019 0cff 74       		.sleb128 -12
 5020 0d00 00       		.byte	0
 5021 0d01 1C       		.uleb128 0x1c
 5022 0d02 EE070000 		.4byte	.LASF127
 5023 0d06 01       		.byte	0x1
 5024 0d07 A108     		.2byte	0x8a1
 5025 0d09 00000000 		.4byte	.LFB17
 5026 0d0d 4C000000 		.4byte	.LFE17-.LFB17
 5027 0d11 01       		.uleb128 0x1
 5028 0d12 9C       		.byte	0x9c
 5029 0d13 360D0000 		.4byte	0xd36
 5030 0d17 19       		.uleb128 0x19
 5031 0d18 52070000 		.4byte	.LASF95
 5032 0d1c 01       		.byte	0x1
 5033 0d1d A108     		.2byte	0x8a1
 5034 0d1f 5D050000 		.4byte	0x55d
 5035 0d23 02       		.uleb128 0x2
 5036 0d24 91       		.byte	0x91
 5037 0d25 74       		.sleb128 -12
 5038 0d26 19       		.uleb128 0x19
 5039 0d27 3F030000 		.4byte	.LASF114
 5040 0d2b 01       		.byte	0x1
 5041 0d2c A208     		.2byte	0x8a2
 5042 0d2e 5B090000 		.4byte	0x95b
 5043 0d32 02       		.uleb128 0x2
 5044 0d33 91       		.byte	0x91
 5045 0d34 70       		.sleb128 -16
 5046 0d35 00       		.byte	0
 5047 0d36 1C       		.uleb128 0x1c
 5048 0d37 4E080000 		.4byte	.LASF128
 5049 0d3b 01       		.byte	0x1
 5050 0d3c B608     		.2byte	0x8b6
 5051 0d3e 00000000 		.4byte	.LFB18
 5052 0d42 C0000000 		.4byte	.LFE18-.LFB18
 5053 0d46 01       		.uleb128 0x1
 5054 0d47 9C       		.byte	0x9c
 5055 0d48 920D0000 		.4byte	0xd92
 5056 0d4c 19       		.uleb128 0x19
 5057 0d4d 52070000 		.4byte	.LASF95
 5058 0d51 01       		.byte	0x1
 5059 0d52 B608     		.2byte	0x8b6
 5060 0d54 5D050000 		.4byte	0x55d
 5061 0d58 02       		.uleb128 0x2
 5062 0d59 91       		.byte	0x91
 5063 0d5a 6C       		.sleb128 -20
 5064 0d5b 20       		.uleb128 0x20
 5065 0d5c 0C000000 		.4byte	.LBB11
 5066 0d60 50000000 		.4byte	.LBE11-.LBB11
 5067 0d64 780D0000 		.4byte	0xd78
 5068 0d68 1A       		.uleb128 0x1a
 5069 0d69 3D020000 		.4byte	.LASF69
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 140


 5070 0d6d 01       		.byte	0x1
 5071 0d6e C008     		.2byte	0x8c0
 5072 0d70 CB000000 		.4byte	0xcb
 5073 0d74 02       		.uleb128 0x2
 5074 0d75 91       		.byte	0x91
 5075 0d76 77       		.sleb128 -9
 5076 0d77 00       		.byte	0
 5077 0d78 1B       		.uleb128 0x1b
 5078 0d79 64000000 		.4byte	.LBB12
 5079 0d7d 50000000 		.4byte	.LBE12-.LBB12
 5080 0d81 1A       		.uleb128 0x1a
 5081 0d82 C7080000 		.4byte	.LASF68
 5082 0d86 01       		.byte	0x1
 5083 0d87 1109     		.2byte	0x911
 5084 0d89 CB000000 		.4byte	0xcb
 5085 0d8d 02       		.uleb128 0x2
 5086 0d8e 91       		.byte	0x91
 5087 0d8f 76       		.sleb128 -10
 5088 0d90 00       		.byte	0
 5089 0d91 00       		.byte	0
 5090 0d92 1F       		.uleb128 0x1f
 5091 0d93 2F030000 		.4byte	.LASF130
 5092 0d97 01       		.byte	0x1
 5093 0d98 2E09     		.2byte	0x92e
 5094 0d9a F7000000 		.4byte	0xf7
 5095 0d9e 00000000 		.4byte	.LFB19
 5096 0da2 2C000000 		.4byte	.LFE19-.LFB19
 5097 0da6 01       		.uleb128 0x1
 5098 0da7 9C       		.byte	0x9c
 5099 0da8 CB0D0000 		.4byte	0xdcb
 5100 0dac 19       		.uleb128 0x19
 5101 0dad 52070000 		.4byte	.LASF95
 5102 0db1 01       		.byte	0x1
 5103 0db2 2E09     		.2byte	0x92e
 5104 0db4 CB0D0000 		.4byte	0xdcb
 5105 0db8 02       		.uleb128 0x2
 5106 0db9 91       		.byte	0x91
 5107 0dba 6C       		.sleb128 -20
 5108 0dbb 1A       		.uleb128 0x1a
 5109 0dbc 64070000 		.4byte	.LASF109
 5110 0dc0 01       		.byte	0x1
 5111 0dc1 3009     		.2byte	0x930
 5112 0dc3 F7000000 		.4byte	0xf7
 5113 0dc7 02       		.uleb128 0x2
 5114 0dc8 91       		.byte	0x91
 5115 0dc9 74       		.sleb128 -12
 5116 0dca 00       		.byte	0
 5117 0dcb 06       		.uleb128 0x6
 5118 0dcc 04       		.byte	0x4
 5119 0dcd D10D0000 		.4byte	0xdd1
 5120 0dd1 07       		.uleb128 0x7
 5121 0dd2 C9040000 		.4byte	0x4c9
 5122 0dd6 1D       		.uleb128 0x1d
 5123 0dd7 70080000 		.4byte	.LASF131
 5124 0ddb 01       		.byte	0x1
 5125 0ddc 4309     		.2byte	0x943
 5126 0dde F7000000 		.4byte	0xf7
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 141


 5127 0de2 00000000 		.4byte	.LFB20
 5128 0de6 38000000 		.4byte	.LFE20-.LFB20
 5129 0dea 01       		.uleb128 0x1
 5130 0deb 9C       		.byte	0x9c
 5131 0dec 1E0E0000 		.4byte	0xe1e
 5132 0df0 19       		.uleb128 0x19
 5133 0df1 01030000 		.4byte	.LASF79
 5134 0df5 01       		.byte	0x1
 5135 0df6 4309     		.2byte	0x943
 5136 0df8 D10B0000 		.4byte	0xbd1
 5137 0dfc 02       		.uleb128 0x2
 5138 0dfd 91       		.byte	0x91
 5139 0dfe 6C       		.sleb128 -20
 5140 0dff 1A       		.uleb128 0x1a
 5141 0e00 64070000 		.4byte	.LASF109
 5142 0e04 01       		.byte	0x1
 5143 0e05 4509     		.2byte	0x945
 5144 0e07 F7000000 		.4byte	0xf7
 5145 0e0b 02       		.uleb128 0x2
 5146 0e0c 91       		.byte	0x91
 5147 0e0d 74       		.sleb128 -12
 5148 0e0e 1A       		.uleb128 0x1a
 5149 0e0f 52070000 		.4byte	.LASF95
 5150 0e13 01       		.byte	0x1
 5151 0e14 4609     		.2byte	0x946
 5152 0e16 5D050000 		.4byte	0x55d
 5153 0e1a 02       		.uleb128 0x2
 5154 0e1b 91       		.byte	0x91
 5155 0e1c 70       		.sleb128 -16
 5156 0e1d 00       		.byte	0
 5157 0e1e 1F       		.uleb128 0x1f
 5158 0e1f 92040000 		.4byte	.LASF132
 5159 0e23 01       		.byte	0x1
 5160 0e24 5709     		.2byte	0x957
 5161 0e26 F7000000 		.4byte	0xf7
 5162 0e2a 00000000 		.4byte	.LFB21
 5163 0e2e 30000000 		.4byte	.LFE21-.LFB21
 5164 0e32 01       		.uleb128 0x1
 5165 0e33 9C       		.byte	0x9c
 5166 0e34 570E0000 		.4byte	0xe57
 5167 0e38 19       		.uleb128 0x19
 5168 0e39 52070000 		.4byte	.LASF95
 5169 0e3d 01       		.byte	0x1
 5170 0e3e 5709     		.2byte	0x957
 5171 0e40 CB0D0000 		.4byte	0xdcb
 5172 0e44 02       		.uleb128 0x2
 5173 0e45 91       		.byte	0x91
 5174 0e46 6C       		.sleb128 -20
 5175 0e47 1A       		.uleb128 0x1a
 5176 0e48 64070000 		.4byte	.LASF109
 5177 0e4c 01       		.byte	0x1
 5178 0e4d 5909     		.2byte	0x959
 5179 0e4f F7000000 		.4byte	0xf7
 5180 0e53 02       		.uleb128 0x2
 5181 0e54 91       		.byte	0x91
 5182 0e55 74       		.sleb128 -12
 5183 0e56 00       		.byte	0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 142


 5184 0e57 1D       		.uleb128 0x1d
 5185 0e58 F7060000 		.4byte	.LASF133
 5186 0e5c 01       		.byte	0x1
 5187 0e5d 6C09     		.2byte	0x96c
 5188 0e5f F7000000 		.4byte	0xf7
 5189 0e63 00000000 		.4byte	.LFB22
 5190 0e67 3C000000 		.4byte	.LFE22-.LFB22
 5191 0e6b 01       		.uleb128 0x1
 5192 0e6c 9C       		.byte	0x9c
 5193 0e6d 9F0E0000 		.4byte	0xe9f
 5194 0e71 19       		.uleb128 0x19
 5195 0e72 01030000 		.4byte	.LASF79
 5196 0e76 01       		.byte	0x1
 5197 0e77 6C09     		.2byte	0x96c
 5198 0e79 D10B0000 		.4byte	0xbd1
 5199 0e7d 02       		.uleb128 0x2
 5200 0e7e 91       		.byte	0x91
 5201 0e7f 6C       		.sleb128 -20
 5202 0e80 1A       		.uleb128 0x1a
 5203 0e81 64070000 		.4byte	.LASF109
 5204 0e85 01       		.byte	0x1
 5205 0e86 6E09     		.2byte	0x96e
 5206 0e88 F7000000 		.4byte	0xf7
 5207 0e8c 02       		.uleb128 0x2
 5208 0e8d 91       		.byte	0x91
 5209 0e8e 74       		.sleb128 -12
 5210 0e8f 1A       		.uleb128 0x1a
 5211 0e90 52070000 		.4byte	.LASF95
 5212 0e94 01       		.byte	0x1
 5213 0e95 6F09     		.2byte	0x96f
 5214 0e97 5D050000 		.4byte	0x55d
 5215 0e9b 02       		.uleb128 0x2
 5216 0e9c 91       		.byte	0x91
 5217 0e9d 70       		.sleb128 -16
 5218 0e9e 00       		.byte	0
 5219 0e9f 21       		.uleb128 0x21
 5220 0ea0 95050000 		.4byte	.LASF135
 5221 0ea4 01       		.byte	0x1
 5222 0ea5 A10A     		.2byte	0xaa1
 5223 0ea7 00000000 		.4byte	.LFB23
 5224 0eab 50000000 		.4byte	.LFE23-.LFB23
 5225 0eaf 01       		.uleb128 0x1
 5226 0eb0 9C       		.byte	0x9c
 5227 0eb1 E20E0000 		.4byte	0xee2
 5228 0eb5 19       		.uleb128 0x19
 5229 0eb6 01030000 		.4byte	.LASF79
 5230 0eba 01       		.byte	0x1
 5231 0ebb A10A     		.2byte	0xaa1
 5232 0ebd 94030000 		.4byte	0x394
 5233 0ec1 02       		.uleb128 0x2
 5234 0ec2 91       		.byte	0x91
 5235 0ec3 6C       		.sleb128 -20
 5236 0ec4 19       		.uleb128 0x19
 5237 0ec5 BA030000 		.4byte	.LASF84
 5238 0ec9 01       		.byte	0x1
 5239 0eca A20A     		.2byte	0xaa2
 5240 0ecc B9000000 		.4byte	0xb9
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 143


 5241 0ed0 02       		.uleb128 0x2
 5242 0ed1 91       		.byte	0x91
 5243 0ed2 68       		.sleb128 -24
 5244 0ed3 22       		.uleb128 0x22
 5245 0ed4 757800   		.ascii	"ux\000"
 5246 0ed7 01       		.byte	0x1
 5247 0ed8 A40A     		.2byte	0xaa4
 5248 0eda 02010000 		.4byte	0x102
 5249 0ede 02       		.uleb128 0x2
 5250 0edf 91       		.byte	0x91
 5251 0ee0 74       		.sleb128 -12
 5252 0ee1 00       		.byte	0
 5253 0ee2 1D       		.uleb128 0x1d
 5254 0ee3 6C060000 		.4byte	.LASF136
 5255 0ee7 01       		.byte	0x1
 5256 0ee8 BF0A     		.2byte	0xabf
 5257 0eea B9000000 		.4byte	0xb9
 5258 0eee 00000000 		.4byte	.LFB24
 5259 0ef2 4C000000 		.4byte	.LFE24-.LFB24
 5260 0ef6 01       		.uleb128 0x1
 5261 0ef7 9C       		.byte	0x9c
 5262 0ef8 290F0000 		.4byte	0xf29
 5263 0efc 19       		.uleb128 0x19
 5264 0efd 01030000 		.4byte	.LASF79
 5265 0f01 01       		.byte	0x1
 5266 0f02 BF0A     		.2byte	0xabf
 5267 0f04 94030000 		.4byte	0x394
 5268 0f08 02       		.uleb128 0x2
 5269 0f09 91       		.byte	0x91
 5270 0f0a 6C       		.sleb128 -20
 5271 0f0b 22       		.uleb128 0x22
 5272 0f0c 757800   		.ascii	"ux\000"
 5273 0f0f 01       		.byte	0x1
 5274 0f10 C10A     		.2byte	0xac1
 5275 0f12 02010000 		.4byte	0x102
 5276 0f16 02       		.uleb128 0x2
 5277 0f17 91       		.byte	0x91
 5278 0f18 74       		.sleb128 -12
 5279 0f19 1A       		.uleb128 0x1a
 5280 0f1a 2E060000 		.4byte	.LASF137
 5281 0f1e 01       		.byte	0x1
 5282 0f1f C20A     		.2byte	0xac2
 5283 0f21 B9000000 		.4byte	0xb9
 5284 0f25 02       		.uleb128 0x2
 5285 0f26 91       		.byte	0x91
 5286 0f27 70       		.sleb128 -16
 5287 0f28 00       		.byte	0
 5288 0f29 21       		.uleb128 0x21
 5289 0f2a 9F020000 		.4byte	.LASF138
 5290 0f2e 01       		.byte	0x1
 5291 0f2f DC0A     		.2byte	0xadc
 5292 0f31 00000000 		.4byte	.LFB25
 5293 0f35 54000000 		.4byte	.LFE25-.LFB25
 5294 0f39 01       		.uleb128 0x1
 5295 0f3a 9C       		.byte	0x9c
 5296 0f3b 5D0F0000 		.4byte	0xf5d
 5297 0f3f 19       		.uleb128 0x19
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 144


 5298 0f40 01030000 		.4byte	.LASF79
 5299 0f44 01       		.byte	0x1
 5300 0f45 DC0A     		.2byte	0xadc
 5301 0f47 94030000 		.4byte	0x394
 5302 0f4b 02       		.uleb128 0x2
 5303 0f4c 91       		.byte	0x91
 5304 0f4d 6C       		.sleb128 -20
 5305 0f4e 22       		.uleb128 0x22
 5306 0f4f 757800   		.ascii	"ux\000"
 5307 0f52 01       		.byte	0x1
 5308 0f53 DE0A     		.2byte	0xade
 5309 0f55 02010000 		.4byte	0x102
 5310 0f59 02       		.uleb128 0x2
 5311 0f5a 91       		.byte	0x91
 5312 0f5b 74       		.sleb128 -12
 5313 0f5c 00       		.byte	0
 5314 0f5d 1E       		.uleb128 0x1e
 5315 0f5e 9A060000 		.4byte	.LASF139
 5316 0f62 01       		.byte	0x1
 5317 0f63 FB0A     		.2byte	0xafb
 5318 0f65 00000000 		.4byte	.LFB26
 5319 0f69 66000000 		.4byte	.LFE26-.LFB26
 5320 0f6d 01       		.uleb128 0x1
 5321 0f6e 9C       		.byte	0x9c
 5322 0f6f B00F0000 		.4byte	0xfb0
 5323 0f73 19       		.uleb128 0x19
 5324 0f74 01030000 		.4byte	.LASF79
 5325 0f78 01       		.byte	0x1
 5326 0f79 FB0A     		.2byte	0xafb
 5327 0f7b 94030000 		.4byte	0x394
 5328 0f7f 02       		.uleb128 0x2
 5329 0f80 91       		.byte	0x91
 5330 0f81 6C       		.sleb128 -20
 5331 0f82 19       		.uleb128 0x19
 5332 0f83 03080000 		.4byte	.LASF102
 5333 0f87 01       		.byte	0x1
 5334 0f88 FC0A     		.2byte	0xafc
 5335 0f8a 0D010000 		.4byte	0x10d
 5336 0f8e 02       		.uleb128 0x2
 5337 0f8f 91       		.byte	0x91
 5338 0f90 68       		.sleb128 -24
 5339 0f91 19       		.uleb128 0x19
 5340 0f92 00020000 		.4byte	.LASF140
 5341 0f96 01       		.byte	0x1
 5342 0f97 FD0A     		.2byte	0xafd
 5343 0f99 74070000 		.4byte	0x774
 5344 0f9d 02       		.uleb128 0x2
 5345 0f9e 91       		.byte	0x91
 5346 0f9f 64       		.sleb128 -28
 5347 0fa0 1A       		.uleb128 0x1a
 5348 0fa1 52070000 		.4byte	.LASF95
 5349 0fa5 01       		.byte	0x1
 5350 0fa6 FF0A     		.2byte	0xaff
 5351 0fa8 5D050000 		.4byte	0x55d
 5352 0fac 02       		.uleb128 0x2
 5353 0fad 91       		.byte	0x91
 5354 0fae 74       		.sleb128 -12
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 145


 5355 0faf 00       		.byte	0
 5356 0fb0 23       		.uleb128 0x23
 5357 0fb1 7800     		.ascii	"x\000"
 5358 0fb3 0A       		.byte	0xa
 5359 0fb4 04       		.byte	0x4
 5360 0fb5 E1000000 		.4byte	0xe1
 5361 0fb9 05       		.uleb128 0x5
 5362 0fba 03       		.byte	0x3
 5363 0fbb 00000000 		.4byte	x
 5364 0fbf 0B       		.uleb128 0xb
 5365 0fc0 04050000 		.4byte	0x504
 5366 0fc4 CF0F0000 		.4byte	0xfcf
 5367 0fc8 0C       		.uleb128 0xc
 5368 0fc9 A9000000 		.4byte	0xa9
 5369 0fcd 09       		.byte	0x9
 5370 0fce 00       		.byte	0
 5371 0fcf 24       		.uleb128 0x24
 5372 0fd0 CD040000 		.4byte	.LASF141
 5373 0fd4 01       		.byte	0x1
 5374 0fd5 A2       		.byte	0xa2
 5375 0fd6 BF0F0000 		.4byte	0xfbf
 5376 0fda 05       		.uleb128 0x5
 5377 0fdb 03       		.byte	0x3
 5378 0fdc 00000000 		.4byte	xQueueRegistry
 5379 0fe0 00       		.byte	0
 5380              		.section	.debug_abbrev,"",%progbits
 5381              	.Ldebug_abbrev0:
 5382 0000 01       		.uleb128 0x1
 5383 0001 11       		.uleb128 0x11
 5384 0002 01       		.byte	0x1
 5385 0003 25       		.uleb128 0x25
 5386 0004 0E       		.uleb128 0xe
 5387 0005 13       		.uleb128 0x13
 5388 0006 0B       		.uleb128 0xb
 5389 0007 03       		.uleb128 0x3
 5390 0008 0E       		.uleb128 0xe
 5391 0009 1B       		.uleb128 0x1b
 5392 000a 0E       		.uleb128 0xe
 5393 000b 55       		.uleb128 0x55
 5394 000c 17       		.uleb128 0x17
 5395 000d 11       		.uleb128 0x11
 5396 000e 01       		.uleb128 0x1
 5397 000f 10       		.uleb128 0x10
 5398 0010 17       		.uleb128 0x17
 5399 0011 00       		.byte	0
 5400 0012 00       		.byte	0
 5401 0013 02       		.uleb128 0x2
 5402 0014 16       		.uleb128 0x16
 5403 0015 00       		.byte	0
 5404 0016 03       		.uleb128 0x3
 5405 0017 0E       		.uleb128 0xe
 5406 0018 3A       		.uleb128 0x3a
 5407 0019 0B       		.uleb128 0xb
 5408 001a 3B       		.uleb128 0x3b
 5409 001b 0B       		.uleb128 0xb
 5410 001c 49       		.uleb128 0x49
 5411 001d 13       		.uleb128 0x13
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 146


 5412 001e 00       		.byte	0
 5413 001f 00       		.byte	0
 5414 0020 03       		.uleb128 0x3
 5415 0021 24       		.uleb128 0x24
 5416 0022 00       		.byte	0
 5417 0023 0B       		.uleb128 0xb
 5418 0024 0B       		.uleb128 0xb
 5419 0025 3E       		.uleb128 0x3e
 5420 0026 0B       		.uleb128 0xb
 5421 0027 03       		.uleb128 0x3
 5422 0028 0E       		.uleb128 0xe
 5423 0029 00       		.byte	0
 5424 002a 00       		.byte	0
 5425 002b 04       		.uleb128 0x4
 5426 002c 24       		.uleb128 0x24
 5427 002d 00       		.byte	0
 5428 002e 0B       		.uleb128 0xb
 5429 002f 0B       		.uleb128 0xb
 5430 0030 3E       		.uleb128 0x3e
 5431 0031 0B       		.uleb128 0xb
 5432 0032 03       		.uleb128 0x3
 5433 0033 08       		.uleb128 0x8
 5434 0034 00       		.byte	0
 5435 0035 00       		.byte	0
 5436 0036 05       		.uleb128 0x5
 5437 0037 0F       		.uleb128 0xf
 5438 0038 00       		.byte	0
 5439 0039 0B       		.uleb128 0xb
 5440 003a 0B       		.uleb128 0xb
 5441 003b 00       		.byte	0
 5442 003c 00       		.byte	0
 5443 003d 06       		.uleb128 0x6
 5444 003e 0F       		.uleb128 0xf
 5445 003f 00       		.byte	0
 5446 0040 0B       		.uleb128 0xb
 5447 0041 0B       		.uleb128 0xb
 5448 0042 49       		.uleb128 0x49
 5449 0043 13       		.uleb128 0x13
 5450 0044 00       		.byte	0
 5451 0045 00       		.byte	0
 5452 0046 07       		.uleb128 0x7
 5453 0047 26       		.uleb128 0x26
 5454 0048 00       		.byte	0
 5455 0049 49       		.uleb128 0x49
 5456 004a 13       		.uleb128 0x13
 5457 004b 00       		.byte	0
 5458 004c 00       		.byte	0
 5459 004d 08       		.uleb128 0x8
 5460 004e 26       		.uleb128 0x26
 5461 004f 00       		.byte	0
 5462 0050 00       		.byte	0
 5463 0051 00       		.byte	0
 5464 0052 09       		.uleb128 0x9
 5465 0053 13       		.uleb128 0x13
 5466 0054 01       		.byte	0x1
 5467 0055 03       		.uleb128 0x3
 5468 0056 0E       		.uleb128 0xe
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 147


 5469 0057 0B       		.uleb128 0xb
 5470 0058 0B       		.uleb128 0xb
 5471 0059 3A       		.uleb128 0x3a
 5472 005a 0B       		.uleb128 0xb
 5473 005b 3B       		.uleb128 0x3b
 5474 005c 05       		.uleb128 0x5
 5475 005d 01       		.uleb128 0x1
 5476 005e 13       		.uleb128 0x13
 5477 005f 00       		.byte	0
 5478 0060 00       		.byte	0
 5479 0061 0A       		.uleb128 0xa
 5480 0062 0D       		.uleb128 0xd
 5481 0063 00       		.byte	0
 5482 0064 03       		.uleb128 0x3
 5483 0065 0E       		.uleb128 0xe
 5484 0066 3A       		.uleb128 0x3a
 5485 0067 0B       		.uleb128 0xb
 5486 0068 3B       		.uleb128 0x3b
 5487 0069 05       		.uleb128 0x5
 5488 006a 49       		.uleb128 0x49
 5489 006b 13       		.uleb128 0x13
 5490 006c 38       		.uleb128 0x38
 5491 006d 0B       		.uleb128 0xb
 5492 006e 00       		.byte	0
 5493 006f 00       		.byte	0
 5494 0070 0B       		.uleb128 0xb
 5495 0071 01       		.uleb128 0x1
 5496 0072 01       		.byte	0x1
 5497 0073 49       		.uleb128 0x49
 5498 0074 13       		.uleb128 0x13
 5499 0075 01       		.uleb128 0x1
 5500 0076 13       		.uleb128 0x13
 5501 0077 00       		.byte	0
 5502 0078 00       		.byte	0
 5503 0079 0C       		.uleb128 0xc
 5504 007a 21       		.uleb128 0x21
 5505 007b 00       		.byte	0
 5506 007c 49       		.uleb128 0x49
 5507 007d 13       		.uleb128 0x13
 5508 007e 2F       		.uleb128 0x2f
 5509 007f 0B       		.uleb128 0xb
 5510 0080 00       		.byte	0
 5511 0081 00       		.byte	0
 5512 0082 0D       		.uleb128 0xd
 5513 0083 16       		.uleb128 0x16
 5514 0084 00       		.byte	0
 5515 0085 03       		.uleb128 0x3
 5516 0086 0E       		.uleb128 0xe
 5517 0087 3A       		.uleb128 0x3a
 5518 0088 0B       		.uleb128 0xb
 5519 0089 3B       		.uleb128 0x3b
 5520 008a 05       		.uleb128 0x5
 5521 008b 49       		.uleb128 0x49
 5522 008c 13       		.uleb128 0x13
 5523 008d 00       		.byte	0
 5524 008e 00       		.byte	0
 5525 008f 0E       		.uleb128 0xe
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 148


 5526 0090 17       		.uleb128 0x17
 5527 0091 01       		.byte	0x1
 5528 0092 0B       		.uleb128 0xb
 5529 0093 0B       		.uleb128 0xb
 5530 0094 3A       		.uleb128 0x3a
 5531 0095 0B       		.uleb128 0xb
 5532 0096 3B       		.uleb128 0x3b
 5533 0097 05       		.uleb128 0x5
 5534 0098 01       		.uleb128 0x1
 5535 0099 13       		.uleb128 0x13
 5536 009a 00       		.byte	0
 5537 009b 00       		.byte	0
 5538 009c 0F       		.uleb128 0xf
 5539 009d 0D       		.uleb128 0xd
 5540 009e 00       		.byte	0
 5541 009f 03       		.uleb128 0x3
 5542 00a0 0E       		.uleb128 0xe
 5543 00a1 3A       		.uleb128 0x3a
 5544 00a2 0B       		.uleb128 0xb
 5545 00a3 3B       		.uleb128 0x3b
 5546 00a4 05       		.uleb128 0x5
 5547 00a5 49       		.uleb128 0x49
 5548 00a6 13       		.uleb128 0x13
 5549 00a7 00       		.byte	0
 5550 00a8 00       		.byte	0
 5551 00a9 10       		.uleb128 0x10
 5552 00aa 0D       		.uleb128 0xd
 5553 00ab 00       		.byte	0
 5554 00ac 03       		.uleb128 0x3
 5555 00ad 08       		.uleb128 0x8
 5556 00ae 3A       		.uleb128 0x3a
 5557 00af 0B       		.uleb128 0xb
 5558 00b0 3B       		.uleb128 0x3b
 5559 00b1 05       		.uleb128 0x5
 5560 00b2 49       		.uleb128 0x49
 5561 00b3 13       		.uleb128 0x13
 5562 00b4 38       		.uleb128 0x38
 5563 00b5 0B       		.uleb128 0xb
 5564 00b6 00       		.byte	0
 5565 00b7 00       		.byte	0
 5566 00b8 11       		.uleb128 0x11
 5567 00b9 13       		.uleb128 0x13
 5568 00ba 01       		.byte	0x1
 5569 00bb 03       		.uleb128 0x3
 5570 00bc 0E       		.uleb128 0xe
 5571 00bd 0B       		.uleb128 0xb
 5572 00be 0B       		.uleb128 0xb
 5573 00bf 3A       		.uleb128 0x3a
 5574 00c0 0B       		.uleb128 0xb
 5575 00c1 3B       		.uleb128 0x3b
 5576 00c2 0B       		.uleb128 0xb
 5577 00c3 01       		.uleb128 0x1
 5578 00c4 13       		.uleb128 0x13
 5579 00c5 00       		.byte	0
 5580 00c6 00       		.byte	0
 5581 00c7 12       		.uleb128 0x12
 5582 00c8 0D       		.uleb128 0xd
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 149


 5583 00c9 00       		.byte	0
 5584 00ca 03       		.uleb128 0x3
 5585 00cb 0E       		.uleb128 0xe
 5586 00cc 3A       		.uleb128 0x3a
 5587 00cd 0B       		.uleb128 0xb
 5588 00ce 3B       		.uleb128 0x3b
 5589 00cf 0B       		.uleb128 0xb
 5590 00d0 49       		.uleb128 0x49
 5591 00d1 13       		.uleb128 0x13
 5592 00d2 38       		.uleb128 0x38
 5593 00d3 0B       		.uleb128 0xb
 5594 00d4 00       		.byte	0
 5595 00d5 00       		.byte	0
 5596 00d6 13       		.uleb128 0x13
 5597 00d7 35       		.uleb128 0x35
 5598 00d8 00       		.byte	0
 5599 00d9 49       		.uleb128 0x49
 5600 00da 13       		.uleb128 0x13
 5601 00db 00       		.byte	0
 5602 00dc 00       		.byte	0
 5603 00dd 14       		.uleb128 0x14
 5604 00de 13       		.uleb128 0x13
 5605 00df 00       		.byte	0
 5606 00e0 03       		.uleb128 0x3
 5607 00e1 0E       		.uleb128 0xe
 5608 00e2 3C       		.uleb128 0x3c
 5609 00e3 19       		.uleb128 0x19
 5610 00e4 00       		.byte	0
 5611 00e5 00       		.byte	0
 5612 00e6 15       		.uleb128 0x15
 5613 00e7 0D       		.uleb128 0xd
 5614 00e8 00       		.byte	0
 5615 00e9 03       		.uleb128 0x3
 5616 00ea 08       		.uleb128 0x8
 5617 00eb 3A       		.uleb128 0x3a
 5618 00ec 0B       		.uleb128 0xb
 5619 00ed 3B       		.uleb128 0x3b
 5620 00ee 0B       		.uleb128 0xb
 5621 00ef 49       		.uleb128 0x49
 5622 00f0 13       		.uleb128 0x13
 5623 00f1 38       		.uleb128 0x38
 5624 00f2 0B       		.uleb128 0xb
 5625 00f3 00       		.byte	0
 5626 00f4 00       		.byte	0
 5627 00f5 16       		.uleb128 0x16
 5628 00f6 17       		.uleb128 0x17
 5629 00f7 01       		.byte	0x1
 5630 00f8 0B       		.uleb128 0xb
 5631 00f9 0B       		.uleb128 0xb
 5632 00fa 3A       		.uleb128 0x3a
 5633 00fb 0B       		.uleb128 0xb
 5634 00fc 3B       		.uleb128 0x3b
 5635 00fd 0B       		.uleb128 0xb
 5636 00fe 01       		.uleb128 0x1
 5637 00ff 13       		.uleb128 0x13
 5638 0100 00       		.byte	0
 5639 0101 00       		.byte	0
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 150


 5640 0102 17       		.uleb128 0x17
 5641 0103 0D       		.uleb128 0xd
 5642 0104 00       		.byte	0
 5643 0105 03       		.uleb128 0x3
 5644 0106 0E       		.uleb128 0xe
 5645 0107 3A       		.uleb128 0x3a
 5646 0108 0B       		.uleb128 0xb
 5647 0109 3B       		.uleb128 0x3b
 5648 010a 0B       		.uleb128 0xb
 5649 010b 49       		.uleb128 0x49
 5650 010c 13       		.uleb128 0x13
 5651 010d 00       		.byte	0
 5652 010e 00       		.byte	0
 5653 010f 18       		.uleb128 0x18
 5654 0110 2E       		.uleb128 0x2e
 5655 0111 01       		.byte	0x1
 5656 0112 3F       		.uleb128 0x3f
 5657 0113 19       		.uleb128 0x19
 5658 0114 03       		.uleb128 0x3
 5659 0115 0E       		.uleb128 0xe
 5660 0116 3A       		.uleb128 0x3a
 5661 0117 0B       		.uleb128 0xb
 5662 0118 3B       		.uleb128 0x3b
 5663 0119 05       		.uleb128 0x5
 5664 011a 27       		.uleb128 0x27
 5665 011b 19       		.uleb128 0x19
 5666 011c 49       		.uleb128 0x49
 5667 011d 13       		.uleb128 0x13
 5668 011e 11       		.uleb128 0x11
 5669 011f 01       		.uleb128 0x1
 5670 0120 12       		.uleb128 0x12
 5671 0121 06       		.uleb128 0x6
 5672 0122 40       		.uleb128 0x40
 5673 0123 18       		.uleb128 0x18
 5674 0124 9642     		.uleb128 0x2116
 5675 0126 19       		.uleb128 0x19
 5676 0127 01       		.uleb128 0x1
 5677 0128 13       		.uleb128 0x13
 5678 0129 00       		.byte	0
 5679 012a 00       		.byte	0
 5680 012b 19       		.uleb128 0x19
 5681 012c 05       		.uleb128 0x5
 5682 012d 00       		.byte	0
 5683 012e 03       		.uleb128 0x3
 5684 012f 0E       		.uleb128 0xe
 5685 0130 3A       		.uleb128 0x3a
 5686 0131 0B       		.uleb128 0xb
 5687 0132 3B       		.uleb128 0x3b
 5688 0133 05       		.uleb128 0x5
 5689 0134 49       		.uleb128 0x49
 5690 0135 13       		.uleb128 0x13
 5691 0136 02       		.uleb128 0x2
 5692 0137 18       		.uleb128 0x18
 5693 0138 00       		.byte	0
 5694 0139 00       		.byte	0
 5695 013a 1A       		.uleb128 0x1a
 5696 013b 34       		.uleb128 0x34
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 151


 5697 013c 00       		.byte	0
 5698 013d 03       		.uleb128 0x3
 5699 013e 0E       		.uleb128 0xe
 5700 013f 3A       		.uleb128 0x3a
 5701 0140 0B       		.uleb128 0xb
 5702 0141 3B       		.uleb128 0x3b
 5703 0142 05       		.uleb128 0x5
 5704 0143 49       		.uleb128 0x49
 5705 0144 13       		.uleb128 0x13
 5706 0145 02       		.uleb128 0x2
 5707 0146 18       		.uleb128 0x18
 5708 0147 00       		.byte	0
 5709 0148 00       		.byte	0
 5710 0149 1B       		.uleb128 0x1b
 5711 014a 0B       		.uleb128 0xb
 5712 014b 01       		.byte	0x1
 5713 014c 11       		.uleb128 0x11
 5714 014d 01       		.uleb128 0x1
 5715 014e 12       		.uleb128 0x12
 5716 014f 06       		.uleb128 0x6
 5717 0150 00       		.byte	0
 5718 0151 00       		.byte	0
 5719 0152 1C       		.uleb128 0x1c
 5720 0153 2E       		.uleb128 0x2e
 5721 0154 01       		.byte	0x1
 5722 0155 03       		.uleb128 0x3
 5723 0156 0E       		.uleb128 0xe
 5724 0157 3A       		.uleb128 0x3a
 5725 0158 0B       		.uleb128 0xb
 5726 0159 3B       		.uleb128 0x3b
 5727 015a 05       		.uleb128 0x5
 5728 015b 27       		.uleb128 0x27
 5729 015c 19       		.uleb128 0x19
 5730 015d 11       		.uleb128 0x11
 5731 015e 01       		.uleb128 0x1
 5732 015f 12       		.uleb128 0x12
 5733 0160 06       		.uleb128 0x6
 5734 0161 40       		.uleb128 0x40
 5735 0162 18       		.uleb128 0x18
 5736 0163 9642     		.uleb128 0x2116
 5737 0165 19       		.uleb128 0x19
 5738 0166 01       		.uleb128 0x1
 5739 0167 13       		.uleb128 0x13
 5740 0168 00       		.byte	0
 5741 0169 00       		.byte	0
 5742 016a 1D       		.uleb128 0x1d
 5743 016b 2E       		.uleb128 0x2e
 5744 016c 01       		.byte	0x1
 5745 016d 3F       		.uleb128 0x3f
 5746 016e 19       		.uleb128 0x19
 5747 016f 03       		.uleb128 0x3
 5748 0170 0E       		.uleb128 0xe
 5749 0171 3A       		.uleb128 0x3a
 5750 0172 0B       		.uleb128 0xb
 5751 0173 3B       		.uleb128 0x3b
 5752 0174 05       		.uleb128 0x5
 5753 0175 27       		.uleb128 0x27
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 152


 5754 0176 19       		.uleb128 0x19
 5755 0177 49       		.uleb128 0x49
 5756 0178 13       		.uleb128 0x13
 5757 0179 11       		.uleb128 0x11
 5758 017a 01       		.uleb128 0x1
 5759 017b 12       		.uleb128 0x12
 5760 017c 06       		.uleb128 0x6
 5761 017d 40       		.uleb128 0x40
 5762 017e 18       		.uleb128 0x18
 5763 017f 9742     		.uleb128 0x2117
 5764 0181 19       		.uleb128 0x19
 5765 0182 01       		.uleb128 0x1
 5766 0183 13       		.uleb128 0x13
 5767 0184 00       		.byte	0
 5768 0185 00       		.byte	0
 5769 0186 1E       		.uleb128 0x1e
 5770 0187 2E       		.uleb128 0x2e
 5771 0188 01       		.byte	0x1
 5772 0189 3F       		.uleb128 0x3f
 5773 018a 19       		.uleb128 0x19
 5774 018b 03       		.uleb128 0x3
 5775 018c 0E       		.uleb128 0xe
 5776 018d 3A       		.uleb128 0x3a
 5777 018e 0B       		.uleb128 0xb
 5778 018f 3B       		.uleb128 0x3b
 5779 0190 05       		.uleb128 0x5
 5780 0191 27       		.uleb128 0x27
 5781 0192 19       		.uleb128 0x19
 5782 0193 11       		.uleb128 0x11
 5783 0194 01       		.uleb128 0x1
 5784 0195 12       		.uleb128 0x12
 5785 0196 06       		.uleb128 0x6
 5786 0197 40       		.uleb128 0x40
 5787 0198 18       		.uleb128 0x18
 5788 0199 9642     		.uleb128 0x2116
 5789 019b 19       		.uleb128 0x19
 5790 019c 01       		.uleb128 0x1
 5791 019d 13       		.uleb128 0x13
 5792 019e 00       		.byte	0
 5793 019f 00       		.byte	0
 5794 01a0 1F       		.uleb128 0x1f
 5795 01a1 2E       		.uleb128 0x2e
 5796 01a2 01       		.byte	0x1
 5797 01a3 03       		.uleb128 0x3
 5798 01a4 0E       		.uleb128 0xe
 5799 01a5 3A       		.uleb128 0x3a
 5800 01a6 0B       		.uleb128 0xb
 5801 01a7 3B       		.uleb128 0x3b
 5802 01a8 05       		.uleb128 0x5
 5803 01a9 27       		.uleb128 0x27
 5804 01aa 19       		.uleb128 0x19
 5805 01ab 49       		.uleb128 0x49
 5806 01ac 13       		.uleb128 0x13
 5807 01ad 11       		.uleb128 0x11
 5808 01ae 01       		.uleb128 0x1
 5809 01af 12       		.uleb128 0x12
 5810 01b0 06       		.uleb128 0x6
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 153


 5811 01b1 40       		.uleb128 0x40
 5812 01b2 18       		.uleb128 0x18
 5813 01b3 9642     		.uleb128 0x2116
 5814 01b5 19       		.uleb128 0x19
 5815 01b6 01       		.uleb128 0x1
 5816 01b7 13       		.uleb128 0x13
 5817 01b8 00       		.byte	0
 5818 01b9 00       		.byte	0
 5819 01ba 20       		.uleb128 0x20
 5820 01bb 0B       		.uleb128 0xb
 5821 01bc 01       		.byte	0x1
 5822 01bd 11       		.uleb128 0x11
 5823 01be 01       		.uleb128 0x1
 5824 01bf 12       		.uleb128 0x12
 5825 01c0 06       		.uleb128 0x6
 5826 01c1 01       		.uleb128 0x1
 5827 01c2 13       		.uleb128 0x13
 5828 01c3 00       		.byte	0
 5829 01c4 00       		.byte	0
 5830 01c5 21       		.uleb128 0x21
 5831 01c6 2E       		.uleb128 0x2e
 5832 01c7 01       		.byte	0x1
 5833 01c8 3F       		.uleb128 0x3f
 5834 01c9 19       		.uleb128 0x19
 5835 01ca 03       		.uleb128 0x3
 5836 01cb 0E       		.uleb128 0xe
 5837 01cc 3A       		.uleb128 0x3a
 5838 01cd 0B       		.uleb128 0xb
 5839 01ce 3B       		.uleb128 0x3b
 5840 01cf 05       		.uleb128 0x5
 5841 01d0 27       		.uleb128 0x27
 5842 01d1 19       		.uleb128 0x19
 5843 01d2 11       		.uleb128 0x11
 5844 01d3 01       		.uleb128 0x1
 5845 01d4 12       		.uleb128 0x12
 5846 01d5 06       		.uleb128 0x6
 5847 01d6 40       		.uleb128 0x40
 5848 01d7 18       		.uleb128 0x18
 5849 01d8 9742     		.uleb128 0x2117
 5850 01da 19       		.uleb128 0x19
 5851 01db 01       		.uleb128 0x1
 5852 01dc 13       		.uleb128 0x13
 5853 01dd 00       		.byte	0
 5854 01de 00       		.byte	0
 5855 01df 22       		.uleb128 0x22
 5856 01e0 34       		.uleb128 0x34
 5857 01e1 00       		.byte	0
 5858 01e2 03       		.uleb128 0x3
 5859 01e3 08       		.uleb128 0x8
 5860 01e4 3A       		.uleb128 0x3a
 5861 01e5 0B       		.uleb128 0xb
 5862 01e6 3B       		.uleb128 0x3b
 5863 01e7 05       		.uleb128 0x5
 5864 01e8 49       		.uleb128 0x49
 5865 01e9 13       		.uleb128 0x13
 5866 01ea 02       		.uleb128 0x2
 5867 01eb 18       		.uleb128 0x18
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 154


 5868 01ec 00       		.byte	0
 5869 01ed 00       		.byte	0
 5870 01ee 23       		.uleb128 0x23
 5871 01ef 34       		.uleb128 0x34
 5872 01f0 00       		.byte	0
 5873 01f1 03       		.uleb128 0x3
 5874 01f2 08       		.uleb128 0x8
 5875 01f3 3A       		.uleb128 0x3a
 5876 01f4 0B       		.uleb128 0xb
 5877 01f5 3B       		.uleb128 0x3b
 5878 01f6 0B       		.uleb128 0xb
 5879 01f7 49       		.uleb128 0x49
 5880 01f8 13       		.uleb128 0x13
 5881 01f9 3F       		.uleb128 0x3f
 5882 01fa 19       		.uleb128 0x19
 5883 01fb 02       		.uleb128 0x2
 5884 01fc 18       		.uleb128 0x18
 5885 01fd 00       		.byte	0
 5886 01fe 00       		.byte	0
 5887 01ff 24       		.uleb128 0x24
 5888 0200 34       		.uleb128 0x34
 5889 0201 00       		.byte	0
 5890 0202 03       		.uleb128 0x3
 5891 0203 0E       		.uleb128 0xe
 5892 0204 3A       		.uleb128 0x3a
 5893 0205 0B       		.uleb128 0xb
 5894 0206 3B       		.uleb128 0x3b
 5895 0207 0B       		.uleb128 0xb
 5896 0208 49       		.uleb128 0x49
 5897 0209 13       		.uleb128 0x13
 5898 020a 3F       		.uleb128 0x3f
 5899 020b 19       		.uleb128 0x19
 5900 020c 02       		.uleb128 0x2
 5901 020d 18       		.uleb128 0x18
 5902 020e 00       		.byte	0
 5903 020f 00       		.byte	0
 5904 0210 00       		.byte	0
 5905              		.section	.debug_aranges,"",%progbits
 5906 0000 EC000000 		.4byte	0xec
 5907 0004 0200     		.2byte	0x2
 5908 0006 00000000 		.4byte	.Ldebug_info0
 5909 000a 04       		.byte	0x4
 5910 000b 00       		.byte	0
 5911 000c 0000     		.2byte	0
 5912 000e 0000     		.2byte	0
 5913 0010 00000000 		.4byte	.LFB0
 5914 0014 B0000000 		.4byte	.LFE0-.LFB0
 5915 0018 00000000 		.4byte	.LFB1
 5916 001c 8C000000 		.4byte	.LFE1-.LFB1
 5917 0020 00000000 		.4byte	.LFB2
 5918 0024 90000000 		.4byte	.LFE2-.LFB2
 5919 0028 00000000 		.4byte	.LFB3
 5920 002c 44000000 		.4byte	.LFE3-.LFB3
 5921 0030 00000000 		.4byte	.LFB4
 5922 0034 70010000 		.4byte	.LFE4-.LFB4
 5923 0038 00000000 		.4byte	.LFB5
 5924 003c E4000000 		.4byte	.LFE5-.LFB5
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 155


 5925 0040 00000000 		.4byte	.LFB6
 5926 0044 D4000000 		.4byte	.LFE6-.LFB6
 5927 0048 00000000 		.4byte	.LFB7
 5928 004c 60010000 		.4byte	.LFE7-.LFB7
 5929 0050 00000000 		.4byte	.LFB8
 5930 0054 4C010000 		.4byte	.LFE8-.LFB8
 5931 0058 00000000 		.4byte	.LFB9
 5932 005c 64010000 		.4byte	.LFE9-.LFB9
 5933 0060 00000000 		.4byte	.LFB10
 5934 0064 D0000000 		.4byte	.LFE10-.LFB10
 5935 0068 00000000 		.4byte	.LFB11
 5936 006c 80000000 		.4byte	.LFE11-.LFB11
 5937 0070 00000000 		.4byte	.LFB12
 5938 0074 30000000 		.4byte	.LFE12-.LFB12
 5939 0078 00000000 		.4byte	.LFB13
 5940 007c 3C000000 		.4byte	.LFE13-.LFB13
 5941 0080 00000000 		.4byte	.LFB14
 5942 0084 2C000000 		.4byte	.LFE14-.LFB14
 5943 0088 00000000 		.4byte	.LFB15
 5944 008c 40000000 		.4byte	.LFE15-.LFB15
 5945 0090 00000000 		.4byte	.LFB16
 5946 0094 B8000000 		.4byte	.LFE16-.LFB16
 5947 0098 00000000 		.4byte	.LFB17
 5948 009c 4C000000 		.4byte	.LFE17-.LFB17
 5949 00a0 00000000 		.4byte	.LFB18
 5950 00a4 C0000000 		.4byte	.LFE18-.LFB18
 5951 00a8 00000000 		.4byte	.LFB19
 5952 00ac 2C000000 		.4byte	.LFE19-.LFB19
 5953 00b0 00000000 		.4byte	.LFB20
 5954 00b4 38000000 		.4byte	.LFE20-.LFB20
 5955 00b8 00000000 		.4byte	.LFB21
 5956 00bc 30000000 		.4byte	.LFE21-.LFB21
 5957 00c0 00000000 		.4byte	.LFB22
 5958 00c4 3C000000 		.4byte	.LFE22-.LFB22
 5959 00c8 00000000 		.4byte	.LFB23
 5960 00cc 50000000 		.4byte	.LFE23-.LFB23
 5961 00d0 00000000 		.4byte	.LFB24
 5962 00d4 4C000000 		.4byte	.LFE24-.LFB24
 5963 00d8 00000000 		.4byte	.LFB25
 5964 00dc 54000000 		.4byte	.LFE25-.LFB25
 5965 00e0 00000000 		.4byte	.LFB26
 5966 00e4 66000000 		.4byte	.LFE26-.LFB26
 5967 00e8 00000000 		.4byte	0
 5968 00ec 00000000 		.4byte	0
 5969              		.section	.debug_ranges,"",%progbits
 5970              	.Ldebug_ranges0:
 5971 0000 00000000 		.4byte	.LFB0
 5972 0004 B0000000 		.4byte	.LFE0
 5973 0008 00000000 		.4byte	.LFB1
 5974 000c 8C000000 		.4byte	.LFE1
 5975 0010 00000000 		.4byte	.LFB2
 5976 0014 90000000 		.4byte	.LFE2
 5977 0018 00000000 		.4byte	.LFB3
 5978 001c 44000000 		.4byte	.LFE3
 5979 0020 00000000 		.4byte	.LFB4
 5980 0024 70010000 		.4byte	.LFE4
 5981 0028 00000000 		.4byte	.LFB5
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 156


 5982 002c E4000000 		.4byte	.LFE5
 5983 0030 00000000 		.4byte	.LFB6
 5984 0034 D4000000 		.4byte	.LFE6
 5985 0038 00000000 		.4byte	.LFB7
 5986 003c 60010000 		.4byte	.LFE7
 5987 0040 00000000 		.4byte	.LFB8
 5988 0044 4C010000 		.4byte	.LFE8
 5989 0048 00000000 		.4byte	.LFB9
 5990 004c 64010000 		.4byte	.LFE9
 5991 0050 00000000 		.4byte	.LFB10
 5992 0054 D0000000 		.4byte	.LFE10
 5993 0058 00000000 		.4byte	.LFB11
 5994 005c 80000000 		.4byte	.LFE11
 5995 0060 00000000 		.4byte	.LFB12
 5996 0064 30000000 		.4byte	.LFE12
 5997 0068 00000000 		.4byte	.LFB13
 5998 006c 3C000000 		.4byte	.LFE13
 5999 0070 00000000 		.4byte	.LFB14
 6000 0074 2C000000 		.4byte	.LFE14
 6001 0078 00000000 		.4byte	.LFB15
 6002 007c 40000000 		.4byte	.LFE15
 6003 0080 00000000 		.4byte	.LFB16
 6004 0084 B8000000 		.4byte	.LFE16
 6005 0088 00000000 		.4byte	.LFB17
 6006 008c 4C000000 		.4byte	.LFE17
 6007 0090 00000000 		.4byte	.LFB18
 6008 0094 C0000000 		.4byte	.LFE18
 6009 0098 00000000 		.4byte	.LFB19
 6010 009c 2C000000 		.4byte	.LFE19
 6011 00a0 00000000 		.4byte	.LFB20
 6012 00a4 38000000 		.4byte	.LFE20
 6013 00a8 00000000 		.4byte	.LFB21
 6014 00ac 30000000 		.4byte	.LFE21
 6015 00b0 00000000 		.4byte	.LFB22
 6016 00b4 3C000000 		.4byte	.LFE22
 6017 00b8 00000000 		.4byte	.LFB23
 6018 00bc 50000000 		.4byte	.LFE23
 6019 00c0 00000000 		.4byte	.LFB24
 6020 00c4 4C000000 		.4byte	.LFE24
 6021 00c8 00000000 		.4byte	.LFB25
 6022 00cc 54000000 		.4byte	.LFE25
 6023 00d0 00000000 		.4byte	.LFB26
 6024 00d4 66000000 		.4byte	.LFE26
 6025 00d8 00000000 		.4byte	0
 6026 00dc 00000000 		.4byte	0
 6027              		.section	.debug_line,"",%progbits
 6028              	.Ldebug_line0:
 6029 0000 13090000 		.section	.debug_str,"MS",%progbits,1
 6029      02004502 
 6029      00000201 
 6029      FB0E0D00 
 6029      01010101 
 6030              	.LASF47:
 6031 0000 75784E75 		.ascii	"uxNumberOfItems\000"
 6031      6D626572 
 6031      4F664974 
 6031      656D7300 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 157


 6032              	.LASF75:
 6033 0010 53656D61 		.ascii	"SemaphoreData\000"
 6033      70686F72 
 6033      65446174 
 6033      6100
 6034              	.LASF145:
 6035 001e 74736B54 		.ascii	"tskTaskControlBlock\000"
 6035      61736B43 
 6035      6F6E7472 
 6035      6F6C426C 
 6035      6F636B00 
 6036              	.LASF78:
 6037 0032 53656D61 		.ascii	"SemaphoreData_t\000"
 6037      70686F72 
 6037      65446174 
 6037      615F7400 
 6038              	.LASF113:
 6039 0042 78517565 		.ascii	"xQueueReceive\000"
 6039      75655265 
 6039      63656976 
 6039      6500
 6040              	.LASF119:
 6041 0050 78517565 		.ascii	"xQueueReceiveFromISR\000"
 6041      75655265 
 6041      63656976 
 6041      6546726F 
 6041      6D495352 
 6042              	.LASF64:
 6043 0065 78546173 		.ascii	"xTasksWaitingToReceive\000"
 6043      6B735761 
 6043      6974696E 
 6043      67546F52 
 6043      65636569 
 6044              	.LASF108:
 6045 007c 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 6045      67686572 
 6045      5072696F 
 6045      72697479 
 6045      5461736B 
 6046              	.LASF115:
 6047 0096 78517565 		.ascii	"xQueueSemaphoreTake\000"
 6047      75655365 
 6047      6D617068 
 6047      6F726554 
 6047      616B6500 
 6048              	.LASF0:
 6049 00aa 756E7369 		.ascii	"unsigned int\000"
 6049      676E6564 
 6049      20696E74 
 6049      00
 6050              	.LASF48:
 6051 00b7 7078496E 		.ascii	"pxIndex\000"
 6051      64657800 
 6052              	.LASF55:
 6053 00bf 7854494D 		.ascii	"xTIME_OUT\000"
 6053      455F4F55 
 6053      5400
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 158


 6054              	.LASF96:
 6055 00c9 70784E65 		.ascii	"pxNewQueue\000"
 6055      77517565 
 6055      756500
 6056              	.LASF40:
 6057 00d4 784C4953 		.ascii	"xLIST_ITEM\000"
 6057      545F4954 
 6057      454D00
 6058              	.LASF83:
 6059 00df 51554555 		.ascii	"QUEUE_REGISTRY_ITEM\000"
 6059      455F5245 
 6059      47495354 
 6059      52595F49 
 6059      54454D00 
 6060              	.LASF144:
 6061 00f3 443A5C55 		.ascii	"D:\\Users\\Jason\\Documents\\Jason's Work\\Labs\\EC"
 6061      73657273 
 6061      5C4A6173 
 6061      6F6E5C44 
 6061      6F63756D 
 6062 0120 45473732 		.ascii	"EG721Project\\PSoCProject\\PSoC_4_BLE_CapSense_Prox"
 6062      3150726F 
 6062      6A656374 
 6062      5C50536F 
 6062      4350726F 
 6063 0151 696D6974 		.ascii	"imity.cydsn\000"
 6063      792E6379 
 6063      64736E00 
 6064              	.LASF142:
 6065 015d 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 6065      43313120 
 6065      352E342E 
 6065      31203230 
 6065      31363036 
 6066 0190 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m0 -mthumb -g -O"
 6066      20726576 
 6066      6973696F 
 6066      6E203233 
 6066      37373135 
 6067 01c3 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 6067      66756E63 
 6067      74696F6E 
 6067      2D736563 
 6067      74696F6E 
 6068              	.LASF26:
 6069 01eb 53746174 		.ascii	"StaticMiniListItem_t\000"
 6069      69634D69 
 6069      6E694C69 
 6069      73744974 
 6069      656D5F74 
 6070              	.LASF140:
 6071 0200 78576169 		.ascii	"xWaitIndefinitely\000"
 6071      74496E64 
 6071      6566696E 
 6071      6974656C 
 6071      7900
 6072              	.LASF63:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 159


 6073 0212 78546173 		.ascii	"xTasksWaitingToSend\000"
 6073      6B735761 
 6073      6974696E 
 6073      67546F53 
 6073      656E6400 
 6074              	.LASF123:
 6075 0226 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 6075      65756553 
 6075      70616365 
 6075      73417661 
 6075      696C6162 
 6076              	.LASF69:
 6077 023d 6354784C 		.ascii	"cTxLock\000"
 6077      6F636B00 
 6078              	.LASF56:
 6079 0245 784F7665 		.ascii	"xOverflowCount\000"
 6079      72666C6F 
 6079      77436F75 
 6079      6E7400
 6080              	.LASF82:
 6081 0254 51756575 		.ascii	"Queue_t\000"
 6081      655F7400 
 6082              	.LASF103:
 6083 025c 78436F70 		.ascii	"xCopyPosition\000"
 6083      79506F73 
 6083      6974696F 
 6083      6E00
 6084              	.LASF122:
 6085 026a 75785265 		.ascii	"uxReturn\000"
 6085      7475726E 
 6085      00
 6086              	.LASF87:
 6087 0273 51756575 		.ascii	"QueueRegistryItem_t\000"
 6087      65526567 
 6087      69737472 
 6087      79497465 
 6087      6D5F7400 
 6088              	.LASF134:
 6089 0287 76517565 		.ascii	"vQueueDelete\000"
 6089      75654465 
 6089      6C657465 
 6089      00
 6090              	.LASF73:
 6091 0294 70635265 		.ascii	"pcReadFrom\000"
 6091      61644672 
 6091      6F6D00
 6092              	.LASF138:
 6093 029f 76517565 		.ascii	"vQueueUnregisterQueue\000"
 6093      7565556E 
 6093      72656769 
 6093      73746572 
 6093      51756575 
 6094              	.LASF110:
 6095 02b5 75785361 		.ascii	"uxSavedInterruptStatus\000"
 6095      76656449 
 6095      6E746572 
 6095      72757074 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 160


 6095      53746174 
 6096              	.LASF126:
 6097 02cc 70727649 		.ascii	"prvInitialiseNewQueue\000"
 6097      6E697469 
 6097      616C6973 
 6097      654E6577 
 6097      51756575 
 6098              	.LASF20:
 6099 02e2 75696E74 		.ascii	"uint32_t\000"
 6099      33325F74 
 6099      00
 6100              	.LASF17:
 6101 02eb 696E7438 		.ascii	"int8_t\000"
 6101      5F7400
 6102              	.LASF105:
 6103 02f2 78596965 		.ascii	"xYieldRequired\000"
 6103      6C645265 
 6103      71756972 
 6103      656400
 6104              	.LASF79:
 6105 0301 78517565 		.ascii	"xQueue\000"
 6105      756500
 6106              	.LASF60:
 6107 0308 51756575 		.ascii	"QueueDefinition\000"
 6107      65446566 
 6107      696E6974 
 6107      696F6E00 
 6108              	.LASF14:
 6109 0318 6C6F6E67 		.ascii	"long long unsigned int\000"
 6109      206C6F6E 
 6109      6720756E 
 6109      7369676E 
 6109      65642069 
 6110              	.LASF130:
 6111 032f 70727649 		.ascii	"prvIsQueueEmpty\000"
 6111      73517565 
 6111      7565456D 
 6111      70747900 
 6112              	.LASF114:
 6113 033f 70764275 		.ascii	"pvBuffer\000"
 6113      66666572 
 6113      00
 6114              	.LASF93:
 6115 0348 70785374 		.ascii	"pxStaticQueue\000"
 6115      61746963 
 6115      51756575 
 6115      6500
 6116              	.LASF43:
 6117 0356 70785072 		.ascii	"pxPrevious\000"
 6117      6576696F 
 6117      757300
 6118              	.LASF9:
 6119 0361 5F5F7569 		.ascii	"__uint16_t\000"
 6119      6E743136 
 6119      5F7400
 6120              	.LASF65:
 6121 036c 75784D65 		.ascii	"uxMessagesWaiting\000"
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 161


 6121      73736167 
 6121      65735761 
 6121      6974696E 
 6121      6700
 6122              	.LASF80:
 6123 037e 7853656D 		.ascii	"xSemaphore\000"
 6123      6170686F 
 6123      726500
 6124              	.LASF117:
 6125 0389 78517565 		.ascii	"xQueuePeek\000"
 6125      75655065 
 6125      656B00
 6126              	.LASF104:
 6127 0394 78456E74 		.ascii	"xEntryTimeSet\000"
 6127      72795469 
 6127      6D655365 
 6127      7400
 6128              	.LASF3:
 6129 03a2 73697A65 		.ascii	"size_t\000"
 6129      5F7400
 6130              	.LASF106:
 6131 03a9 7854696D 		.ascii	"xTimeOut\000"
 6131      654F7574 
 6131      00
 6132              	.LASF85:
 6133 03b2 7848616E 		.ascii	"xHandle\000"
 6133      646C6500 
 6134              	.LASF84:
 6135 03ba 70635175 		.ascii	"pcQueueName\000"
 6135      6575654E 
 6135      616D6500 
 6136              	.LASF51:
 6137 03c6 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 6137      495F4C49 
 6137      53545F49 
 6137      54454D00 
 6138              	.LASF46:
 6139 03d6 784C4953 		.ascii	"xLIST\000"
 6139      5400
 6140              	.LASF107:
 6141 03dc 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 6141      75654765 
 6141      6E657269 
 6141      6353656E 
 6141      6446726F 
 6142              	.LASF34:
 6143 03f5 70764475 		.ascii	"pvDummy1\000"
 6143      6D6D7931 
 6143      00
 6144              	.LASF32:
 6145 03fe 70764475 		.ascii	"pvDummy2\000"
 6145      6D6D7932 
 6145      00
 6146              	.LASF25:
 6147 0407 70764475 		.ascii	"pvDummy3\000"
 6147      6D6D7933 
 6147      00
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 162


 6148              	.LASF29:
 6149 0410 75784475 		.ascii	"uxDummy2\000"
 6149      6D6D7932 
 6149      00
 6150              	.LASF36:
 6151 0419 75784475 		.ascii	"uxDummy4\000"
 6151      6D6D7934 
 6151      00
 6152              	.LASF129:
 6153 0422 70727643 		.ascii	"prvCopyDataToQueue\000"
 6153      6F707944 
 6153      61746154 
 6153      6F517565 
 6153      756500
 6154              	.LASF100:
 6155 0435 78517565 		.ascii	"xQueueGenericSend\000"
 6155      75654765 
 6155      6E657269 
 6155      6353656E 
 6155      6400
 6156              	.LASF70:
 6157 0447 75635374 		.ascii	"ucStaticallyAllocated\000"
 6157      61746963 
 6157      616C6C79 
 6157      416C6C6F 
 6157      63617465 
 6158              	.LASF67:
 6159 045d 75784974 		.ascii	"uxItemSize\000"
 6159      656D5369 
 6159      7A6500
 6160              	.LASF111:
 6161 0468 75785072 		.ascii	"uxPreviousMessagesWaiting\000"
 6161      6576696F 
 6161      75734D65 
 6161      73736167 
 6161      65735761 
 6162              	.LASF16:
 6163 0482 63686172 		.ascii	"char\000"
 6163      00
 6164              	.LASF50:
 6165 0487 4C697374 		.ascii	"ListItem_t\000"
 6165      4974656D 
 6165      5F7400
 6166              	.LASF132:
 6167 0492 70727649 		.ascii	"prvIsQueueFull\000"
 6167      73517565 
 6167      75654675 
 6167      6C6C00
 6168              	.LASF71:
 6169 04a1 51756575 		.ascii	"QueuePointers\000"
 6169      65506F69 
 6169      6E746572 
 6169      7300
 6170              	.LASF22:
 6171 04af 55426173 		.ascii	"UBaseType_t\000"
 6171      65547970 
 6171      655F7400 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 163


 6172              	.LASF112:
 6173 04bb 78517565 		.ascii	"xQueueGiveFromISR\000"
 6173      75654769 
 6173      76654672 
 6173      6F6D4953 
 6173      5200
 6174              	.LASF141:
 6175 04cd 78517565 		.ascii	"xQueueRegistry\000"
 6175      75655265 
 6175      67697374 
 6175      727900
 6176              	.LASF59:
 6177 04dc 51756575 		.ascii	"QueueHandle_t\000"
 6177      6548616E 
 6177      646C655F 
 6177      7400
 6178              	.LASF49:
 6179 04ea 784C6973 		.ascii	"xListEnd\000"
 6179      74456E64 
 6179      00
 6180              	.LASF124:
 6181 04f3 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 6181      6575654D 
 6181      65737361 
 6181      67657357 
 6181      61697469 
 6182              	.LASF52:
 6183 0511 4D696E69 		.ascii	"MiniListItem_t\000"
 6183      4C697374 
 6183      4974656D 
 6183      5F7400
 6184              	.LASF18:
 6185 0520 75696E74 		.ascii	"uint8_t\000"
 6185      385F7400 
 6186              	.LASF86:
 6187 0528 78517565 		.ascii	"xQueueRegistryItem\000"
 6187      75655265 
 6187      67697374 
 6187      72794974 
 6187      656D00
 6188              	.LASF98:
 6189 053b 78517565 		.ascii	"xQueueGenericCreate\000"
 6189      75654765 
 6189      6E657269 
 6189      63437265 
 6189      61746500 
 6190              	.LASF28:
 6191 054f 78535441 		.ascii	"xSTATIC_LIST\000"
 6191      5449435F 
 6191      4C495354 
 6191      00
 6192              	.LASF1:
 6193 055c 6C6F6E67 		.ascii	"long long int\000"
 6193      206C6F6E 
 6193      6720696E 
 6193      7400
 6194              	.LASF21:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 164


 6195 056a 42617365 		.ascii	"BaseType_t\000"
 6195      54797065 
 6195      5F7400
 6196              	.LASF92:
 6197 0575 70756351 		.ascii	"pucQueueStorage\000"
 6197      75657565 
 6197      53746F72 
 6197      61676500 
 6198              	.LASF57:
 6199 0585 7854696D 		.ascii	"xTimeOnEntering\000"
 6199      654F6E45 
 6199      6E746572 
 6199      696E6700 
 6200              	.LASF135:
 6201 0595 76517565 		.ascii	"vQueueAddToRegistry\000"
 6201      75654164 
 6201      64546F52 
 6201      65676973 
 6201      74727900 
 6202              	.LASF42:
 6203 05a9 70784E65 		.ascii	"pxNext\000"
 6203      787400
 6204              	.LASF39:
 6205 05b0 53746174 		.ascii	"StaticQueue_t\000"
 6205      69635175 
 6205      6575655F 
 6205      7400
 6206              	.LASF58:
 6207 05be 54696D65 		.ascii	"TimeOut_t\000"
 6207      4F75745F 
 6207      7400
 6208              	.LASF118:
 6209 05c8 70634F72 		.ascii	"pcOriginalReadPosition\000"
 6209      6967696E 
 6209      616C5265 
 6209      6164506F 
 6209      73697469 
 6210              	.LASF54:
 6211 05df 5461736B 		.ascii	"TaskHandle_t\000"
 6211      48616E64 
 6211      6C655F74 
 6211      00
 6212              	.LASF94:
 6213 05ec 75635175 		.ascii	"ucQueueType\000"
 6213      65756554 
 6213      79706500 
 6214              	.LASF53:
 6215 05f8 4C697374 		.ascii	"List_t\000"
 6215      5F7400
 6216              	.LASF116:
 6217 05ff 75785365 		.ascii	"uxSemaphoreCount\000"
 6217      6D617068 
 6217      6F726543 
 6217      6F756E74 
 6217      00
 6218              	.LASF62:
 6219 0610 70635772 		.ascii	"pcWriteTo\000"
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 165


 6219      69746554 
 6219      6F00
 6220              	.LASF23:
 6221 061a 5469636B 		.ascii	"TickType_t\000"
 6221      54797065 
 6221      5F7400
 6222              	.LASF4:
 6223 0625 5F5F696E 		.ascii	"__int8_t\000"
 6223      74385F74 
 6223      00
 6224              	.LASF137:
 6225 062e 70635265 		.ascii	"pcReturn\000"
 6225      7475726E 
 6225      00
 6226              	.LASF91:
 6227 0637 75785175 		.ascii	"uxQueueLength\000"
 6227      6575654C 
 6227      656E6774 
 6227      6800
 6228              	.LASF2:
 6229 0645 6C6F6E67 		.ascii	"long double\000"
 6229      20646F75 
 6229      626C6500 
 6230              	.LASF19:
 6231 0651 75696E74 		.ascii	"uint16_t\000"
 6231      31365F74 
 6231      00
 6232              	.LASF37:
 6233 065a 75634475 		.ascii	"ucDummy5\000"
 6233      6D6D7935 
 6233      00
 6234              	.LASF38:
 6235 0663 75634475 		.ascii	"ucDummy6\000"
 6235      6D6D7936 
 6235      00
 6236              	.LASF136:
 6237 066c 70635175 		.ascii	"pcQueueGetName\000"
 6237      65756547 
 6237      65744E61 
 6237      6D6500
 6238              	.LASF74:
 6239 067b 51756575 		.ascii	"QueuePointers_t\000"
 6239      65506F69 
 6239      6E746572 
 6239      735F7400 
 6240              	.LASF97:
 6241 068b 7853697A 		.ascii	"xSize\000"
 6241      6500
 6242              	.LASF66:
 6243 0691 75784C65 		.ascii	"uxLength\000"
 6243      6E677468 
 6243      00
 6244              	.LASF139:
 6245 069a 76517565 		.ascii	"vQueueWaitForMessageRestricted\000"
 6245      75655761 
 6245      6974466F 
 6245      724D6573 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 166


 6245      73616765 
 6246              	.LASF8:
 6247 06b9 73686F72 		.ascii	"short int\000"
 6247      7420696E 
 6247      7400
 6248              	.LASF41:
 6249 06c3 78497465 		.ascii	"xItemValue\000"
 6249      6D56616C 
 6249      756500
 6250              	.LASF11:
 6251 06ce 6C6F6E67 		.ascii	"long int\000"
 6251      20696E74 
 6251      00
 6252              	.LASF99:
 6253 06d7 78517565 		.ascii	"xQueueSizeInBytes\000"
 6253      75655369 
 6253      7A65496E 
 6253      42797465 
 6253      7300
 6254              	.LASF101:
 6255 06e9 70764974 		.ascii	"pvItemToQueue\000"
 6255      656D546F 
 6255      51756575 
 6255      6500
 6256              	.LASF133:
 6257 06f7 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 6257      75654973 
 6257      51756575 
 6257      6546756C 
 6257      6C46726F 
 6258              	.LASF121:
 6259 0710 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 6259      6575654D 
 6259      65737361 
 6259      67657357 
 6259      61697469 
 6260              	.LASF72:
 6261 0727 70635461 		.ascii	"pcTail\000"
 6261      696C00
 6262              	.LASF6:
 6263 072e 5F5F7569 		.ascii	"__uint8_t\000"
 6263      6E74385F 
 6263      7400
 6264              	.LASF90:
 6265 0738 78517565 		.ascii	"xQueueGenericCreateStatic\000"
 6265      75654765 
 6265      6E657269 
 6265      63437265 
 6265      61746553 
 6266              	.LASF95:
 6267 0752 70785175 		.ascii	"pxQueue\000"
 6267      65756500 
 6268              	.LASF88:
 6269 075a 784E6577 		.ascii	"xNewQueue\000"
 6269      51756575 
 6269      6500
 6270              	.LASF109:
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 167


 6271 0764 78526574 		.ascii	"xReturn\000"
 6271      75726E00 
 6272              	.LASF15:
 6273 076c 73697A65 		.ascii	"sizetype\000"
 6273      74797065 
 6273      00
 6274              	.LASF13:
 6275 0775 6C6F6E67 		.ascii	"long unsigned int\000"
 6275      20756E73 
 6275      69676E65 
 6275      6420696E 
 6275      7400
 6276              	.LASF77:
 6277 0787 75785265 		.ascii	"uxRecursiveCallCount\000"
 6277      63757273 
 6277      69766543 
 6277      616C6C43 
 6277      6F756E74 
 6278              	.LASF143:
 6279 079c 2E2E5C46 		.ascii	"..\\FreeRTOS\\Source\\queue.c\000"
 6279      72656552 
 6279      544F535C 
 6279      536F7572 
 6279      63655C71 
 6280              	.LASF120:
 6281 07b7 78517565 		.ascii	"xQueuePeekFromISR\000"
 6281      75655065 
 6281      656B4672 
 6281      6F6D4953 
 6281      5200
 6282              	.LASF45:
 6283 07c9 7078436F 		.ascii	"pxContainer\000"
 6283      6E746169 
 6283      6E657200 
 6284              	.LASF7:
 6285 07d5 756E7369 		.ascii	"unsigned char\000"
 6285      676E6564 
 6285      20636861 
 6285      7200
 6286              	.LASF12:
 6287 07e3 5F5F7569 		.ascii	"__uint32_t\000"
 6287      6E743332 
 6287      5F7400
 6288              	.LASF127:
 6289 07ee 70727643 		.ascii	"prvCopyDataFromQueue\000"
 6289      6F707944 
 6289      61746146 
 6289      726F6D51 
 6289      75657565 
 6290              	.LASF102:
 6291 0803 78546963 		.ascii	"xTicksToWait\000"
 6291      6B73546F 
 6291      57616974 
 6291      00
 6292              	.LASF44:
 6293 0810 70764F77 		.ascii	"pvOwner\000"
 6293      6E657200 
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 168


 6294              	.LASF24:
 6295 0818 7844756D 		.ascii	"xDummy2\000"
 6295      6D793200 
 6296              	.LASF35:
 6297 0820 7844756D 		.ascii	"xDummy3\000"
 6297      6D793300 
 6298              	.LASF30:
 6299 0828 7844756D 		.ascii	"xDummy4\000"
 6299      6D793400 
 6300              	.LASF61:
 6301 0830 70634865 		.ascii	"pcHead\000"
 6301      616400
 6302              	.LASF27:
 6303 0837 78535441 		.ascii	"xSTATIC_MINI_LIST_ITEM\000"
 6303      5449435F 
 6303      4D494E49 
 6303      5F4C4953 
 6303      545F4954 
 6304              	.LASF128:
 6305 084e 70727655 		.ascii	"prvUnlockQueue\000"
 6305      6E6C6F63 
 6305      6B517565 
 6305      756500
 6306              	.LASF89:
 6307 085d 78517565 		.ascii	"xQueueGenericReset\000"
 6307      75654765 
 6307      6E657269 
 6307      63526573 
 6307      657400
 6308              	.LASF131:
 6309 0870 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 6309      75654973 
 6309      51756575 
 6309      65456D70 
 6309      74794672 
 6310              	.LASF5:
 6311 088a 7369676E 		.ascii	"signed char\000"
 6311      65642063 
 6311      68617200 
 6312              	.LASF10:
 6313 0896 73686F72 		.ascii	"short unsigned int\000"
 6313      7420756E 
 6313      7369676E 
 6313      65642069 
 6313      6E7400
 6314              	.LASF81:
 6315 08a9 78515545 		.ascii	"xQUEUE\000"
 6315      554500
 6316              	.LASF76:
 6317 08b0 784D7574 		.ascii	"xMutexHolder\000"
 6317      6578486F 
 6317      6C646572 
 6317      00
 6318              	.LASF125:
 6319 08bd 78506F73 		.ascii	"xPosition\000"
 6319      6974696F 
 6319      6E00
ARM GAS  C:\Users\Jason\AppData\Local\Temp\ccMsFGiZ.s 			page 169


 6320              	.LASF68:
 6321 08c7 6352784C 		.ascii	"cRxLock\000"
 6321      6F636B00 
 6322              	.LASF33:
 6323 08cf 78535441 		.ascii	"xSTATIC_QUEUE\000"
 6323      5449435F 
 6323      51554555 
 6323      4500
 6324              	.LASF31:
 6325 08dd 53746174 		.ascii	"StaticList_t\000"
 6325      69634C69 
 6325      73745F74 
 6325      00
 6326              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
